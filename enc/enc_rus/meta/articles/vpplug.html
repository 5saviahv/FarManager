<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Написание плагинов на Virtual Pascal 2.0</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:raven66@mail.ru">
<meta NAME="Author" content="Dmitry Suhodoev">
<meta NAME="description" CONTENT="How to reduce size plugin. On example of compiler Watcom C v11">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<!-- History of modification:
 Date: Nov 10 1999
   Author: Valentin Skirdin
   E-mail: vskirdin@mail.ru
-->
<body>

<a name="top"></a>
<h1>Написание плагинов на Virtual Pascal 2.0</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right>
<code>Дмитрий Суходоев <a href="mailto:Dmitry%20Suhodoev%20<raven66@mail.ru>?subject=Virtual Pascal for FAR plugins programming">
<img src="../../images/email.gif" border="0" alt="[raven66@mail.ru]" width="16" height="16" align="middle">raven66@mail.ru</a>
</code></div>
<hr color="#003399">

  <p class=plain>
   Сначала хочу немного рассказать про этот самый Virtual Pascal 2.0. Все
   таки для пользователей Win32 - это довольно неизвестный компилятор. Первая
   версия этого компилятора была разработана в Киевском Институте Кибернетики
   Виталием Мирьяновым (хотя институт тут помог только тем, что предоставлял
   машины для работы). Большая часть ядро Virtual Pascal была написана на i386
   с 4 мегобайтами памяти и поэтому была даже для того времени очень
   оптимизирована. В июне 1995 была выпущена публичная бета версия Virtual
   Pascal для OS/2, и тогда с Виталием связалась британская компания fPrint в
   лице Аллана Мертнера и предложила свою помощью в разработке и поддержке
   продукта и место жительства в UK. В итоге у них получился Virtual Pascal
   v1.11 для OS/2. Сейчас уже доступен релиз Virtual Pascal 2.0, который
   насчитывает всего около 200 пользователей. Здесь я не считаю тех
   пользователей, которые украли, этот прекрасный компилятор.</p>
  <p class=plain>
   Самая главная особенность, которая меня привлекла в Virtual Pascal 2.0
   это его почти 100% совместимость с таким достаточно известном компилятором
   Borland Pascal 7.0, а также одновременная (частичная) совместимость с
   Borland Delphi 3, с использованием классов. Нельзя не упомянуть то, что в
   Virtual Pascal вложены скомпиленная библиотека Turbo Vision 2.0, а также
   патчи для стандартных исходников от Borland и патчи для библиотеки Object
   Professional 1.30 от Turbo Power Software.
  </p>
  <p class=plain>
   При первых попытках написания простого плагина на Virtual Pascal 2.0
   я, естественно, столкнулся с тем, что мне нужен был аналог plugin.hpp, но
   для паскаля. FarIntf.pas не подходил, по тем причинам, что он был
   достаточно неплохо заточен под Borland Delphi 4, что вобщем-то и осложнило
   его компиляцию под Virtual Pascal 2.0. короче говоря - собрать я собрал, а
   вот работать оно не захотело :-)
  <p class=plain>
   Ну немного побездельничав, попросил у
   <a href="mailto:Vasily V Moshninov <vmoshninov@chat.ru>?subject=delphi FAR api">Василия Мошнинова</a>
   исходники аналога plugin.hpp в его варианте и небольшой
   hello world тоже для его plugin.pas. После небольшой правки все заработало на
   &laquo;ура&raquo;, что подтолкнуло меня сделать то чего мне так давно в FAR не хватало.
  <p class=plain>
   Особых отличий написания плагинов на Virtual Pascal 2.0 от дельфи нет,
   но все таки есть такая обязательная комбинация директив компилятора, без
   которых собрать что-либо работающее на Virtual Pascal 2.0 для FAR будет
   просто невозможным.
   <br>
  <ul>
   <li>
    Huge Strings. В Дельфи они по умолчанию включены. В Virtual Pascal
    2.0 для пущей совместимости с bp7 они выключены, поэтому для начала {&amp;H+}.
    А нужны они в первую очередь для того, чтобы организовать большую
    совместимость с нуль-терминальными строками pChar, т.е. с ними можно
    сделать так: pChar(String) - и это будет верным, то есть компилятор на это
    не будет ругаться.
   <li>
    Use32. В дельфи такого понятия как Use32 вроде даже и нет. Попытаюсь
    объяснить что это такое. Так как Virtual Pascal 2.0 должен быть совместим
    с bp7, то все данные типы целочисленный переменных у него аналогичны типам
    bp7, т.е. Word, Integer занимают два байта, ShortInt, Byte занимают один
    байт, а четыре байта занимает только Longint и Cardinal. Но также Virtual
    Pascal 2.0 должен обеспечивать совместимость с третьей дельфей, а там типы
    Integer и Word приравнены в типу Longint, (т.е. занимают четыре байта),
    что и правильно - какой вин не любит кушать много памяти :-) Ну и
    соответственно эту директиву выключают для обеспечения совместимости с
    дельфи и включают для совместимости с bp7. В нашем случае она должна быть
    включена, т.к. все структуры в стандартном plugin.hpp расписаны тем самым
    четырехбайтным Integer. Короче говоря вот он этот модуль Use32.pas</li>
    <pre class=code>unit Use32;
{$Use32-}
interface
type
{$IfDef Use32}
 Integer    = System.Longint;
 Word       = System.Longint;
const
 MaxInt     = MaxLongint;
{$Else}
 SmallInt   = System.Integer;
 SmallWord  = System.Word;
{$EndIf}
type
 PByte      = ^Byte;
 PWord      = ^Word;
 PLongint   = ^Longint;
 PSmallInt  = ^SmallInt;
 PSmallWord = ^SmallWord;
implementation
end.
</pre>
    <li>
    Еще в Virtual Pascal 2.0 я лично наткнулся на такие грабли, что
    перечисляемые типы всегда занимали один байт, а в plugin.hpp - четыре.
    Василий Мошнинов упорно :) советовал мне {$MINENUMSIZE 4} и {$ALIGN OFF},
    не зная, что Virtual Pascal 2.0 на эти директивы матом :-) Я почти три дня
    думал что в Virtual Pascal 2.0 подобных директив нет, и просто забивал
    оставшееся пространство массивом из трех символов, пока не почитал
    документацию. Короче говоря подобное в Virtual Pascal 2.0 будет выглядеть
    ровно так: <code>{&amp;AlignRec+,Z+}</code>
   <li>
    В итоге получаем директиву: <code>{&amp;H+,Use32+,Z+,AlignRec+}</code>
   <li>
    Что ставить в начале: begin или initialization? Я, собственно, не
    хочу пересказывать документацию по Virtual Pascal, но тем не менее
    расскажу, так как сам наступал на эти грабли. Зарезервированное слово
    inittialization заставляет компилятор вставлять в dll инициализирующий
    код, то есть тот код, который идет в implementation секции каждого модуля
    (unit), подключенного к программе. Вообще для ФАРовского плагина это не
    нужно (или нужно только для отладки), так как все действия, к которым
    подготавливает этот код (например вывод текста с помощью <code>WriteLn</code> для
    модуля Crt, etc..), можно сделать с помощью ФАРовского api. То есть в
    ФАРовских плагинах надо делать begin, а <code>initialization</code> только для отладки,
    например для вывода отладочного текста в лоб с помощью процедур Write и
    <code>WriteLn</code>. При постановке <code>initialization</code> в dll у меня было замечено довольно
    странное поведение некоторых моих плагинов, в частности, true macro
    редакторе совершенно от балды выдавал откуда-то макросы, причем там, где
    их не должно было быть. Когда поставил begin - стало все нормально.
    <p class=plain>
    Что касается использования библиотеки Turbo Vision 2.0 for Win32 в
    плагинах. Для нее как раз нужно ставить initialization. Почему? Если
    стандартный модуль drivers.pas не проведет инициализацию, то в лучшем
    случае у Вас ничего не запустится. В худшем будет просто gpf ;-) Но одного
    <code>initialization</code> вообще всегда мало. Инициализация, выделение памяти прошло.
    А кто же будет высвобождать эту память? В обычном exe этим занимается
    ExitProc - указатель на процедуру деинициализации. В dll он тоже есть, но
    почему-то при выгрузке он не вызывается. Возможно, это баг Virtual Pascal.
    Поэтому нужно импортировать ФАРу процедуру <a href="../exported_functions/exitfar.html">ExitFAR</a> и там насильно вызывать
    <code>ExitProc</code>. Я делаю это так:

<pre class=code>procedure ExitFAR; assembler;
 asm
  call ExitProc;
 end;
</pre>

   </ul>

  <p class=plain>
   Дальше идут необязательные советы, без них работать уже будет, но с ними
   просто легче.
   <br>
   <ul>
   <li>
    Чем Virtual Pascal 2.0 хорош, по отношению к дельфи, так это тем, что
    не надо писать для каждой процедуры stdcall. Достаточно в начале модуля
    поставить директиву компилятора <code>{&amp;StdCall+}</code> и все процедуры и функции,
    которые будут за ней идти будут подразумеваться как stdcall.
    <li>
    Да, ради справедливости надо заметить, что в стандартном windows.pas
    от Virtual Pascal 2.0 есть такой прикольный баг: значения
    HKEY_CURRENT_USER и HKEY_LOCAL_MACHINE перепутаны местами, так что если
    что-то заработало не так, то надо их прописать нормально :)
  </ul>
  <p class=plain>
   Кстати сказать, что именно с помощью Virtual Pascal 2.0 намного лучше
   и экономичней компилять плагины. И не только к ФАРу. Вот я читаю
   PLUGINSR.HLP и сочувствую наСИльникам: всегда надо как-то извратиться,
   чтобы получить маленький размер плагина. На дельфи тоже самое, но там уже
   проще: можно выкинуть модуль SysUtils и спокойно себе скомпилять плагин
   небольшого размера, другое дело, что без SysUtils в дельфи ничего не
   сделаешь. А на Virtual Pascal 2.0 самое то! SysUtils в нем тоже есть, но в
   отличии от дельфи без SysUtils в Virtual Pascal 2.0 можно прожить, да
   причем прожить припеваючи! Есть все для этого замены: модуль Dos (для
   работы с диском), модуль Strings (для работы с pChar), а большего от
   SysUtils никто и не требовал, т.к. исключения (exceptions) плагинам
   по-моему мнению совсем не нужны. Наконец в Virtual Pascal 2.0 есть Turbo
   Vision для Win32, что дает более гибкие возможности по сравнению со
   стандартными ФАРовскими диалогами. Применение его в плагинах уже дает
   замечательные результаты (смотри плагины rAscii, color selector).
  <p class=plain>
   Модуль plugin.pas Василия Мошнинова был несколько переделан мной на
   лад Virtual Pascal 2.0, туда я добавил функции для работы с реестром, для
   обработки масок. Смысла здесь их публиковать я не вижу, кому интересно
   может взять
   <a target="_blank" href="http://raven66.newmail.ru/far/plugin.rar">архив с модулем</a>
   на моей страничке.
  <p class=plain>
   Почти там же лежат интерфесы для работы с регулярными выражениями
   используя плагин
   <a href="mailto: Igor Ruskih <ruiv@uic.nnov.ru>">Игоря Русских</a>
        Colorer 3.0. Оно тоже переписано мной для Virtual Pascal 2.0, но при
   достаточной сноровке это запросто можно собрать с помощью какой-нибудь из
   семейства дельфей. Лежит
   <a target="_blank" href="http://raven66.newmail.ru/far/colorerpas.rar">тут</a>.

<div align=right><code>
<br>(c) raVen&nbsp;<br>
21.02.2000<br>
Rev 30.04.2000
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>