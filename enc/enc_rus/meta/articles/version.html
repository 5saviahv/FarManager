<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Плагин для разных версий FAR Manager.</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:vskirdin@mail.ru">
<meta name="Author" content="Valentin Skirdin">
<meta name="description" content="Плагин для разных версий FAR Manager.">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<!-- History of modification:
 Date: Sep 09 1999
   Author: Valentin Skirdin
   E-mail: vskirdin@mail.ru
-->
<body>

<a name="top"></a>
<h1>Плагин для разных версий FAR Manager.</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
FAR Group<br>
</code></div>
<hr color="#003399">

<p class=plain>С выходом в свет FAR manager версии 1.70 произошли некоторые
изменения в части инициализации плагина (<b>что ни в коем случае не скажется на
работоспособности ранее написанных плагинов</b>), хотя старый метод
инициализации также остался работоспособным. После добавления в
<a href="../structures/pluginstartupinfo.html">PluginStartupInfo</a>
указателя на структуру <a href="../fsf/index.html">FSF</a>, содержащей
указатели на стандартные функции FAR, стало возможным уменьшить размер
плагинов за счёт использования функций, находящихся в теле Far.exe.
Использование новой экспортной функции <a href="../exported_functions/getminfarversion.html">GetMinFarVersion</a> позволяет
осуществлять контроль за версией FAR со стороны плагина. Теперь
немного примеров.<br><br></p>

<p class=plain>Для начала корректно напишем функцию <dfn>SetStartupInfo</dfn>:</p>

<pre class=code>char PluginRootKey[80];
static struct PluginStartupInfo Info;
static struct FarStandardFunctions FSF;

void WINAPI SetStartupInfo(struct PluginStartupInfo *PSInfo)
{
  if(PSInfo-&gt;StructSize &gt;= sizeof(struct PluginStartupInfo))
  {
    Info=*PSInfo;
    FSF=*PSInfo.FSF;
    Info.FSF=&amp;FSF;
    ...
  }
  else
    memcpy(&amp;Info,PSInfo,PSInfo-&gt;StructSize);
}</pre>

<p class=plain>Начиная с FAR 1.70 нужна функция <dfn>GetMinFarVersion</dfn>,
при этом FAR сам проследит за запуском плагина.</p>
<pre class=code>int WINAPI GetMinFarVersion(void)
{
  return FARMANAGERVERSION;
}</pre>

<p class=plain>Естественно, что пуская плагин в 1.65 (и ниже) FAR не
отреагирует на <dfn>GetMinFarVersion</dfn> - про эту функцию он просто не
знает. Поэтому...</p>

<p class=plain>Следующий шаг - <dfn>GetPluginInfo</dfn> (или <dfn>OpenPlugin</dfn>).
Если предполагается, что плагин будет работать только с планируемой версией FAR
Manager (и выше), то достаточно выдать об этом сообщение и вывалить, если
версия меньше планируемой - сравнить размер структуры <dfn>PluginStartupInfo</dfn> с полем
PluginStartupInfo.<dfn>StructSize</dfn>:</p>

<pre class=code>void WINAPI GetPluginInfo(struct PluginInfo *Info)
{
  if(Info.StructSize &lt; sizeof(struct PluginStartupInfo))
  {
    // Выводим сообщение: <b>"Этот плагин требует FAR Manager версии N.NN и выше!"</b>
    return;
  }
  .
  .
  .
}</pre>

<p class=plain>Добавив подобную проверку в <dfn>GetPluginInfo</dfn> мы добиваемся
того, что плагин вообще нигде не появляется. Если эту проверку делать в <dfn>OpenPlugin</dfn>,
то он (плагин) болтаться будет в менюшках без надобности...</p>

<p class=plain>Маленькое замечание - надо обязательно упомянуть в сообщении
<u>имя</u> плагина и, желательно, путь к нему, а то юзер будет гадать, какой
это там плагин не будет работать ;). Прикольное, кстати, суходоевский чеккер
сообщение выводит - "зарегистрируй плагин, парень", а какой плагин, остается
только гадать...</p>


<div class=articlenotes>
<a href="good_version.html">дополнения от Eugene Yavorsky</a>
</div>


<div align=right><code>
<br>&nbsp;<br>
02.11.2000<br>
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>