<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Как уменьшить размер плагина: Microsoft VC++ 6.0</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<LINK REV=made href="mailto:dosoft@mail.ru">
<META NAME="Author" content="Oleg Danilov aka DO">
<META NAME="description" CONTENT="How to reduce size plugin. On example of compiler Microsoft VC++ 6.0">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</HEAD>

<body>
<a name="top"></a>
<h1>Как уменьшить размер плагина</h1>
<h5>(на примере Microsoft VC++ 6.0)</h5>
<div class=navbar>
<a href="../index.html">главная</a> | <a href="index.html">статьи</a>
</div>

<div align=right>
<code>Олег Данилов aka <b>DO</b> <a href="mailto:Oleg%20Danilov%20<dosoft@mail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[dosoft@mail.ru]" width="16" height="16" align="middle">dosoft@mail.ru</a>
</code></div>
<hr color="#003399">

<div align=right>
<code>
&laquo;Mala herba cito crestis&raquo;<br>
(Сорная трава быстро растет - лат.)
</code></div>
<h2>Введение.</h2>
<p class=plain>Прошло уже несколько лет с тех пор, когда красивой программой считалась
  программа маленькая. Канули в лету XT, 286 и 386, процессор 486 можно найти
  лишь дома у любителей старины, а одних только Pentium'ов сменилось несколько
  штук. Не модно стало писать маленький код, напротив, чем больше компакт-дисков
  занимает ваше творение, тем лучше. Тем не менее, в этой статье я хотел бы слегка
  уделить внимание такой теме, как оптимизация. Очевидно, что оптимизировать мы
  будем плагин для Far'а. Менее очевидно, но все же это факт &#151; для компиляции
  будет использоваться Microsoft Visual C++ 6.0. Выбор сделан был не случайно,
  у данного компилятора есть одно, неоспоримое достоинство &#151; он установлен
  как на моем домашнем компьютере, так и на рабочем. К тому же VC достаточно подробно
  описан в MSDN, а я без этой библиотеки и шагу ступить не могу, поскольку ни
  языка C++ ни Win API абсолютно не знаю ;) Кстати, в связи с последним, сразу
  уточнение &#151; изложенный ниже материал не претендует на полноту. И даже в
  некотором роде не претендует на правильность. Сформулируем так &#151; у меня
  это заработало и позволило уменьшить размер получившегося плагина в несколько
  раз.</p>
<h2>Этапы большого пути.</h2>
<p class=plain><b>Шаг&nbsp;0.</b>&nbsp;Все функции, используемые, в плагине были заменены
  на аналогичные из Win API: strcpy на lstrcpy и т.д. К сожалению, история не
  сохранила исходный размер плагина, поэтому оценить экономию на этом шаге затруднительно.</p>
<p class=plain>&nbsp;</p>
<p class=plain><b>Шаг&nbsp;1.</b>&nbsp;Документ <b>VCReadme.txt</b> из архива <b>PlugDoc.rar</b>,
  входящего в поставку Far'а (<em>ред: начиная с FAR 1.70 beta 5 примеры
устанавливаются в отдельный каталог PlugDoc</em>), содержал первоначальную информацию, которая помогла
  мне успешно скомпилировать свой плагин &laquo;<a target="_blank" href="http://plugring.farmanager.com/cgi-bin/downld.cgi?Draw=List&Sort=Date&SelectCateg=Addons&Select=Search&SearchText=ScanDir">ScanDir</a>&raquo;.
  Оттуда я вынес следующее:</p>
<p class=plain>&nbsp;</p>
<pre class=code>cl /Zp2&nbsp;/LD ScanDir.cpp /link /def: ScanDir.def kernel32.lib advapi32.lib</pre>
<p class=plain>&nbsp;</p>
<p class=plain>Что получилось в результате &#151; dll размером 30 килобайт. По
  нынешним меркам &#151; не размер для программы, но&#133;</p>
<p class=plain>&nbsp;</p>
<p class=plain><b>Шаг&nbsp;2.</b>&nbsp;Включаем оптимизацию по размеру:</p>
<p class=plain>&nbsp;</p>
<pre class=code>cl /O1 /Zp2&nbsp;/LD ScanDir.cpp /link /def: ScanDir.def kernel32.lib advapi32.lib</pre>
<p class=plain>&nbsp;</p>
<p class=plain>Сути дела это не изменило. Будем считать ключ /O1 ритуальным обрядом,
  вызывающим бога оптимизации. Безуспешно&#133;</p>
<p class=plain>&nbsp;</p>
<p class=plain><b>Шаг&nbsp;3.</b>&nbsp;Пришлось взять в руки скальпель, коим выступила программа
  <b>DUMPBIN</b> и препарировать полученный файл <b>ScanDir.dll</b>. Вот, что
  меня там заинтересовало:</p>
<p class=plain>&nbsp;</p>
<pre class=code>OPTIONAL HEADER VALUES
&#133;
1000 section alignment
1000 file alignment
&#133;

Summary

1000 .data
1000 .rdata
1000 .reloc
4000 .text</pre>
<p class=plain>&nbsp;</p>
<p class=plain>О чем это говорит? Только о том, что в данной программе есть четыре
  секции (section), каждая из которых выровнена на границу 0x1000. То есть, теряем
  мы тут в среднем 4*0x800 = 8Кб. Реально же после компиляции</p>
<p class=plain>&nbsp;</p>
<pre class=code>cl /O1 /Zp2&nbsp;/LD ScanDir.cpp /link /opt:nowin98 /def: ScanDir.def kernel32.lib advapi32.lib</pre>
<p class=plain>&nbsp;</p>
<p class=plain>размер <b>ScanDir.dll</b> уменьшился до 19Кбайт. Параметр /opt:nowin98
  привел к тому, что выравнивание стало равно 0x200, а плагин существенно &laquo;похудел&raquo;</p>
<p class=plain>&nbsp;</p>
<p class=plain><b>Шаг&nbsp;4.</b>&nbsp;Теперь настала очередь MAP-файла. Из него можно извлечь
  некоторую полезную информацию:</p>
<p class=plain>&nbsp;</p>
<pre class=code>&#133;
0001:00000a1f __CRT_INIT@12 10001a1f f LIBCMT:dllcrt0.obj
0001:00000af8 __DllMainCRTStartup@12 10001af8 f LIBCMT:dllcrt0.obj
0001:00000b95 __amsg_exit 10001b95 f LIBCMT:dllcrt0.obj
0001:00000bc8 __cinit 10001bc8 f LIBCMT:crt0dat.obj
0001:00000bf5 __exit 10001bf5 f LIBCMT:crt0dat.obj
&#133;
0001:0000342d __seh_longjmp_unwind@4 1000442d f LIBCMT:exsup3.obj
&#133;</pre>
<p>&nbsp;</p>
<p>Это не что иное, как startup code &#151; код, проводящий инициализацию, необходимую
  при использовании функций из стандартных библиотек. Но я к этому моменту эти
  функции не использовал (см. <b>Шаг&nbsp;0</b>). Потому вполне логичным было следующее:</p>
<p class=plain>&nbsp;</p>
<pre class=code>cl /O1 /Zp2&nbsp;/LD ScanDir.cpp /link /opt:nowin98 /noentry /def: ScanDir.def kernel32.lib advapi32.lib</pre>
<p class=plain>&nbsp;</p>
<p class=plain>Что я получил? <b>ScanDir.dll</b> размером 5120 байт!</p>
<p class=plain>&nbsp;</p>
<p class=plain><b>Шаг&nbsp;5.</b>&nbsp;Все вышеперечисленное достаточно универсально и подойдет
  для любых плагинов. Теперь же начинаем экономить на мелочах, с учетом особенностей
  конкретной программы. Смотрим в MAP-файле, что из стандартных функций до сих
  пор используется:</p>
<p class=plain>&nbsp;</p>
<pre class=code>&#133;
0001:00000990 _memset 10001990 f LIBCMT:memset.obj
0001:000009f0 __chkstk 100019f0 f LIBCMT:chkstk.obj
0001:000009f0 __alloca_probe 100019f0 f LIBCMT:chkstk.obj
&#133;</pre>
<p class=plain>&nbsp;</p>
<p class=plain>memset на самом деле вызывается всего пару раз, при этом накладные
  расходы по вызову функции достаточно велики по отношении к ее размеру. Логично
  было бы воспользоваться ключиком /Oi, который указывает, что вызовы ряда функций
  (memset, strcpy, abs и др.) надо заменять на ассемблерный код, который очень
  и очень лаконичен для функций такого рода.</p>
<p class=plain>&nbsp;</p>
<pre class=code>cl /O1 /Zp2 /LD /Oi ScanDir.cpp /link /opt:nowin98 /noentry /def: ScanDir.def kernel32.lib advapi32.lib</pre>
<p class=plain>&nbsp;</p>
<p class=plain>Что такое chkstk? Как следует из названия &#151; это проверка стека.
  Локальные переменные, как известно размещаются на стеке и если в одной из функций,
  общий размер переменных превышает 4K, то компилятор генерирует вызов chkstk,
  для того, чтобы гарантировать, что размер стека достаточен для них. Разумеется,
  это правильно и повышает надежность работы программы. Но моя статья рассказывает
  об оптимизации, поэтому chkstk &#151; долой! Для этого укажем, чтобы вызов chkstk
  производился только при достижении 10K, чего заведомо в моей программе случиться
  не должно.</p>
<p class=plain>&nbsp;</p>
<p class=plain>Ну а чтобы быть уверенным, что при сборке не используются никакие
библиотеки, кроме указанных явно, зададим ключ /NODEFAULTLIB:
<p class=plain>&nbsp;</p>
<pre class=code>cl /O1 /Zp2 /LD /Oi /Gs10000 ScanDir.cpp /link /opt:nowin98 /noentry
   /nodefaultlib /def: ScanDir.def kernel32.lib advapi32.lib</pre>
<p class=plain>&nbsp;</p>
<p class=plain>Общая экономия на этом шаге &#151; 512 байт.</p>
<p class=plain>&nbsp;</p>
<p class=plain><b>Шаг&nbsp;6.</b>&nbsp;(Не надоело? Терпите, осталось чуть-чуть). Разумеется,
  memset и chkstk не занимали все 512 байт, это &#151; результат выравнивания секций,
  о котором говорилось выше. А таких секций целых четыре. Попробуем уменьшить
  их число, ведь чем меньше секций, тем меньше выравниваний и тем меньше будут
  потери. Ясно, что .reloc лучше не трогать, она используется Windows в своих
  целях, а остальные можно попытаться объединить в одну:</p>
<p class=plain>&nbsp;</p>
<pre class=code>cl /O1 /Zp2 /LD /Oi /Gs10000 ScanDir.cpp /link /opt:nowin98 /noentry
   /merge:.rdata=.text /merge:.data=.text
   /nodefaultlib /def:ScanDir.def kernel32.lib advapi32.lib</pre>
<h2>Заключение.</h2>
<p class=plain>Тут, пожалуй, пока и остановимся. Итоговый размер плагина &#151;
  4K. Это не так уж много для программы, которая в процессе работы создает на
  экране диалог, вызывает внешние программы, работает с реестром, обменивается
  информацией с Far'ом. Можно ли еще на чем-нибудь сэкономить, и где предел? Попробуем
  посчитать: 1K ушел на заголовок dll, с ним сделать уже ничего нельзя, 0.5K &#151;
  на секцию .reloc, и что с ней делать &#151; не очень ясно. Итого остается для
  дальнейшей оптимизации 2.5 килобайта. А это не так уж мало &#151; целых 2560
  байт&#133; Быть может, когда-нибудь&#133;</p>
<p class=plain>&nbsp;</p>

<div class=articlenotes>
<a href="rsp_microsoftvc42.html">дополнения от Eugene Yavorsky</a>
</div>

<div align=right><code>
<br>&nbsp;<br>
29.01.2001
</code></div>
<div class=seecont><a href="#top">наверх</a></div>


</body>
</html>