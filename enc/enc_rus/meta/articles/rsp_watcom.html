<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Как уменьшить размер плагина: Watcom v11</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:Edward.Sultanov@alcatel.ru">
<meta NAME="Author" content="Edward Sultanov">
<meta NAME="description" CONTENT="How to reduce size plugin. On example of compiler Watcom C v11">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<!-- History of modification:
 Date: Nov 10 1999
   Author: Valentin Skirdin
   E-mail: vskirdin@mail.ru
-->
<body>

<a name="top"></a>
<h1>Как уменьшить размер плагина</h1>
<h5>(на примере Watcom v11)</h5>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right>
<code>Эдуард Султанов <a href="mailto:Edward%20Sultanov%20<ed@it.nsc.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[ed@it.nsc.ru]" width="16" height="16" align="middle">ed@it.nsc.ru</a>
</code></div>
<hr color="#003399">


<p class=plain>
Ровно такие же проблемы были и у
меня. Результат похож, но другой компилятор -
другие заморочки. Если у Вас Watcom и Вам
неинтересны причины, то найдете в конце примеры
makefile и plugin.lnk. Если у Вас другой компилятор -
посмотрите все вплоть до конкретной реализации,
может Вам это поможет.</p>

<p class=plain>Конкретнее:</p>

<h3>I. Немного теории.</h3>

<p class=plain>
Залог успешного похудения вашего
плагина состоит в контроле того что используете
вы сами, а что ваш компилятор:</p>

<h4>1. Используемые функции.</h4>

<div class=descr>
  <p>Желательно использовать Win API и не
  пользовать без разбора библиотечные функции
  типа <code>printf</code> и <code>a2i</code>. Как правило все
  функции семейства используют одну виртуальную и
  соответственно донельзя универсальную. Можно
  привести много причин вредности использовании,
  но нас интересует одна: размер. Можете мне не
  верить и попробовать заменить ваш <code>printf</code> на
  несколько <code>strcat</code> или еще лучше (но не на
  много) вручную сбить строку. Хитростей тут нет.
  Это не зависит от компилятора. Просто надо
  немного думать <code>:-)</code> В конце концов пару
  простеньких функций сделать несложно.</p>
</div>

<h4>2. Скрытые функции.</h4>

<div class=descr>
  <p>Да, любой современный компилятор в
  обьектнике выдает больше чем вы написали в
  исходнике. Во-первых <b>startup</b> - инициализация
  переменных, используемых библиотеками,
  инициализация памяти и еще много чего. Как
  правило ненужного. Во-вторых проверка стека. Все
  они будут видны если вы дизассемблируете
  обьектный файл. И вообще иногда бывает интересно
  посмотреть на результат работы компилятора. </p>
</div>

<h4>3. Подключаемые библиотеки</h4>

<div class=descr>
  <p>Я вообще-то приверженец
  радикального подхода: никаких библиотек. Но это
  совсем необязательно. Если включить у линкера
  оптимизацию, то пользовать библиотеки вполне
  возможно. Но надо помнить главное: используя одну
  библиотечную функцию вы можете подлинковать
  половину библиотеки, только потому что
  используемая функция их все пользует.
  Естественно это не касается стандартных
  динамических библиотек.</p>
</div>

<h3>II. Немного работы ручками.</h3>

<p class=plain>Если скомпилировать плагин,
например так: &quot;<code>wpp386 -bd -d0 -mf Blocks.cpp</code>&quot;.
Потом получившийся файл отдать на растерзание
дизассемблеру: &quot;<code>wdis -a Blocks.obj &gt; Blocks.asm</code>&quot;,
получиться примерно следующее:</p>

<pre class=code>---------------- 'Block.asm' ------------------
.387
.386p
.model flat
                PUBLIC  `_SetStartupInfo@4`
                PUBLIC  `_OpenPlugin@8`
                PUBLIC  `_GetPluginInfo@4`
; Это,понятно, то что мы экспортируем в Far.
; К стати, полезно видеть как это выглядит. Об этом чуть ниже.

                PUBLIC  `W?GetMsg$n(i)pna`
; &quot;Наша&quot; собственная функция. Позаимствовал у ER :-)

                EXTRN   __CHK:BYTE
; Вот !!! Проверка стека вначале функции.

                EXTRN   memset_:BYTE
; Библиотечная функция

                EXTRN   `__imp__RegisterClipboardFormatA@4`:BYTE
; Импорт. Из DLL-ки. Об этом чуть ниже

                EXTRN   __DLLstart_:BYTE
; Вот !!! Так называемый startup.
---------------- !'Block.asm' ------------------</pre>

<p class=plain>
Чтобы не смотреть беспомощно на то
что вытворяет линкер с вашим обьектником, к стати
обычно не большим, нужно взять все под контроль.
Лично я не стал цацкатся и оглядываться на
копирайты и просто взял рекомендуемую для Win32 DLL
библиотеку <code>CLIB3R.lib</code> и распотрошил. Достал
оттуда <code>DLLStart</code> и функции <code>mem*</code> и <code>str*</code>.
Оставил от всего <code>DLLStart</code> только </p>

<pre class=code>       mov       eax,00000001H
       ret       0000000cH
</pre>

<p class=plain>
ну и естественно немного
подправленный копирайт <code>:-)</code> Слинковал я все
это в библиотеку <code>mindll.lib</code> <strong>(входит в поставку энциклопедии)</strong>.
Получилось 5.6K. Я ничего не сказал про <code>__CHK</code>,
потому что отключил проверку стека. Но, если Вам
это не по душе, можете включить в библиотеку и ее.
Только лучше,сначала, маленько прохудить. Лично я
не нашел в ней ничего полезного. </p>

<p class=plain>Теперь о подключаемых DLL. Каждый
компилятор имеет вариант своей статической
библиотеки в виде DLL. Для такой динамической
линковки есть свой lib-файл. Так что если вы
экспериментируете с библиотеками и Вам удалось
наконец найти библиотеку с которой dll-ка плагина
не ужасающе громадна - посмотрите на вашу dll-ку
QuickViewer'ом - что ему надо для работы. Если это что-то
помимо <code>user32.dll</code>, <code>kernel32.dll</code>, <code>advapi32.dll</code>
то ваш плагин, скорее всего, будет работать
только у пользователей такого же компилятора.
Так что лучше обрубить линкеру крылья и все
библиотеки прописывать самому. Так вернее.</p>

<h3>III. Собственно это все. Теперь примеры:</h3>

<pre class=code>;---------------- 'makefile' ------------------
# Это собственно рабочий кусок.
#Я привык их делать сам, а не из IDE - так понятнее.

Blocks.dll : Blocks.obj
         wlink file Blocks.obj @plugin &gt;err.log

# ну тут наверно все понятно файл plugin.lnk будет чуть позже.

Blocks.obj : Blocks.cpp Blocks.hpp
         wpp386 -3r -bd -d0 -mf -s Blocks.cpp

# ключи:
# -3r оптимизация под 386 и передача параметров через регистр.
# -bd - для DLL.
# -d0 - без информации для дебагера.
# -mf - Модель памяти flat.
# -s - отключить проверку стека.
---------------- !'makefile' ------------------</pre>


<pre class=code>;---------------- 'plugin.lnk' ------------------
FORMAT
    WINDOWS NT DLL
# Это формат выходного файла

OPTION
    NODEFAULTLIB,
    NOSTDCALL
# Первое - чтобы линкер не подключил что не надо
# Второе - чтобы экспортные функции экспортировались &quot;как есть&quot;
# к стати вот как они декларируются:
# extern &quot;C&quot;
# {
# void WINAPI _export SetStartupInfo(struct PluginStartupInfo *Info);
# HANDLE WINAPI _export OpenPlugin(int OpenFrom,int Item);
# void WINAPI _export GetPluginInfo(struct PluginInfo *Info);
# };
# обратите внимание на ключевое слово &quot;_export&quot;

LIBRARY
     mindll.lib,
     USER32.LIB,
     KERNEL32.LIB,
     ADVAPI32.LIB

# Здесь перечисленные сами библиотеки.
# Первое описано выше
# Со второй по четвертую - соответствуют стандартным DLL-кам.

RUNTIME CONSOLE
# Особо ни на что не влияет.
---------------- !'plugin.lnk' ------------------</pre>

<p class=plain>
Вот с этим всем из 4K С++ файла
получаем 4K dll. Это конечно не показатель, но все же <code>:-)</code></p>


<br>&nbsp;<br>
<div align=right><code>
<br>&nbsp;<br>
18.10.1999
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>