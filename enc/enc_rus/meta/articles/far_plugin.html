<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Как самому сделать plug-in к FAR на Visual C++</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:phoenixbird@hotmail.ru">
<meta name="Author" content="2000 (C) Phoenix aka Руслан Ильгасов">
<meta name="description" content="Как самому сделать plug-in к FAR на Visual C++ - шаг за шагом">
<script type="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<body>

<a name="top"></a>
<h1>Как самому сделать plug-in к FAR на Visual C++<BR><em>шаг за шагом</em></h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
Phoenix aka Руслан Ильгасов <a href="mailto:Руслан%20Ильгасов%20<phoenixbird@hotmail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[phoenixbird@hotmail.ru]" width="16" height="16" align="middle">phoenixbird@hotmail.ru
</a><br>
</code></div>
<hr color="#003399">

<p class=plain>
Трудно найти человека, которые не знает или не использует Far - IMHO
лучший клон NC для Windows. Кроме того, что это просто очень хороший файл
менеджер, к нему есть огромное количество plug-in модулей. Plug-in модуль
это DLL-файл, который вместо стандартных Windows функций по работе с
монитором, клавиатурой и т.д. обращается к функциям Far-а. Far
поддерживает весь набор функций для работы в текстовом режиме. Установка
plug-in модуля происходит предельно просто - DLL файл и файлы данных
копируются в каталог в каталоге Far\Plugins и Far перезапускается.</P>

<p class=plain>
FAR распространяется с полным набором файлов для написания самим
plug-in на любом С компиляторе для Windows. Темой этой статьи является
написание этих модулей самим на Visual C++ (я использовал Visual C++ 5.0).
При установке в каталог Far копируется PlugDoc.rar, в нем есть примеры
plug-in-ов и header файл (<em>ред: начиная с FAR 1.70 beta 5 примеры
устанавливаются в отдельный каталог PlugDoc</em>). Все примеры используются
Еще там есть <code>VCReadme.txt</code>, в котором описываются тонкости работы с
Visual C++. Потом поразбираетесь с примерами.</P>

<p class=plain>
Мы с вами напишем plug-in, который получает список открытых окон
Windows, он может пригодиться как заготовка для своих. И вообще - стоит
начать - все это не так сложно, как можно подумать. Вот, а теперь -
поехали:</P>

<ol>
<li>Запускает VC, делаем новый проект типа "Win32 Dynamic-Link Library"
по имени SimpleFP. Создает файл simplefp.cpp - здесь, собственно, мы и
будем писать. В каталог SimpleFP копируем header файл plugin.hpp из архива
PlugDoc.rar (<em>ред: начиная с FAR 1.70 beta 5 примеры
устанавливаются в отдельный каталог PlugDoc</em>).</li>
<li>Теперь нам надо сделать .def файл - это файл, в котором описываются
функции, которые вызываются из внешних модулей. Мы должны описать функции
Far-а, которые мы будем использовать в нашем модуле. Делаем текстовый файл
simplefp.def, в котором пишем:
<pre class=code>LIBRARY
EXPORTS
GetPluginInfo=_GetPluginInfo@4
OpenPlugin=_OpenPlugin@8
SetStartupInfo=_SetStartupInfo@4</pre>

Здесь мы описываем 3 функции, которые нам пригодятся. А теперь добавим
simpledef.def к файлам проекта (Project - Add to project -
Files - simplefp.def).</li>

<li>Теперь пишем сам plug-in - работаем с файлом simplefp.cpp. Я решил
дать текст самой программы с комментариями - можно скопировать в С++ и
начать с ним возиться. Но сначала о основах.</li>
</ol>

<p class=plain>
Far работает по тем же принципам, что и Windows - вы ссылаетесь в
программе на те функции, уже имеющиеся в системе, которые хотите
использовать. Far предоставляет функции для работы с экранными формами в
режиме console application. При запуске plug-in-а Far запускает функцию
OpenPlugin, мы будем ее рассматривать как аналог main() или WinMain(). Но
кроме этого надо еще сообщить Far-у данные о нашем plug-in-е. Это делает
функция GetPluginInfo.</p>

<pre class=code>/*
* SimpleFP - простой plug-in к Far-у. (С) 2000 Phoenix, Moscow
*/

#include &lt;stdio.h&gt;    // для вызова sprintf
#include &lt;windows.h&gt;  // для функций Windows
#include "plugin.hpp" // для функций Far

#define PLUGIN_NAME "Open windows"      // Название plug-in-а
#define WINDOW_HEAD "Open windows list" // Заголовок меню, которое мы сделаем

//
// Описываем функции Far, которые с которыми мы работаем.
//

extern "C"
{
void WINAPI _export SetStartupInfo(struct PluginStartupInfo *Info);
HANDLE WINAPI _export OpenPlugin(int OpenFrom,int Item);
void WINAPI _export GetPluginInfo(struct PluginInfo *Info);
};

static struct PluginStartupInfo Info; // Информация о нашем plug-in-е

//
// Информация о модуле определена нами в структуре Info
//

void WINAPI _export SetStartupInfo(struct PluginStartupInfo *Info)
{
  ::Info=*Info;
}

// Эта функция вызывается для получения информации о plug-in.
// Мы должны заполнить поля структуры Info.
//

void WINAPI _export GetPluginInfo(struct PluginInfo *Info)
{
  Info-&gt;StructSize=sizeof(*Info); // Размер структуры Info
  Info-&gt;Flags=0; // Это нам не нужно
  Info-&gt;DiskMenuStringsNumber=0; // Это нам тоже не нужно

  // Определяем строку с названием модуля
  static char *PluginMenuStrings[1];
  PluginMenuStrings[0]= PLUGIN_NAME;

  // Определяем название plug-in модуля
  Info-&gt;PluginMenuStrings=PluginMenuStrings;
  Info-&gt;PluginMenuStringsNumber=
    sizeof(PluginMenuStrings)/sizeof(PluginMenuStrings[0]);
  Info-&gt;PluginConfigStringsNumber=0; // Это нам не нужно
}

// Эта функция вызывается при запуске plug-in модуля.
//

HANDLE WINAPI _export OpenPlugin(int OpenFrom,int Item)
{
  HWND hwnd; // Используем для получения handle
  char p[128], o[128]; // Для создания строк меню
  int i=0; // Счетчик

  struct FarMenuItem MenuItems[64]; // Описание меню, которое создаст для нас Far
  memset(MenuItems,0,sizeof(MenuItems)); // Инициализируем наше меню
  MenuItems[0].Selected=TRUE;

  hwnd = GetDesktopWindow(); // Получаем handle для desktop
  hwnd = GetWindow(hwnd, GW_CHILD); // Получаем его handle
  while (hwnd !=0) // Пока оно не последнее
  {
    hwnd = GetWindow(hwnd, GW_HWNDNEXT); // получим handle окна
    GetWindowText(hwnd,p,128); // и его заголовок
    if (strlen(p)&gt;0) // если заголовок есть
    {
      sprintf(o,"%0.8xld %s", hwnd, p); // сделаем строчку
      strcpy(MenuItems[i++].Text, o); // скопируем эту строчку в массив MenuItems
    }
  }

  // вызываем созданное нами меню, получаем номер выбранного пункта - MenuCode
  //
  int MenuCode=Info.Menu(Info.ModuleNumber,
                  -1,-1,0,
                  FMENU_AUTOHIGHLIGHT|FMENU_WRAPMODE,
                  WINDOW_HEAD,
                  NULL,
                  "Menu content",
                  NULL,
                  NULL,
                  MenuItems,
                  i);

  return(INVALID_HANDLE_VALUE);
}</pre>


<p class=plain>
Компилируйте, копируйте в Far\Plugin и перезапускайте Far. В Far-е
нажмите F11 - это список plug-in модулей. Теперь в нем должна появиться
строка Open windows. Посмотрите на результат. Теперь можно развивать,
например - обрабатывая результат MenuCode посылать выбранному окну
сообщение WM_CLOSE, или сделать еще что-нибудь нетривиальное :) Создание
plug-in модулей к Far-у документировано замечательно, разбирайтесь.</p>

<p class=plain>
<em>В поставку Энциклопедии входит архив <code>simplefp.zip</code> - пример
DLL файла (~20Кб)</em></P>


<div align=right><code>
Phoenix aka Руслан Ильгасов, Москва
<BR>E-Mail:<A href="mailto:phoenixbird@hotmail.ru">phoenixbird@hotmail.ru</a>
<BR>FIDO: 2:5020/2637.2
<br>&nbsp;<br>
13.05.2000
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>
