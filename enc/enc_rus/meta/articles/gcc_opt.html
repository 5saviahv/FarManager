<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Оптимизация размера плагина при использовании gcc.</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
</head>

<body>

<a name="top"></a>
<h1>Оптимизация размера плагина при использовании gcc.</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>
<div align=right><code>Вадим Егоров <a href="mailto:zg@matrica.apollo.lv?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[zg@matrica.apollo.lv]" width="16" height="16" align="middle">zg@matrica.apollo.lv</a></code></div>
<hr color="#003399">

<h3>Введение.</h3>
<p class=plain>В данной статье рассматривается вопрос об уменьшении размера плагинов, скомпилированных gcc.<br>
Условия, при которых возможен существенный выигрыш в размере:<br>
1. Вы явно или неявно используете в своем плагине оператор new.<br>
2. Вы не используете обработку исключений и механизм rtti.<br></p>
<p class=plain>Для компиляции использовались gcc 2.95.3-4 и ld 2.11.90 (20010704).</p>
<h3>Тестовый плагин.</h3>
<p class=plain><b>test.cpp:</b></p>
<pre class=code>
#include "plugin.hpp"

void WINAPI _export SetStartupInfo(const struct PluginStartupInfo *Info)
{
  int *a;
  a=<b>new</b> int;
  <b>delete</b> a;
}
</pre>
<p class=plain><b>test.def:</b></p>
<pre class=code>
EXPORTS
SetStartupInfo=SetStartupInfo@4
</pre>
<p class=plain><b>makefile:</b></p>
<pre class=code>
CFLAGS=-c -mcpu=pentiumpro -O3 -Wall
LFLAGS=-s -mdll

RM=rm
CC=gcc
DLLTOOL=dlltool

DEF=test.def
OBJS=test.o
TARGET=test.dll

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) $(LFLAGS) -o nul -Xlinker --base-file -Xlinker $@.base $^ $(LIBS)
	$(DLLTOOL) --dllname $@ --base-file $@.base --output-exp $@.exp --def $(DEF)
	$(CC) $(LFLAGS) -o $@ $^ $@.exp $(LIBS)
	$(RM) $@.base
	$(RM) $@.exp

test.o: test.cpp
	$(CC) $(CFLAGS) $&lt; -o $@
</pre>
<p class=plain>Примечание: -mcpu=pentiumpro означает всего лишь оптимизацию для P6+ процессоров, без использования команд отсутствующих в i386.</p>
<h3>Оптимизация.</h3>
<p class=plain>Запускаем make. Получаем test.dll размером 23552 байт. Незаслуженно много для такого простого плагина. Начинаем оптимизацию.</p>
<p class=plain><b>Шаг 1.</b> На этом шаге из плагина исключается код для поддержки исключений и rtti. Добавляем в makefile:</p>
<pre class=code>
CFLAGS=-c -mcpu=pentiumpro -O3 -Wall -fno-rtti -fno-exceptions
</pre>
<p class=plain>Но этого недостаточно. Дело в том, что в реализации глобальных операторов new и delete используются и исключения и rtti. Поэтому добавим в плагин свои версии этих операторов:</p>
<pre class=code>
void * operator new(size_t size)
{
  return HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,size);
}

void operator delete(void *block)
{
  if(block) HeapFree(GetProcessHeap(),0,block);
}
</pre>
<p class=plain>Запускаем make. Получаем test.dll размером 3584 байт.<br>Если вы используете операторы new[] и delete[], то их тоже надо переписать:</p>
<pre class=code>
void * operator new[](size_t size)
{
  return HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,size);
}

void operator delete[](void *block)
{
  if(block) HeapFree(GetProcessHeap(),0,block);
}
</pre>
<p class=plain><b>Шаг 2.</b> Исключение startup code. Его размер в версии gcc, указанной выше, составляет 268 байт. Не так уж много, но все же. Добавляем в makefile:</p>
<pre class=code>
LFLAGS=-s -mdll -nostartfiles
</pre>
<p class=plain>...и в test.cpp:</p>
<pre class=code>
#ifdef __cplusplus
extern "C"{
#endif
  BOOL WINAPI DllMainCRTStartup(HANDLE hDll,DWORD dwReason,LPVOID lpReserved);
#ifdef __cplusplus
};
#endif

BOOL WINAPI DllMainCRTStartup(HANDLE hDll,DWORD dwReason,LPVOID lpReserved)
{
  return TRUE;
}
</pre>
<p class=plain>Запускаем make. Получаем test.dll размером 3072 байт.<br>Для этого плагина на этом можно и остановится. Но для реальных плагинов можно еще сэкономить килобайт, другой.</p>
<p class=plain><b>Шаг 3.</b> Дополнительные флаги оптимизации.<br>Далее идет описание флагов, влияющих на оптимизацию, но не включенных в -O3. Ими надо пользоваться с осторожностью. Иногда может быть получен неожидаемый результат.</p>
<p class=plain><b>-fomit-frame-pointer</b> - без этого флага для каждой функции генерируется пролог и эпилог примерно следующего вида:</p>
<pre class=code>
push ebp
mov ebp,esp
...
mov esp,ebp
pop ebp
</pre>
<p class=plain>Использование данного флага позволяет исключить генерацию пролога и эпилога без необходимости. Что при большом числе функций в проекте, позволяет получить видимый выигрыш в размере.</p>
<p class=plain><b>-fstrict-aliasing</b> - включает оптимизацию, основываясь на типе выражения. Считается что указатели разных типов указываю на разные участки памяти. Исключение составляют поля в объединениях.</p>
<p class=plain><b>-funroll-loops</b> - оптимизация по раскрытию циклов с заранее известным количеством итераций. Может приводить к увеличению размера кода.</p>
<p class=plain><b>-funroll-all-loops</b> - оптимизация по раскрытию всех циклов. Может приводить к увеличению размера и увеличению времени выполнения кода.</p>
<p class=plain><b>-fno-builtin</b> - для таких функций, как <span class=code>abort</span>, <span class=code>abs</span>, <span class=code>alloca</span>, <span class=code>cos</span>, <span class=code>exit</span>, <span class=code>fabs</span>, <span class=code>ffs</span>, <span class=code>labs</span>, <span class=code>memcmp</span>, <span class=code>memcpy</span>, <span class=code>sin</span>, <span class=code>sqrt</span>, <span class=code>strcmp</span>, <span class=code>strcpy</span> и <span class=code>strlen</span> gcc по умолчанию вместо вызова библиотечных функций генерирует inline код. Данный флаг предотвращает это, уменьшая размер кода, но при этом увеличивая время выполнения.


<div align=right><code>
<br>&nbsp;<br>
16.07.2001
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>