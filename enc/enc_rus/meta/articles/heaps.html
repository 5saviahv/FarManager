<html>
<head>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<title>Распределение памяти. Скромная попытка расставить все по своим местам в этом вопросе.</title>
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:spinoza@mail.ru">
<meta name="Author" content="Ivan Sintyurin">
<meta name="description" content="Распределение памяти. Скромная попытка расставить все по своим местам в этом вопросе.">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<body>

<a name="top"></a>
<h1>Распределение памяти. Скромная попытка расставить все по своим местам в этом вопросе.</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
Иван Синтюрин <a href="mailto:Ivan%20Sintyurin%20<spinoza@mail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[spinoza@mail.ru]" width="16" height="16" align="middle">spinoza@mail.ru</a>
</code></div>
<hr color="#003399">

<p class=plain>В очередной раз подняли вопрос о распределении памяти под win32...
У меня по этому поводу кое-что накипело, это можно выразить следующей фразой:
<dfn>"С операционной системой следует говорить на ее родном языке!"</dfn>.
Конечно, не надо возводить это правило в абсолют, но на самом деле в
некоторых случаях лучше не пользоваться языковыми средствами
распределения памяти (new, delete, malloc, free, GetMem, FreeMem
и т.д.), т.к. их эффективность зависит от конкретного компилятора
и может быть неудовлетворительной, а использовать функции из
win32 api, тогда глюков будет меньше (если не считать ваши
собственные ;), а скорость работы увеличится. Кроме этого вы
можете не просто задействовать сервис из win32 api, но и написать
свой собственный менеджер памяти, который в вашем конкретном
случае будет обеспечивать максимальную эффективность (последнее
не описывается в данной статье, читайте книжки ;-).

</p>

<p class=plain>В win32 используется три механизма управления памятью:
<UL>
<LI>виртуальная память - наиболее подходящая для операций с большими
массивами объектов или структур;
<LI>проецируемые в память файлы - наиболее подходящие для операций с
интенсивными потоками данных (обычно из файлов) и для совместного
использования данных несколькими процессами;
<LI>кучи или динамически распределяемы области памяти - для удобны при
создании множества небольших блоков данных.
</UL>
Вот о кучах мы немного и поговорим.</p>

<p  class=plain>Если вы программировали для 16-разрядной
Windows, Вам знакомы два типа куч: локальные и глобальные. У каждого процесса и
DLL-модуля в ней собственная локальная куча,  а единственная глобальная -
доступна всем процессам. В win32 есть принципиальные отличия в схеме управления
динамически распределяемой памятью:
<ul>
<li>существует только один тип кучи;
<li>кучи всегда являются локальными для процесса;
<li>к содержимому кучи не может обратиться поток из другого процесса;
<li>процессу разрешается создавать несколько куч,  являющихся частью его
адресного пространства;
<li>DLL-модулю собственная куча не выделяется, он использует кучи являющиеся
частью адресного пространства процесса, но DLL может создать в нем кучу и
использовать ее для себя.
</ul>
</p>

<p class=plain>Куча (анлг. heap) - регион
зарегистрированного адресного пространства. Первоначально большей его части
физическая память не передается. По мере того, как программа занимает эту
область под данные,  специальный диспетчер,  управляющий кучами (<dfn>heap
manager</dfn>), передает ей физическую память постранично. А при освобождении страниц в куче
диспетчер возвращает физическую память системе.</p>

<p class=plain>Кучи бывают двух видов:

<ul>
<li>Стандартная куча процесса - ее
создает система при инициализации win32-процесса. Ее размер по умолчанию - 1
Mb (не забудьте, что DLL-модулям куча по умолчанию не предоставляется). Эта
куча используется многими win32-функциями, доступ к куче разрешается только по
очереди. Описатель этой кучи возвращает функция <dfn><a href="win32/getprocessheap.html">GetProcessHeap</a></dfn>.
<li>Дополнительные кучи. Для чего они нужны:
защита компонентов, более эффективное управление памятью, локальный доступ
(кому не понял, про что я говорю, - пишите, я поясню). Эти кучи создаются
функцией <dfn><a href="win32/heapcreate.html">HeapCreate</a></dfn>.
</ul>
Для выделения блока памяти из кучи используют функцию <dfn><a href="win32/heapalloc.html">HeapAlloc</a></dfn>,
для изменения размера блока памяти - <dfn><a href="win32/heaprealloc.html">HeapReAlloc</a></dfn>. Если вы хотите
узнать истинный размер выделенного блока памяти, то используйте
<dfn><a href="win32/heapsize.html">HeapSize</a></dfn>. Не забывайте ;-) освобождать блоки, для этого есть
<dfn><a href="win32/heapfree.html">HeapFree</a></dfn>. Функция <dfn><a href="win32/heapdestroy.html">HeapDestroy</a></dfn> используется для
уничтожения кучи (созданной <dfn><a href="win32/heapcreate.html">HeapCreate</a></dfn>, стандартную кучу уничтожает
операционная система при завершении процесса) - обращение к этой функции
приводит к освобождению всех блоков памяти внутри кучи и возврату системе
физической памяти и региона адресного пространства, занятого кучей.
</p>
<p class=plain>Для удобства при написании программ (или при написании
портируемых программ) можно переопределить стандартные операторы в C/C++
(btw, размер плагинов также уменьшается, это очевидно...). Например, можно
использовать следующее:<br>

<pre class=code>typedef unsigned size_t;

HANDLE heapNew_SR; /*эту кучу я создаю в самом начале работы программы*/

void *malloc(size_t size)
{
  return HeapAlloc(heapNew_SR,HEAP_ZERO_MEMORY,size);
}

void *realloc(void *block, size_t size)
{
  void *p=NULL;
  if(heapNew_SR!=NULL)
  {
   if(!size) HeapFree(heapNew_SR,0,block);
   else
   {
    if(block==NULL) p=HeapAlloc(heapNew_SR,HEAP_ZERO_MEMORY,size);
    else p=HeapReAlloc(heapNew_SR,HEAP_ZERO_MEMORY,block,size);
   }
  }
  return p;
}

void free(void *block)
{
  if(block!=NULL &amp;&amp; heapNew_SR) HeapFree(heapNew_SR,0,block);
}

void *operator new(size_t size)
{
  size=size?size:1;
  return malloc(size);
}

void *operator new[](size_t size) {return ::operator new(size);}
void *operator new(size_t size, void *p) {return p;}
void operator delete(void *p)
{
 free(p);
}
void operator delete[](void *ptr) {::operator delete(ptr);}

</pre>
</p>
<p class=plain>Многие скажут, а как же <dfn><a href="win32/globalalloc.html">GlobalAlloc</a></dfn>,
<dfn><a href="win32/globalfree.html">GlobalFree</a></dfn>,
<dfn><a href="win32/globallock.html">GlobalLock</a></dfn> и прочие?
Ответ прост - <dfn>это старье</dfn> и его лучше не использовать в своих
программах (можно, если вы пишете под 16-разрядные винды)! Windows
поддерживает эти функции только для совместимости со старыми программами.
<dfn>Они работают хуже и медленнее win32-функций, управляющих кучами, и
требуют для своей работы дополнительной памяти.</dfn></p>

<p class=plain>Приведу пример для тех, кому не достаточно просто утверждения. Для
поддержки 16-разрядных функций, управляющих глобальными и локальными кучами,
каждому процессу при инициализации предоставляется своя таблица описателей и
своя стандартная куча, в которой выделяются участки для глобальной и локальной
памяти. Эта таблица описателей нужна win32 для управления выделением
глобальной и локальной памяти, она является массивом структур, каждый элемент
массива указывает на блок памяти, выделенной из стандартной кучи процесса. При
вызове <a href="win32/globalalloc.html">GlobalAlloc</a> система выделяет блок из этой кучи и отыскивает свободный
элемент в таблице описателей, принадлежащей процессу. Затем сохраняет адрес
выделенного блока в таблице описателей и возвращает адрес элемента этой
таблицы. Последнее значение, по сути, описатель блока памяти. И когда вы
вызовете <a href="win32/globallock.html">GlobalLock</a>, система просмотрит таблицу описателей и просто вернет
адрес блока памяти, выделенного в стандартной куче процесса. Первоначально
win32 отводит небольшой объем памяти, достаточный для хранения буквально
нескольких элементов таблицы описателей. По мере необходимости в нее
добавляются новые элементы; при этом win32 может <dfn>увеличивать объем памяти,
занимаемый таблицей описателей</dfn>. Только из-за одних дополнительных операций с
таблицей описателей <dfn>старые 16-разрядные функции работают медленнее</dfn>,
чем win32-функции, управляющие кучами...
</p>
<br><br>
<p class=plain>That's all,  folks :-)</p>
<div align=right><code>
<br>&nbsp;<br>
28.05.2000<br>
Rev. 20.12.2001
</code></div>
<p class=plain>
P.S. При написании этой статьи кроме личного опыта использовался
материал книги Джеффри Рихтера "Windows для профессионалов. 3-е
издание." (кстати, по сети гуляет 4-е английское издание этой
замечательной книжки, если вам сложно купить ее в магазине, то
поищите в любимом поисковике файл <b>Richter_book_withoutIE5.zip</b>).
</p>

<div class=seecont><a href="#top">наверх</a></div>
</body>
</html>
