<html>

<head>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<title>Step1: Первое приближение</title>
<link rel="stylesheet" type="text/css" href="../../../styles/styles.css">
</head>

<body>

<div class=navbar>
<a href="../../index.html">главная</a> |
<a href="../index.html">статьи</a>
</div>

<a name="top"></a>
<h1>Шаг1: Первое приближение</h1>
<div class=navbar><a href="panelplugin.html">Введение</a> &#187; Шаг 1 &#187; <a href="panelplugin.2.html">Шаг 2</a> &#187; <a href="panelplugin.3.html">Шаг 3</a></div>
<div align=right>
</div>
<hr color="#003399">

<p>Полная реализация идеи. Информацию о местоположении Доски пользователя берем из реестра -
<nobr><code>HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Desktop</code></nobr>.
<br>Имеется так же возможность задания конкретного каталога для перехода (не только Desktop
текущего пользователя) - достигается путем введения блока конфигурирования плагина.
Этим самым "конкретным каталогом" может быть каталог, в котором лежит куча LNK-файлов
(см. плагин "Shell link creation")...
<br>На данном шаге плагин не создает собственной панели.


<p>Попробуем решить задачу в лоб, как есть, т.е. в меню дисков и меню выбора плагинов должен
появится пункт меню, выбрав который пользователь попадет на свою Доску.

<p>Для создания полноценного плагина на данном этапе нам понадобятся 5 экспортируемых функций:

<table class="cont">
<tr class="cont"><th class="cont" width="20%">Функция</th><th class="cont" width="80%">Назначение</th></tr>
<tr class="cont"><td class="cont" width="20%"><a href="../../exported_functions/setstartupinfo.html">SetStartupInfo</a></td>
<td class="cont" width="80%">получить от FAR начальные значения, необходимые плагину</td></tr>
<tr class="cont"><td class="cont" width="20%"><a href="../../exported_functions/getplugininfo.html">GetPluginInfo</a></td>
<td class="cont" width="80%">передать в FAR информацию о плагине</td></tr>
<tr class="cont"><td class="cont" width="20%"><a href="../../exported_functions/configure.html">Configure</a></td>
<td class="cont" width="80%">настройки плагина: показывать ли плагин в меню выбора дисков и задание каталога по умолчанию.</td></tr>
<tr class="cont"><td class="cont" width="20%"><a href="../../exported_functions/openplugin.html">OpenPlugin</a></td>
<td class="cont" width="80%">пользователь вызвал плагин</td></tr>
<tr class="cont"><td class="cont" width="20%"><a href="../../exported_functions/getfinddata.html">GetFindData</a></td>
<td class="cont" width="80%">передача в FAR нашего каталога для позиционирования на панели</td></tr>
</table>

<p>Функции SetStartupInfo, GetPluginInfo и Configure важны, но рассматривать их мы не будем
дабы не потерять основную мысль. Сосредоточимся на последних двух - OpenPlugin и GetFindData (<em>для реальной
панели вместе с функцией GetFindData должна идти FreeFindData, но т.к. мы панель не создаем, то <a href="../../exported_functions/freefinddata.html">FreeFindData</a>
сейчас использовать не будем</em>).

<p>Вариантов вызова этого плагина два, поэтому по очереди их и рассмотрим. Начнем с простого - вызов
из меню плагинов.</p>

<h3>OPEN_PLUGINSMENU</h3>

<p>Пока мы "не знаем" как создавать свою файловую панель (да она нам сейчас и ни к чему), поэтому
воспользуемся тем фактом, что в функцию <a href="../../service_functions/control.html">Control</a> первым параметром можно
передать значение <dfn>INVALID_HANDLE_VALUE</dfn>:</p>

<blockquote>
  <i>&quot;hPlugin - Текущий описатель плагина. При
  запросе информации относительно активной <br>
  панели установите этот параметр равным
  INVALID_HANDLE_VALUE. Это позволяет <br>
  использовать эту функцию в командах плагина без
  создания&nbsp; новой панели.&quot;</i> </p>
</blockquote>

<p>Далее все просто. В <a href="../../exported_functions/openplugin.html">OpenPlugin</a> для активной панели (INVALID_HANDLE_VALUE)
установить каталог (<a href="../../service_functions/control.html#FCTL_SETPANELDIR">FCTL_SETPANELDIR</a>),
обновить панель (<a href="../../service_functions/control.html#FCTL_REDRAWPANEL">FCTL_REDRAWPANEL</a>) и вернуть в FAR
значение INVALID_HANDLE_VALUE (при этом FAR сразу "закроет" плагин):

<pre class=code>
HANDLE WINAPI OpenPlugin(int OpenFrom,int Item)
{
  if(Opt.DefaultFolder[0])
  {
    if(OpenFrom == OPEN_PLUGINSMENU)
    {
      ::Info.Control(INVALID_HANDLE_VALUE,FCTL_SETPANELDIR,Opt.DefaultFolder);
      ::Info.Control(INVALID_HANDLE_VALUE,FCTL_REDRAWPANEL,NULL);

    }
    ...
  }
  return INVALID_HANDLE_VALUE;
}
</pre>


<h3>OPEN_DISKMENU</h3>

<p>На данном этапе известно, что FAR вызовет функцию плагина <a href="../../exported_functions/openplugin.html">OpenPlugin</a> с параметром <dfn>OPEN_DISKMENU</dfn>.
В этом случае в FAR необходимо вернуть все, что угодно, кроме INVALID_HANDLE_VALUE и 0.
Для простоты вернем адрес переменной <code>Opt</code>.

<pre class=code>
HANDLE WINAPI OpenPlugin(int OpenFrom,int Item)
{
  if(Opt.DefaultFolder[0])
  {
    ...
    else if(OpenFrom == OPEN_DISKMENU)
    {
      return (HANDLE)&amp;Opt; // возвращаем все, что угодно, кроме 0 и INVALID_HANDLE_VALUE
                           // тогда сработает функция GetFindData()
    }
  }
  return INVALID_HANDLE_VALUE;
}
</pre>

Это сделано по следующим причинам:
<ol>
<li>нам нужно как то сказать ФАРу, чтобы он перешел на панели в нужный каталог; это
можно сделать с помощью Control(FCTL_CLOSEPLUGIN,"Каталог")
<li>нам неизвестно для какой панели вызвано меню дисков, поэтому простым вызовом
Control(INVALID_HANDLE_VALUE,FCTL_CLOSEPLUGIN,"Каталог") нам не обойтись (в этом случае
наш каталог всегда будет позиционироваться на активной панели, т.е. действие аналогичное варианту
OPEN_PLUGINSMENU)
<li>ближайшая функция, которая позволит нам позиционировать каталог с помощью
Control(FCTL_CLOSEPLUGIN,"Каталог") - это GetFindData(); функция GetFindData во-первых будет вызвана
тогда, когда FAR будет обновлять панели (т.е. сразу после закрытия меню), во-вторых у нее есть описатель
плагина.
</ol>

<p>Функция GetFindData хочет взглянуть на список наших файлов, но т.к. панели как таковой нет, то с
учетом выше сказанного... просто закроем плагин, с указанием каталога:

<pre class=code>
int WINAPI GetFindData(HANDLE hPlugin,struct PluginPanelItem **pPanelItem,
                      int *pItemsNumber,int OpMode)
{
  ::Info.Control(hPlugin,FCTL_CLOSEPLUGIN,Opt.DefaultFolder);
  return TRUE;
}
</pre>


<p>На этом первый этап заканчиваем. Исходники для этого "урока" можно взять <a href="panelplugin.1/">здесь</a>.

<div align=right><code>
<br>
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>
