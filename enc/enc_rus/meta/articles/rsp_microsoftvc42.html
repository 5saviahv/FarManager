<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Как уменьшить размер плагина: Microsoft VC++ 4.2</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<LINK REV=made href="mailto:eugene_yavorsky@mail.ru">
<META NAME="Author" content="Eugene Yavorsky">
<META NAME="description" CONTENT="How to reduce size plugin. On example of compiler Microsoft VC++ 4.2">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</HEAD>

<body>
<a name="top"></a>
<h1>Как уменьшить размер плагина: Microsoft VC++ 4.2</h1>
<h5>(замечания к статье <a href="rsp_microsoftvc.html">Олега Данилова</a>)</h5>
<div class=navbar>
<a href="../index.html">главная</a> | <a href="index.html">статьи</a>
</div>

<div align=right>
<code>Eugene Yavorsky <a href="mailto:Eugene%20Yavorsky%20<eugene_yavorsky@mail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[eugene_yavorsky@mail.ru]" width="16" height="16" align="middle">eugene_yavorsky@mail.ru</a>
</code></div>
<hr color="#003399">

<p>В статье <a href="rsp_microsoftvc.html">"Как уменьшить размер плагина (на примере Microsoft VC++ 6.0)"</a> Олег Данилов пишет:


<pre class=code><em>Шаг 0. Все функции, используемые, в плагине были заменены на аналогичные
из Win API: strcpy на lstrcpy и т.д. К сожалению, история не сохранила
исходный размер плагина, поэтому оценить экономию на этом шаге затруднительно.
</em></pre>

<p>В дополнение привожу результаты моих "издевательств" над двумя собственными проектиками в VC 4.2.</p>

<p>Первая подопытная программа - Win32 GDI, RTL - single-threaded (ключ компиляции /ML).
До "измывательства" - 26624 байт (исходный код до "обработки" - до 100 строк, после - 101 строка, из
которых 3 - инклуды, 30 - форматирование [пробелы и открывающие/закрывающие скобки], 10 - комментарии, 26 - объявления и
инициализация переменных. Итого 32 "смысловые" строки).


<p>В таблице приведены результаты рекомендованных Олегом Даниловым замен (естественно, где было что заменять ;-).</p>

<TABLE border=0>
  <TR>
    <TH align=left>Заменяемая функция</TH>
    <TH align=left>Замена</TH>
    <TH align=left>До замены</TH>
    <TH align=left>После</TH>
    <TH align=left>Выигрыш</TH>
  </TR>
  <TR>
    <TD>strlen</TD>
    <TD>lstrlen</TD>
    <TD>26624</TD>
    <TD>26112</TD>
    <TD>512</TD>
  </TR>
  <TR>
    <TD>sprintf</TD>
    <TD>strcpy+strcat</TD>
    <TD>26112</TD>
    <TD>18432</TD>
    <TD>7680</TD>
  </TR>
  <TR>
    <TD>strcat, strcpy</TD>
    <TD>lstrcat, lstrcpy</TD>
    <TD>18432</TD>
    <TD>17920</TD>
    <TD>512</TD>
  </TR>
  <TR>
   <TD colspan=5><HR></TD>
  </TR>
  <TR>
    <TD><B>Итого</B></TD>
    <TD><B>&nbsp;</B></TD>
    <TD><B>26624</B></TD>
    <TD><B>17920</B></TD>
    <TD><B>8704</B></TD>
  </TR>
</TABLE>

<p>Наибольший эффект дала замена
<pre class=code>sprintf(lpszMessage, "%s\n\"%s\"\n%s", lpszBegin, lpszExe, lpszError);</pre>
на
<pre class=code>strcpy(lpszMessage, lpszBegin);
strcat(lpszMessage, "\n\"");
strcat(lpszMessage, lpszExe);
strcat(lpszMessage, "\"\n");
strcat(lpszMessage, lpszError);</pre>

<p><small>(естественно, замена сначала на RTL-функции проводилась исключительно в исследовательских целях).</small></p>

<p>Т.о., для данного приложения выигрыш от замен составил порядка трети. Естественно, если размер скомпилированного приложения или библиотеки больше двух-трех сотен килограмм, "овчинка" (эти 8 КБ) вряд ли стоит выделки.</p>

<p>Так же стоит внести некоторое возражение относительно "отсутствия эффекта от оптимизации по размеру".

<p>Поскольку размер слинкованного приложения округляется до 512, то имеется достаточно большая
вероятность того, что при небольшом количестве исполняемого "пользовательского" кода выигрыш в несколько
сот байт просто не приведет к уменьшению файла.</p>

<p>В рассматриваемом микро-приложении при отключении оптимизации в "окончательном" варианте размер
подскакивает с 17920 до 18432 байт (т.е., на каких-то 32 "смысловых" строках оно таки наоптимизировало 512 байт).</p>

<p>При взятии чуть большего приложения, которому даже далеко до "среднего" по размеру программного
прожекта (тестовый проект состоял из 21 исходника на C и CPP суммарным размером около 150
килограмм), получаем такую статистику:</p>

<TABLE border=0>
  <TR>
    <TH align=left>Optimization</TH>
    <TH align=left>размер</TH>
    <TH align=left>выигрыш, %</TH>
  </TR>
  <TR>
    <TD>Disabled (debug)</TD>
    <TD>404480 (653824)</TD>
    <TD>-</TD>
  </TR>
  <TR>
    <TD>Default</TD>
    <TD>404480 (653824)</TD>
    <TD>-</TD>
  </TR>
  <TR>
    <TD>Maximize speed</TD>
    <TD>358912 (636416)</TD>
    <TD>11,3% (4,5%)</TD>
  </TR>
  <TR>
    <TD>Minimize size</TD>
    <TD>348160 (624128)</TD>
    <TD>13,9% (2,7%)</TD>
  </TR>
</TABLE>

<p><small>Компилировалась RELEASE-версия. Размер в скобках - это то же, но с включенной "Generate debug info" в релизе.</small></p>

<p>В качестве вывода - не стоит пренебрежительно относиться к стандартным средствам оптимизации.
Просто не всегда им есть где &quot;разгуляться&quot; ;-)</p>


<div align=right><code>
<br>&nbsp;<br>
08.05.2004
</code></div>
<div class=seecont><a href="#top">наверх</a></div>


</body>
</html>