<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>"Обработка нажатия ESC или . . ."</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<meta name="description" content="Обработка нажатия ESC или . . .">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<body>

<a name="top"></a>
<h1>"Обработка нажатия ESC или . . ."</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a> |
<a href="escape.html">статья</a>
</div>

<div align=right>
По материалам FAR.SUPPORT
</div>

<hr>
<pre class=code> From : Serg Bormant                        2:5027/12.80    Сpд 21 Фев 01 02:21
 Subj : FarCodePatterns :)</pre>
<hr>

<p class=plain>...процедурка набросалась, хотелось обсудить некоторые моменты...
<p class=plain>Основные отличия от <a href="escape_r1.html">варианта Василия Мошнинова</a>
в наличии небольшого буфера на стеке, дабы при небольшом количестве событий не дергать
GlobalAlloc() и GlobalFree(), плюс динамическое выделение/освобождение памяти
кусками, кратными 4 Кб.

<p class=plain>Вот только сомнение гложет -- есть в этом хоть какой-то смысл
или нет?

<pre class=code>#define Make4KSize( x ) ( ((x-1)/4096+1)*4096 )

#ifndef MAX_IR_BUF_SIZE
#define MAX_IR_BUF_SIZE (1024*2)
#endif

BOOL CheckForEsc( HANDLE hConIn, BOOL bClearESC )
{
  INPUT_RECORD irBuffer[MAX_IR_BUF_SIZE/sizeof(INPUT_RECORD)];
  INPUT_RECORD *irBuf=irBuffer, *ir;
  DWORD dwi, dwR;
  BOOL result=FALSE;

  GetNumberOfConsoleInputEvents(hConIn, &amp;dwR);
  if( dwR )
  {
    /* очередь событий не пуста */
    if( dwR &gt; sizeof(irBuffer)/sizeof(irBuffer[0]) )
    {
      /* все события в irBuffer не влезут */
      /* распределим динамический буфер кратный 4К */
      dwi = Make4KSize(sizeof(INPUT_RECORD)*dwR);
      if( ir = (INPUT_RECORD *)GlobalAlloc(GMEM_FIXED, dwi) )
      {
        /* получилось, выставляем указатели и размер */
        irBuf = ir;
        dwR = dwi / sizeof(INPUT_RECORD);
      }
      else
        /* есть шанс, что ESC попадет в irBuffer */
        dwR = sizeof(irBuffer)/sizeof(irBuffer[0]);
    }

    if( PeekConsoleInput(hConIn, irBuf, dwR, &amp;dwR) )
      /* поищем ESC */
      for( dwi = 0, ir = irBuf; dwi &lt; dwR; dwi++, ir++)
        if( KEY_EVENT == ir-&gt;EventType
          &amp;&amp; ir-&gt;Event.KeyEvent.bKeyDown
          &amp;&amp; VK_ESCAPE == ir-&gt;Event.KeyEvent.wVirtualKeyCode )
        {
          /* нашли, чистить ESC будем? */
          if( bClearESC ) dwi++;
          /* очистим очередь */
          if( dwi ) ReadConsoleInput(hConIn, irBuf, dwi, &amp;dwR);
          result = TRUE;
          break;
        }
    if( irBuf != irBuffer )
      /* irBuf был динамический, почистим */
      GlobalFree((HGLOBAL)irBuf);
  }
  return (result);
}</pre>

<hr>
<pre class=code> From : Jouri Mamaev                        2:5080/80.66    Сpд 21 Фев 01 08:02
 Subj : FarCodePatterns :)</pre><hr>

<p class=plain>Эта процедура, насколько я понимаю (да и в оригинале так)
должна использоваться в "долгоиграющих" ситуациях на случай если юзер
возжелал отменить операцию, так?

<p class=plain>Тогда она просто не пригодна, ибо нужно знание не о том,
что где-то в буфере есть ESC, а в том, что <u>текущий нажатый</u> ESC.

<p class=plain>А все остальные <u>читать</u> и игнорировать. Т.е. как только
хоть что-то в буфере оказалось - оно обязано быть прочитано и обработано.

<p class=plain>Таким образом твоя процедура просто не делает то, что от нее
требуется, а "оригинал" делает :)

<p class=plain>Либо ее надо всегда использовать, так:
<pre class=code>if ( CheckForEsc( ..., TRUE) ) PluginAbort();</pre>
смысл тогда во всех этих наворотах со сканированием кеки?

<p class=plain>Или я не о том, и ее еще как-то можно использовать ?

<div align=right><code>
<br>&nbsp;<br>
15.04.2000
</code></div>
<div class=seecont><a href="#top">наверх</a></div>
</body>
</html>