<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Синдром ``Рождественской Ёлки'' или Свобода Безумия</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rev="made" href="mailto:ruiv@uic.nnov.ru">
<meta name="Author" content="Igor Ruskih/Cail Lomecb">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<script language="javascript" src='../links.js' type="text/javascript"></script>
</head>
<!--history
-->
<body>

<h1>Синдром ``Рождественской Ёлки'' или Свобода Безумия</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
Игорь Русских <a href="mailto:Igor%20Ruskih%20<ruiv@uic.nnov.ru>?subject=Articles%3A%20colorer%20freecraze">
<img src="../../images/email.gif" border=0 alt="[ruiv@uic.nnov.ru]" width=16 height=16 align=middle>ruiv@uic.nnov.ru
</a>
</code></div>
<hr color="#003399">

<h2>Лирика</h2>
<p class=plain>
Привет. Тут вот недавно вышел новый колорер, и решил я маленько его
подкомментировать. Вообще, я давно заметил очень странное явление - колорер
выходит сам. И меня тут заинтересовало, как это он так выходит, по своей воле.
Наверное все-таки я сам его делаю, только не замечаю как. Необычная это
программа вышла, вообще на программу-то не похожа.
<p class=plain>
Последняя на сегодня версия <code>FreeCraze</code> включает в себя помимо
привычного вам плагина еще и программу вьювер вместе с генератором цветных
HTML-листингов кодов. Но это не главное. Главное то, что почему-то в архиве
вместе со всем этим оказались все исходники колорера. Как всегда, что бы я
не делал, меня опять начали, мягко выражаясь, обругивать. То у тебя
документация левая и неправильная, непонятно в ней ничего, то сам колорер не
работает из-за его большой неправильности, то вот теперь вроде как
начинаются упреки о том, что исходники недостаточно ``лиричны''. Ну, то бишь
непонятно в них ничего. Кто-то сказал, что в хорошем проекте исходники должны
состоять из комментариев, слегка разбавленных инструкциями.
Ну что-ж, у меня поганый проект. Комментариев там нет вообще.
<p class=plain>
Ну и вот тут я попытаюсь кой-как это все хозяйство <em>прокомментировать</em>.
Все-таки колорер вроде как библиотека - захотите вы его использовать у себя
где-нить, а как, чем, какой стороной - не понятно. Ну, во-первых не надо
думать, что колорер - это что-то сложное, сверх заумное и вообще из компьютерной
магии. Не совсем так. На самом деле все можно просто понять, тем более, что
для того чтобы использовать его как библиотеку в исходниках вовсе не обязательно
штудировать их от корки до корки. Хотя, конечно, и это может быть полезно, так
как вообще говоря колорер состоит из нескольких модулей, которые вообще-то
и сами-по-себе представляют некоторую ценность.</p>

<h2>Shared codes</h2>
<p class=plain>В принципе вся либа колорера состоит из нескольких модулей,
которые могут использоваться как вместе, так и по-отдельности.
Плагин колорер - это всего лишь интерфейсная оболочка, такая же, как и
лежащий вместе с ним <code>colorer.exe</code> (их исходники находятся
соответственно в каталогах ( <code>/src/colorer/</code> и
<code>/src/colorlib/</code> ). Все разделяемые модули находятся в каталоге
<code>/src/shared/</code>.</p>

<h3>SGML</h3>

<p class=plain>
Первый модуль и самый простой - это модуль парсинга SGML(HTML) подобного
текста ( <code>/src/shared/sgml/</code> ). На самом деле на него можно не
обращать внимания, так как он используется колорером для внутренних целей
полностью автоматически. Единственно для чего он вам может понадобиться -
это для работы с расширенными параметрами в описаниях блоков
<code>&lt;type&gt;</code> скриптов HRC. Так, всякие дополнительные параметры
навроде цвета текста и фона по умолчанию, подсветки скобок и всей остальной
чуши - реализуются модулем <b>плагина</b>. Иными словами сама библиотека по
своим структурам никакие эти параметры не поддерживает. Если вам нужна
аналогичная функциональность, то использовать SGML-парсер вам придется.
Но, повторяю, там ничего сложного - единственный класс, который по методу
<code>parse</code> генерирует дерево, преобразуя параметры, названия тэгов,
и сохраняя линейный текст и комментарии. Как сгенерированное дерево использовать
вы можете понять из описания класса <code>CSgmlEl</code> и из исходников
плагина ( <code>/src/colorer/pcolorer.cpp</code> ).
<p class=plain>методы и свойства класса CSgmlEl:
<ul>
<li><code>bool parse(char *src,int sz);</code><br>
 Парсинг данных из <dfn>src</dfn> размером <dfn>sz</dfn>. Создает дерево объектов.
<li><code>parent(), next(),  prev(),  child()</code><br>
 Возвращают указатели на соответствующий объект в дереве.
<li><code>char   *name;</code><br>
 Имя тэга, если объект - тэг.
<li><code>  char   *content;  int     contentsz;</code><br>
 Линейный текст и его размер - если объект - не тэг, а простой текст.
<li>Все остальные методы и данные представляют собой дополнительные атрибуты.
</ul>

<h3>Регэкспы</h3>

<p class=plain>
Немногим более сложным является модуль регэкспов.
( <code>/src/shared/regexp/</code> )
В принципе его вам вообще
можно не понимать (тем более многие люди испытывают какой-то животный страх
при одном слове ``регэксп'' и отмахиваются всеми шестью руками с саблями,
когда им начинаешь пытаться объяснить что ничего сложного нет, и основы
можно понять прямо сейчас). Но очень часто регулярные выражения можно
использовать как отдельную возможность по расширению и использовать
их в областях никак не связанных с расцветкой (к примеру поиск, замена).
На самом деле если вы уже знаете что это такое, то всунуть эти коды в вашу
программу не составит никакой сложности. У класса CRegExp фактически два
основных метода - SetExpr и Parse. Все остальное - это их вариации.
К слову сказать коды моих регэкспов полностью портируемы,
и работают даже под DOS :)
<p class=plain>public-методы класса CRegExp:
<ul>
<li><code>bool SetExpr(char *Expr);</code><br>
 Устанавливает  и  компилирует  регулярное  выражение  из строки
 <dfn>Expr</dfn>.   Может   вызываться   несколько  раз  для  одного  объекта.
 Возвращает <dfn>true</dfn> в случае успеха и <dfn>false</dfn> при ошибке разбора.
<li><code>bool SetNoMoves(bool Moves);</code><br>
 Устанавливает  значение перемещения по целевой строке по умолчанию
 (в    случае    использования    <dfn>moves</dfn>=-1).   <dfn>false</dfn>   эквивалентно
 множественному   парсингу   регэкспа  для  каждой  позиции  строки
 в отдельности.
<li><code>bool Parse(char *Str,char *Sol, char *Eol, PMatches Mtch, int Moves = -1);</code><br>
 Пытается сопоставить регулярное выражение строке <dfn>str</dfn>
 и  сохранить  результат совпадения скобок в структуру, указываемую
 <dfn>mtch</dfn>. Параметры Sol и Eol указывают начало и конец строки (которые
 в  общем   случае  могут  не  совпадать  со  строкой  str). mtch -
 указатель  на  структуру  SMatches,  определенную  в  заголовочном
 файле.  Эта  структура  хранит  совпавшие позиции скобок. Параметр
 moves  -  возможность  перемещаться по строке в поиске совпадения.
 Если  moves  равен  -1, то используется установленное по умолчанию
 значение    перемещения.    Возвращает   результат   сопоставления
 (true/false).
<li><code>bool Parse(char *Str, PMatches Mtch);</code><br>
 Аналогична предыдущей, но считает некоторые параметры по умолчанию.
 Sol=str; Eol=str+strlen(str); moves=-1;
<li><code>bool SetBkTrace(char *Str, PMatches Trace);</code><br>
 Устанавливает связь между двумя объектами регэкспов через оператор
 <dfn>\yN</dfn>.  Регэксп  re  при  встрече  такого оператора будет сравнивать
 текущее  положение  в  целевой  строке  со строкой <dfn>str</dfn> по смещению
 trace.s[N].
<li><code>bool isok();</code><br>
 Возвращает результат компиляции. Полезна при компиляции из
 конструктора объекта.
</ul>


<h3>Другое</h3>
<p class=plain>Несколько файлов в других каталогах - это просто вспомогательные
функции. Там же лежит plugins.hpp, дополнительные коды для работы с реестром,
числами. Мелочь короче.</p>

<h3>Colorer library - CColorData</h3>
<p class=plain>Ну вот добрались до самого главного. В каталоге
<code>/src/shared/colorer/</code> лежат главные модули библиотеки по
парсингу и расцветке кода. Эти коды делятся на два модуля: первый (ccdata.cpp)
используется для загрузки и компиляции HRC-базы, второй (ccolorer.cpp) -
непосредственно для динамической расцветки текстов. Соответственно в разделяемом
файле classes.h (который вы тоже должны подключить в свой проект) описаны два
главных класса - <code>CColorData</code> и <code>CColorer</code>.

<p class=plain>
CColorData - класс, ответственный за загрузку и компиляцию HRC-скриптов.
Хочу подчеркнуть,
что текущая структура скриптов (имеется в виду дерево каталогов и организация
некоторых соглашений по использованию цветов, определений, постановок) совсем
не обязательны и не фиксированы. Иными словами, вы можете в вашем проекте
взять из HRC-кодов только необходимые вам файлы, скомпоновать их в один
большой (с расчетом на то, что пользователь не будет в вашей программе менять
конфигурацию колорера) и подавать на парсинг именно этот файл. Замечу также,
что значения цветов, используемых для раскраски вовсе не фиксированы. Смысл в
том, что вы можете однозначно сопоставить каждой лексеме в расцвечиваемом
коде определенный индекс цвета (ведь их может быть больше 16 - максимум 0xFFFF
текста и столько же цветов фона - ограничения консоли на цвета не играют для
библиотеки никакой роли), а уже в своей программе давать возможность
пользователю сопоставлять каждой лексеме любой требуемый цвет. Надеюсь
идея дошла. Теперь обзор основных методов:
<ul>
<li><code>CColorData(char *path, char *ef);</code><br>
<li><code>CColorData(char *data, int len, char *ef);</code><br>
 Два варианта конструктора для инициализации базы. Первый - с указанием
 пути до внешнего файла, второй - непосредственная передача библиотеке
 данных уже готового файла указанной длины. В первом случае возможно
 применение в скрипте директивы подключения других файлов (пути считаются
 относительно базового файла), во втором же случае эта директива не
 имеет смысла. В обоих конструкторах параметр <dfn>ef</dfn> задает имя
 файла для отладочной информации. При нулевом значении не получите вы
 лога. Хочу заметить также, что объект CColorData фактически одноразовый
 объект. То есть если вам вдруг взбрендило заново перечитать и скомпилировать
 скрипты, вы должны удалить этот объект и создать заново.
 Ничто не запрещает вам иметь несколько представителей этого класса, хотя толку
 от этого мало.
 <p>Заметьте, что вся база не загружается - грузится только базовый файл.
 Реальная компиляция схем из других файлов происходит при вызове метода
 loadtype. Из всего этого следует, что если вы все схемы и определения поместите
 в один файл (для компактности к примеру), или вообще будете вызывать
 второй вариант конструктора, когда никакого файла может и не
 существовать (данные к примеру могут храниться в ресурсах вашего проекта),
 все преимущество частичной загрузки баз сходит на нет - так как все схемы
 начнут компилироваться сразу из конструктора.
 <hr>
 Но, естественно, при небольших
 размерах базы это оправдано, так как даже полная база (~400Kb в версии
 FreeCraze), в библиотеке, собранной в VC6.0, грузится около четырех секунд.
 Хочу кстати заметить, что либа, собранная в BC5.0 при максимуме оптимизации
 работает при парсинге текста с той же скоростью, а при компиляции баз в пять
 раз медленнее (~20 секунд). Компилятор GCC дает около 15 секунд.
 Возможно, я получил не совсем корректные результаты - с удовольствием поспорю
 относительно иных параметров оптимизации компиляции. Замеры брались из логов
 загрузки колорера.
 <hr>

<li><code>bool isok();</code><br>
 Результат компиляции. Сбой может произойти только при грубых ошибках -
 отсутствие самого файла, окаймляющего блока, и так далее. Все остальные
 ошибки при компиляции игнорируются и только могут заноситься в лог.
<li><code>unsigned int GetColor(char *name);</code><br>
 Функция, используется для возвращения значения цвета от символьного имени
 <dfn>name</dfn> с учетом <b>только загруженных</b> цветовых определений.
<li><code>PType enumtypes(PType next);</code><br>
 Возвращает следующий тип за типом <dfn>next</dfn> в списке типов PType.
 Вообще-то лишняя, так как к соответствующему элементу в типе SType (*PType)
 можно обратиться напрямую - он открыт.
<li><code>PType seltype(char *fname, char *fstline, int no = 0);</code><br>
 Выбирает соответствующий файлу тип по имени файла и по первой строке файла.
 <dfn>no</dfn> - если несколько типов попадают под имя файла, номер выбираемого.
 Стоит наверное устанавливать его в ноль - он же по умолчанию подразумевается.
<li><code>bool loadtype(PType type);</code><br>
 Физически загружает тип по указанному указателю. Именно этот метод
 компилирует все необходимые схемы, регэкспы, и обновляет перекрестные ссылки.
 Уже загруженный тип еще раз не загружается.
 Использование этого метода позволяет загружать базу только по частям. То есть
 методы seltype и enumtypes вы можете вызывать и без вызова соответствующего
 вызова loadtype.
</ul>
<p class=plain>Три последних типа используют открытую структуру
<code>SType (*PType)</code>. Это связанный список структур, и в каждой
из них хранится информация о соответствующем типе, включая указатель на
CSgmlEl объект, который можно использовать для получения дополнительных
атрибутов. Я бы рекомендовал использовать ее как readonly :)

<h3>CColorer</h3>
<p class=plain>
Этот класс является дополнением к классу CColorData, и если
тот ничего не знает о нем, то CColorer полагает существование
загруженного класса CColorData - из него он черпает информацию о
непосредственной расцветке, коей сам и занимается.
В отличие от класса CColorData вы можете создавать несколько представителей
класса CColorer - к примеру для каждого окна в вашем редакторе. Это необходимо,
так как этот класс варится в собственном соку и хранит много информации,
зависимой от содержимого расцвечиваемого файла. Сначала маненький обзорчик по
сервисам, потом скажу что к чему.
<ul>
<li><code>bool SetServices(char*(*gl)(PColorer, int, int*), void (*vr)(PColorer));</code><br>
 Устанавливает сервисы для обработки со стороны программы.
 <dfn>char*(*gl)(PColorer, int, int*)</dfn> - функция, возвращающая
 строку с запрашиваемым номером для обработки объектом и ее длину.
 Второй указатель - вообще говоря редко используется - синхронизационное
 сообщение - необходимо при реализации многопоточного парсинга
 (в теории - на практике сильно лень пробовать :)
<li><code>bool SetColoringSrc(PType type);</code><br>
 Устанавливает тип, используемый для расцветки текста. Указатель из параметра
 может быть получен любым способом, описанным в предыдущем разделе.
<li><code>PLineHL SetMaxLines(int num);</code><br>
 Устанавливает размер массива для строчек. Программа не может одновременно
 запрашивать на расцветку число строк, большее установленного сначала здесь.
 Можно вызывать этот метод несколько раз для изменения размера массива.
 Возвращает указатель на соответствующий массив структур SLineHL.
 <p><code>SLineHL</code> - это структура, которая определяет один
 элемент  расцвеченного  текста. Во время работы вы получаете указатель
 на  массив  таких структур размером вами же заданным. Этот размер чаще
 всего  -  количество одновременно видимых строк на экране - или можете
 взять  с  запасом  если  это  значение  у вас меняется. Первый элемент
 всегда  пустой, и содержит внутреннюю информацию. Лучше его не трогать
 - ровно как и всю структуру.
 <p>Собственно  данные  начинаются  с элемента массива  <code>PLines[1]</code>.
 Каждый элемент   -   строка,  номер  которой  вы  задали  при  вызове функции
 парсинга   текста.   В   каждом  элементе  содержится  указатель  next
 на  следующую  такую структуру в строке. Замечу, что в самих элементах
 массива  информации  не содержится - они просто скелет. Вся информация
 о  расцветке(откуда,  докуда,  и  каким  цветом)  содержится в списках
 динамических структур, связанных указателем next.

<li><code>bool CompactLines();</code><br>
 Вспомогательный метод - сжимает цветовые области. Смысл в том, что
 в полученном массиве вообще говоря цветовые области могут перекрываться и
 накладываться друг на друга - это не проблема при отображении их к примеру на
 экран - но вот когда надо сгенерировать с них код (что делает colorer.exe с
 параметром <code>-h</code>), это может обернуться проблемками.
 Этот сервис после вызова гарантирует, что цветовые области будут упорядочены
 без перекрытий.
<li><code>bool ClearCache();</code><br>
 Чистит внутренний кэш расцветки. Нужно вызывать при смене типа расцветки
 в объекте.
<li><code>void BreakParse();</code><br>
 Останавливает процесс расцветки, если он работает в другом потоке. Вызывать
 естественно стоит из другого потока. Применяется только при
 использовании многопоточной системы расцветки.
<li><code>int  QuickParse(int from, int num);</code><br>
 Быстрый  парсинг  <dfn>num</dfn>  строк  текста начиная со строки
 <dfn>from</dfn>.  возвращает  строку,  на которой закончился парсинг. Быстрый
 парсинг   означает,   что  не  строится  ни  каких  дополнительных
 структур,  и  текст  расцвечивается  линейно  в указанных пределах.
 Расцветка  будет некорректной, если строка from попадет в середину
 какой-либо вложенной схемы. Может применяться для полной расцветки
 текста от начала до конца - в этом случае корректность естественно
 гарантируется.
<li><code>int  FullParse(int from, int fvis, int visnum, int allnum);</code><br>
 Полный парсинг с заполнением внутренних структур. Текст
 парсируется  cо строки <dfn>from</dfn>, анализируется <dfn>allnum</dfn> строк. Параметры
 <dfn>fvis</dfn>  и  <dfn>visnum</dfn>  определяют  соответственно  начальную  строку  для
 заполнения  структур  SLineHL  и  общее  число  строк,  подлежащих
 цветовому  парсингу. Это число не должно превышать размер выделенного
 функцией SetMaxLines массива.
 Этот  вид  парсинга предварительно сохраняет
 информацию  о предыдущих результатах во внутреннем кэше. При новом
 обращении к функции расцветка начинается с той схемы, которая была
 сохранена  при предыдущем парсинге. При этом необходимо расцветить
 только  лишь  один  экран  (что  очень  быстро), и все вложенности
 блочных   схем   будут   соблюдаться.   Функция  обладает  большой
 гибкостью,  и  может  использоваться в различных вариантах, вплоть
 до  фонового  парсинга в  отдельном потоке.  Возвращает строку, на
 которой был остановлен (или окончен) разбор.
</ul>

<p class=plain>
Ну вот. Примерно значит так. Я думаю элементарный парсинг с использованием
QuickParse объяснять не надо - там все линейно и без особых точек.
Немного поподробнее надо поговорить о методе FullParse. Не знаю с чего
начать объяснять, там любое место связано с другими еще необъясненными.
Гмм... Ну первое что надо понять - это соотношения производительности.
На примере реализации библиотеки в плагине вы можете видеть, что скорость
практически на всех типах файлов приемлема. Ну то-есть жить можно. На некоторых
конечно побыстрее, некоторые довольно тормозят - но в общем ничего.
И это все на моем стареньком p166mmx. Думаю на любой другой телеге на порядок
быстрее. Это зафиксировали. Теперь еще одна вещь - плагин использует наиболее
медленный вариант расцветки кода. Конкретнее, при любом нажатии клавиши, даже
клавиш курсора, происходит полный парсинг через FullParse текущего экрана.
Все это связано с ограничениями ФАРовского внутреннего редактора, и вас не
больно должно волновать. Единственно из всего этого хочу до вас донести
идею, что при использовании библиотеки целенаправленно в своем проекте
вы можете добиться еще больших скоростей. Как минимум вы будете избавлены
от работы при каждом перемещении курсора... необходимо контролировать только
действия по непосредственной модификации текста (ну или по его прокрутке :))
<p class=plain>
Теперь что конкретно значит кэширование при работе этот метода.
Метод FullParse вы вызываете с двумя парами параметров - фактически внешними
границами и внутренними (выраженными в строках). Внутренними границами чаще
всего выступают строки, видимые на экране в текущий момент. Это то, на что
реально заполняются цветовые структуры. Окаймляющие границы также полностью
парсятся - но цветового заполнения не происходит - так как вы их не видите,
и вам это просто не надо. После того, как вы первый раз вызвали этот метод,
он у себя автоматически сохраняет всю структуру и вложенность схем, которые
прошли парсинг. Если в следующий раз этот метод вызовется откуда-нибудь с
середины текста, вместо того, чтобы начинать парсинг с нуля - с нулевой схемы
(что фактически может быть неправильно - к примеру эта середина попадет внутрь
комментария - и это простейший конфликт), функция обратится к кэшу и начнет
парсинг с сохраненной в этой позиции схемы - а потом произойдет ``раскрутка''
схем назад - так как они могут быть многократно вложены. В итоге текст
раскрасится с учетом блочных комментариев - хотя начинались они где-то раньше,
и мы вообще-то не знали где. А расцветка в то же время корректная.
<p class=plain>
Короче можно сформулировать такое правило: Полученный код гарантированно
будет расцвечен, если каждый раз при вызове FullParse происходит зацеп
текста - то есть если в прошлый раз вы вызвали
<pre class=code>  <font color=#007777>//</font><font color=#007777> параметры распределяются следующим образом:</font>
  <font color=#007777>//</font>
  <font color=#007777>//</font><font color=#007777> from ------------+</font>
  <font color=#007777>//</font><font color=#007777> ..               |</font>
  <font color=#007777>//</font><font color=#007777> fvis ---------+  +- в этих пределах происходит</font>
  <font color=#007777>//</font><font color=#007777> ..            +--+  заполнение структур с цветовыми</font>
  <font color=#007777>//</font><font color=#007777> fvis+visnum --+  +- областями</font>
  <font color=#007777>//</font><font color=#007777> ..               |</font>
  <font color=#007777>//</font><font color=#007777> from+allnum -----+</font>
  <font color=#007777>//</font>
  FullParse<font color=#992016>(</font>from<font color=#992016>,</font> fvis<font color=#992016>,</font> visnum<font color=#992016>,</font> allnum<font color=#992016>)</font><font color=#992016>;</font>
</pre>
То в следующий раз вы должны передать в параметре <dfn>from</dfn> значение,
не превышающее предыдущие <dfn>(from+allnum)</dfn>. В этом случае вы
гарантированно не сможете пропустить никакой начинающийся блок, и как следствие
получите корректную расцветку. Естественно, это правило не всегда удается
выполнить - если юзер к примеру находясь в начале файла вдруг захочет
проскочить сразу в конец его, то по этому правилу вам придется для корректности
провести парсинг всего текста. На первой-второй тысяче строчек это еще
не так критично - а вот потом время начинает неприятно увеличиваться.
<p class=plain>В плагине колорер это решено довольно просто - по превышению
некоего критического значения числа строк (задается параметром backparse),
эти строки просто проскакивают. Как следствие возможны сбои в расцветке.
Но! Для того чтобы увидеть такие сбои, надо специально потрудиться
и создать специальный файл. Другими словами на обычных файлах этого не
заметишь - практически всегда все будет корректно.
<pre class=code>  <font color=#007777>//</font><font color=#007777> fr - это параметр, задающий откуда начнется кэширование и расцветка</font>
  <font color=#007777>//</font><font color=#007777> CurList-&gt;endline - это его старое значение.</font>
  fr <font color=#992016>=</font> <font color=#992016>(</font>EditInfo<font color=#992016>.</font>TopScreenLine <font color=#992016>&gt;</font> CurList<font color=#992016>-</font><font color=#992016>&gt;</font>endline<font color=#992016>)</font><font color=#992016>?</font>CurList<font color=#992016>-</font><font color=#992016>&gt;</font>endline<font color=#992016>:</font>EditInfo<font color=#992016>.</font>TopScreenLine<font color=#992016>;</font>
  CurList<font color=#992016>-</font><font color=#992016>&gt;</font>endline <font color=#992016>=</font> EditInfo<font color=#992016>.</font>TopScreenLine<font color=#992016>;</font>
  <font color=#007777>//</font><font color=#007777> тут есть дополнительная обработка на блочное выделение - нас это не волнует</font>
  <font color=#007777>//</font><font color=#007777> ...</font>
  <font color=#007777>//</font><font color=#007777> а вот тут глядится, превысила ли длина необходимого для парсинга текста</font>
  <font color=#007777>//</font><font color=#007777> некое критическое значение (CurList-&gt;typeinfo-&gt;backparse)</font>
  <font color=#007777>//</font><font color=#007777> если да - то число линий для парсинга уменьшается...</font>
  <font color=#992016>if</font> <font color=#992016>(</font>EditInfo<font color=#992016>.</font>TopScreenLine <font color=#992016>-</font> fr <font color=#992016>&gt;</font> CurList<font color=#992016>-</font><font color=#992016>&gt;</font>typeinfo<font color=#992016>-</font><font color=#992016>&gt;</font>backparse<font color=#992016>)</font>
    fr <font color=#992016>=</font> EditInfo<font color=#992016>.</font>TopScreenLine <font color=#992016>-</font> CurList<font color=#992016>-</font><font color=#992016>&gt;</font>typeinfo<font color=#992016>-</font><font color=#992016>&gt;</font>backparse<font color=#992016>;</font>
  <font color=#007777>//</font><font color=#007777> А это вызывается сам парсер с соответствующими параметрами номеров строк</font>
  <font color=#007777>//</font><font color=#007777> Заметьте, что начало реального парсинга (fr) не совпадает с началом</font>
  <font color=#007777>//</font><font color=#007777> расцветки текста (EditInfo.TopScreenLine)</font>
  CurList<font color=#992016>-</font><font color=#992016>&gt;</font>FullParse<font color=#992016>-</font><font color=#992016>&gt;</font>FullParse<font color=#992016>(</font>fr<font color=#992016>,</font> EditInfo<font color=#992016>.</font>TopScreenLine<font color=#992016>,</font> EditInfo<font color=#992016>.</font>WindowSizeY<font color=#992016>,</font>
     EditInfo<font color=#992016>.</font>TopScreenLine <font color=#992016>-</font> fr <font color=#992016>+</font> EditInfo<font color=#992016>.</font>WindowSizeY<font color=#992016>)</font><font color=#992016>;</font>
</pre>

Я хочу подчеркнуть, что колорер оптимизирован и рассчитан на то, что
юзер - нормальный программер. То есть чаще всего он работает только в
определенной области файлов, резкие переходы совершает только может быть
на начало да на конец файла. Ну, это уже психология. И это правильно.
При таких предположениях колорер работает стабильно и сверх-быстро.
Некоторые сомнения вызывает только резкий переход на конец файла. Что
происходит в этом случае? Чего делать?
<p class=plain>Во-первых вы должны себе ясно уяснить
что для <b>абсолютно</b> корректного продолжения расцветки в <b>любом</b>
случае вам необходимо провести парсинг всего текста. Если не очень можется
вериться, попробуйте рассмотреть схему с одним блочным комментарием, в котором
начало и конец представляются одной и той же комбинацией символов. И
соответственно файл, в котором периодически эти комментарии повторяются.
При изменении чего-то в начале(это что-то может включать в себя и символ начала
комментария) и моментального перехода в конец для корректной расцветки
вам остается только лишь парсить весь текст. И от этого не убежишь.
Если текст большой - соответственно время увеличивается пропорционально.
<p class=plain>И в этом случае, и вообще при случайном переходе по тексту(когда
пользователю к примеру взбрело подергать мышкой линейку прокрутки туда-сюда),
вы можете воспользоваться функцией <code>QuickParse</code> для раскраски только
текущего экрана. Естественно может оказаться, что полученная расцветка будет
неверна - но зато работать будет сверх-быстро. Дополнительно к этому вы
можете попытаться запустить в фоновом потоке функцию FullParse (кстати
этого не надо делать для одного и того же объекта - лучше создать два
объекта CColorer, ссылающихся на один тип данных). Если юзер успокоился, то
через пару мгновений у него на экране появится правильная расцветка вместо
показанной сначала некорректной. Если же попался буйный - то вы можете
использовать функцию BreakParse для прерывания обработки во втором потоке
и возобновлении ее опять с нужного места (так как гипотетически очень наглый
юзер может быстро прокручивать текст мышкой да еще и изменять его :-)).
Для этого-же предназначен таинственный второй метод <dfn>vr</dfn> в
функции <code>SetServices</code>. Библиотека вызывает его, когда процесс
расцветки закончился либо сам-по-себе либо когда его прервали функцией
BreakParse. Короче это синхронизационное сообщение. По идее эта функция
должна сообщить первому потоку (который отвечает за ввод пользователя), что
расцветка закончилась, можно вызывать парсинг заново (это она может сделать
посредством либо Event'ов, либо посредством любой другой синхронизации - не
мне вас учить).

<p class=plain>
Для оптимизации по скорости при вводе пользователем единственно что вам
надо - это расцвечивать только текущий экран. Как уже было сказано это
делается мгновенно. Определенный интерес может представлять оптимизация
для линейного просмотра текста, то есть когда пользователь давит <b>down</b>
и линейно глядит весь текст. Для того, чтобы каждый раз при изменении не
парсить экран заново (в конце концов и это для некоторых типов становится
медленным), вы можете запускать парсинг только при сдвиге всего текста.
Далее, чтобы при каждом сдвиге не анализировать текст, вы можете поступить
следующим образом: выделить массив
<pre class=code>  <font color=#007777>//</font><font color=#007777> num - количество строк на экране</font>
  cl<font color=#992016>-</font><font color=#992016>&gt;</font>SetMaxLines<font color=#992016>(</font> num <font color=#992016>*</font> <font color=#009900>2</font> <font color=#992016>)</font><font color=#992016>;</font>
  <font color=#007777>//</font><font color=#007777> расцвечивать, только если добрались до строчки,</font>
  <font color=#007777>//</font><font color=#007777> не содержащейся в массиве цветовых областей.</font>
  <font color=#992016>if</font> <font color=#992016>(</font>topline<font color=#992016>+</font>num <font color=#992016>&gt;</font> from <font color=#992016>+</font> num<font color=#992016>*</font><font color=#009900>2</font><font color=#992016>)</font><font color=#992016>{</font>
    from <font color=#992016>=</font> topline<font color=#992016>;</font>
    cl<font color=#992016>-</font><font color=#992016>&gt;</font>FullParse<font color=#992016>(</font>from<font color=#992016>,</font> topline<font color=#992016>,</font> num<font color=#992016>*</font><font color=#009900>2</font><font color=#992016>,</font> num<font color=#992016>*</font><font color=#009900>2</font><font color=#992016>)</font><font color=#992016>;</font>
  <font color=#992016>}</font><font color=#992016>;</font>
</pre>
<p class=plain>Аналогично вы можете выделить массив в три раза больший
экрана для кэширования предыдущего экрана и следующего...
Увеличение времени парсинга экрана в два-три раза с лихвой окупается
скоростью прокрутки текста.
Вот такие вот каменья.
<p>Напомни мне если я пел об этом раньше, я все равно не помню ни слова.
Напомни мне если я пел об этом раньше - и я спою это снова,
я не знаю ничего другого...</p>

<h2>Последний раздел</h2>
<p class=plain>
Есть два типа людей. Первые могут воспринимать колорер в стандартном
дистрибутивном виде, вторые не могут. Соответственно первые (куда вхожу и я)
могут воспринимать гамму цветов колорера, вторые не могут. Проблема вторых
известна как синдром Рождественской Ёлки. Думаю, здесь имеют место глубокие
инфантильные связи, первично обозначившиеся в домладенческом периоде.
Причем физиологию уже не поменять. Я привык теперь (думаю как и многие из вас)
к тому, что можно находить простейшие ошибки и опечатки уже на этапе набивки
кода. И, вообще говоря, при написании HRC кодов я стремлюсь именно к этому.
Основное правило гласит, что главным является не корректно расцвечиваемый
правильный код, а ясно видимый и различимый неправильный код. Хотя, конечно,
первое тоже важно. Ну и прежде чем хандрить по поводу рождественской гирлянды
попробуйте различные варианты настройки цветов. Возможно, что даже какой-то
из дистрибутивных вам понравится. Ну а если нет, то никто не мешает вам
определить свою цветовую схему - на вкус и, главное, цвет товарищей нет...
<p class=plain>Ну вот, думаю выложил все что смог, чего непонятно - спрашивайте.</p>


<div align=right>
<code>
Cail Lomecb<br>
Sat 25 Mar 2000
<br><br>
</code>
<small>
Если б вы знали, как мне надоел скандал,<br>
Я готов уйти. Эй, кто здесь претендует на мой пьедестал?<br>
Где та молодая шпана,<br>
что сотрет нас с лица земли ?<br>
Ее нет, нет, нет...<br>
Ее нет, нет, нет...<br>
</small>
</div>

</body>
</html>
