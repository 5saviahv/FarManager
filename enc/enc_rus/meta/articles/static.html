<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>О пользе и вреде static в диалогах.</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rev="made" href="mailto:jourim@usue.ru">
<meta name="Author" content="Jouri Mamaev">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<script language="javascript" src='../links.js' type="text/javascript"></script>
</head>
<!--history

-->
<body>

<a name="top"></a>
<h1>О пользе и вреде static в диалогах.</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>


<div align=right><code>
Jouri Mamaev <a href="mailto:Jouri%20Mamaev%20<jourim@usue.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[jourim@usue.ru]" width="16" height="16" align="middle">jourim@usue.ru
</a></code></div>

<hr color="#003399">

<div align=right>
Счастливым обладателям С++ посвящается.<br>
Плюс немного о языках.<br>
</div>

<h2>Введение</h2>
<p class=plain>Одним из удобных, да и очевидных, способов описания
статического, т.е. полностью обрабатываемого ФАРом диалога является
следующий:</p>
<pre class=code>
bool DoConfigure( void )
{
  static FarDialogItem itm[] = {
       {     DI_CHECKBOX, 1, 1, 0, 0,  0, NULL, 0,            0, "&amp;Enabled" },
       {         DI_TEXT, 1, 2, 0, 0,  0, NULL, DIF_LEFTTEXT, 0, "&amp;Activators" },
       {     DI_CHECKBOX, 2, 3, 0, 0,  0, NULL, DIF_GROUP,    0, "Control" },
       {     DI_CHECKBOX, 2, 4, 0, 0,  0, NULL, 0,            0, "Alt" },
       {     DI_CHECKBOX, 2, 5, 0, 0,  0, NULL, 0,            0, "Shift" },
       {     DI_BUTTON,   2, 6, 0, 0,  0, NULL, 0,            0, "&amp;OK" },
       {     DI_BUTTON,  12, 6, 0, 0,  0, NULL, 0,            0, "&amp;Cancel" },
  };
  //Заполнение данных элемента диалога реальными данными плагина
  ...
  //Выполнение диалога
  if ( Info.Dialog( Info.ModuleNumber,-1,-1,25,15,NULL,
                     itm,sizeof(itm)/sizeof(itm[0]) ) == -1)
      return false;
  //В случае успешного завершения диалога получение отредактированных
  //  пользователем данных
  return true;
}</pre>

<p class=plain>Однако те, кто писал (и закончил) свой плагин, после того
как проходит эйфория от выполненной работы, замечают несколько "проблем"
такого подхода.</p>

<ol>
<li>Размер плагина, с количеством используемых в нем диалогов и
    диалоговых элементов растет как на дрожжах.
    <p>Не помогают ни оптимизация плагина, не подключение динамического
    RTL-а, ни шаманство с объединением кодовых секций и изменения
    их выравниваний на этапе линковки.
    <p>Становится немного обидно, что плагин, который делает всего
    ничего занимает место столько же, что и соседний, который
    делает черти-что, да еще и с бантиками...

<li>В ФАРе предусмотрены возможности многоязыковой поддержки, которые
  не требуют перекомпиляции плагина, для использования, которых
  достаточно все строковые константы на одном языке вынести в
  определенный файл, который положить в каталог с плагином.
  <p>Для "добывания" этих строк нужно использовать функцию АПИ ФАРа
  <pre class=code>char *<a href="../service_functions/getmsg.html">GetMsg</a>( int LanguageStringNumber );</pre>
  <p>Казалось бы ничего сложного, но использование этого метода, с тем
  подходом, который использовался при создании диалогов, порождает
  достаточно большую массу текста никак не связанного с тем, что
  делает плагин и только ухудшает читабельность и возможности
  модификаций такого текста.
  <p>Дополнительным минусом является то, что интернациональная
  поддержка нужна <u>только</u> конечному пользователю, а в процессе
  написания и редактирования диалога она только мешает, заставляя
  перелопачивать абсолютно не относящийся к логике работы плагина
  текст.
</ol>

<h2>Рассмотрим проблемы, и способы их решения по очереди.</h2>
<h3>Размер плагина.</h3>
<p class=plain>Используя статические переменные в программе, независимо от
места их описания и использования, вы неявно даете указание компилятору
и линкеру поместить их в отдельный кодовый сегмент данных,
производимого выполняемого файла.</p>

<p class=plain>Это бы ничего т.к. использование, к примеру:
<pre class=code>static char GlobalBuff[ 100000 ];</pre>
не должно, и не влияет на размер выполняемого файла, т.к. данные
создаются и существуют только в памяти, в момент загрузки
программы операционной системой.</p>

<p class=plain>Но изменив описание на такое:
<pre class=code>static char GlobalBuff[ 100000 ] = "ABC";</pre>
ваша программа увеличилась в размере на 100Кб.</p>

<p class=plain>В нашем случае наблюдается именно эта ситуация, т.к. из-за того,
что данные были явно инициализированы значениями, линкеру
приходится их реально записывать в выполняемый файл.</p>

<p class=plain>Посмотрим на размер данных, которые мы заставляем линкер
приписывать к программе, инициализируя элементы диалога.</p>

<p class=plain>Выполнить эту операцию можно по разному, начиная от
разглядывания карты связей линкера, кончая тривиальным:
<pre class=code>#include "plugin.hpp"
printf( "%d\n",sizeof(FarDialogItem) );</pre>
Т.к. точные цифры нас интересуют слабо, то поступим проще -
нажмем F4 на plugin.hpp и посмотрим на описание структуры
<a href="../dialogapi/structures/fardialogitem.html">FarDialogItem</a>.</p>

<p class=plain>В ряду с остальными элементами мы там обнаружим следующее:
<pre class=code>char Data[512];</pre>
Т.е. любой элемент диалога занимает более 500 байт данных в любом случае.</p>

<p class=plain>Легко подсчитать, что если у вас описан диалог из 20 элементов,
и плагин занимает 10К, то ровно половину этого объема занимают статические
данные массива элементов FarDialogItem, в каждом из которых
используется не более десятка букв и несколько цифр.</p>

<dl>
<dt>Вывод:</dt>
<dd>нужно уменьшить размер статических, инициализирующихся данных,
    стараясь сохранить удобство их использования и не требующих
    больших затрат на описание и манипуляцию ими в тексте
    программы.</dd>
</dl>

<h3>Многоязыковая поддержка.</h3>
<p class=plain>Задачи, которые хотелось бы уметь решать:
<ul>
  <li>иметь эту самую поддержку
  <li>не иметь с ней проблем в процессе написания и изменения
         данных, кода и самих строк, которые хочется вынести для
         возможного перевода на потусторонние языки
  <li>не проводить (или по возможности минимизировать)
         дополнительной работы, по вынесению строк в файл языковой
         поддержки ФАРа
</ul>

<p class=plain>Идеальным решением было бы такое средство, когда строки пишутся
     как обычно, без оглядки на их последующую замену, а потом, когда
     плагин окончательно готов, нажать на какую-нибудь чудо-кнопку и
     получить возможность их полного изменения.

<p class=plain>Создание такой чудо-кнопки сложностей не представляет, но это
     будет средство, которое будет во многом зависеть от того, в каких
     условиях и какими средствами плагин создается и, поэтому,
     рассмотрение его выходит за рамки этой "статьи".

<p class=plain>Рассмотрим более простое, не лишенное минусов, но могущее
     значительно облегчить описанную проблему, средство.


<h2>Реализации</h2>

<p class=plain>Вашему вниманию представляется, как было заявлено в начале
статьи, объектно-ориентированные средства для решения поставленных задач.
Эти решения не есть идеал, и ни в коей мере не указание к
немедленному применению.

<p class=plain>Эти средства не являются необходимыми для написания плагинов к
ФАРу. Это всего лишь один из способов облегчения процесса написания
плагинов.

<p class=plain>В исходных текстах, приведенных здесь, для уменьшения количества
текста и облегчения читабельности, используется несколько
макросов, которые приведены в приложении.

<h3>Многоязыковая поддержка.</h3>

<p class=plain>Те, кто заглядывал в заголовочные файлы windows, или имел
счастье писать диалоговые программы под эту операционную среду помнят такой
макрос как <code><a href="win32/makeintresource.html">MAKEINTRESOURCE</a></code>.

<p class=plain>Его можно использовать для реализации механизмов поддержки языков
в плагинах.

<p class=plain>Для этого нужно написать тройку макросов и одну функцию:

<pre class=code>#define FLANGID( v )   ((CONSTSTR)MK_DWORD(0xF5F5,v))
#define FISID( v )     (LO_WORD((DWORD)(v)) == 0xF5F5)
#define FGETID( v )    (HI_WORD((DWORD)(v)))

extern CONSTSTR FGetMsg( CONSTSTR String );</pre>

Где:
<ul>
<li><dfn>FLANGID( &lt;номер строки из файла языков&gt; )</dfn><br>
    создает строку, в которой сохраняет этот номер

<li><dfn>FISID( &lt;строка&gt; )</dfn><br>
    проверяет, является ли данная строка реальной, или она
    представляет из себя номер, собранный макросом FLANGID

<li><dfn>FGETID( &lt;строка&gt; )</dfn><br>
    получает из строки, собранной макросом FLANGID, номер элемента
    из файла языков
</ul>

<p class=plain>Для использования нам пригодится только FLANGID, остальные
используются самой процедурой FGetMsg.

<p class=plain>На том этапе, когда плагин будет готов, и вы будете заниматься
перенесением строк из текста программы в языковой файл достаточно
будет поменять, к примеру:
<pre class=code>const char *Message = "Not enouth";</pre>
на
<pre class=code>const char *Message = FLANGID( LNG_NotEnouth );</pre>

<p class=plain>Использовать этот указатель как обычную строку, не зависимо от того
чем это значение реально является - номером или строкой, позволяет
функция FGetMsg:

<pre class=code>CONSTSTR FGetMsg( CONSTSTR String ) {
  if ( FISID(String) )
   return Info.GetMsg(Info.ModuleNumber,FGETID(String));
  else
   return String;
}</pre>

<p class=plain>Для более корректной обработки возможных ошибок, можно добавить
первой строчкой в эту функцию:
<pre class=code>Assert( String );</pre>
или
<pre class=code>if ( !String ) return "";</pre>
В зависимости от того, какой реакции от функции вы хотите.
</p>


<h3>Класс оперирования диалогами.</h3>

<p class=plain>Первое что нужно сделать - это придумать небольшую, по занимаемому,
объему памяти, но достаточно функциональную замену структуры
FarDialogItem, которая будет использоваться для инициализации
элементов интерфейса.

<p class=plain>Проанализировав использующиеся у меня диалоги, и рассмотрев
необходимые поля, которые она должна содержать, я реализовал ее
так:

<pre class=code>#define FFDI_FOCUSED   0x00010000UL
#define FFDI_SELECTED  0x00020000UL
#define FFDI_DEFAULT   0x00040000UL

STRUCT( FDialogItem )
  DWORD    Type;
  int      X1;
  int      Y1;
  int      X2;
  int      Y2;
  DWORD    Flags;
  CONSTSTR Text;
};</pre>

<p class=plain>Где флаги FDI_XXX добавляются к типу объекта и заменяют
соответствующие названию поля оригинальной структуры, т.к.
во-первых, нужны они далеко не всегда, и, во-вторых, раз уж
заниматься минимизацией, то это барство - для хранения одного бита
использовать 32.

<p class=plain>Т.к. изначально, стояла задача минимального изменения кода
существующих плагинов, то реально работать мы будем продолжать со
структурой <a href="../dialogapi/structures/fardialogitem.html">FarDialogItem</a>,
а FDialogItem будет использоваться только для описания статических данных элементов.

<p class=plain>Дополнительно, с целью уменьшить количество текста вида "0,0,0,..."
можно использовать макросы для целевого описания типовых элементов
диалога.

<pre class=code>#define FDI_CONTROL( tp,x,y,x1,y1,fl,txt )    { tp,x,y,x1,y1,fl,txt }
#define FDI_LABEL( x,y,txt )                  FDI_CONTROL( DI_TEXT,x,y,0,0,0,txt )
#define FDI_COLORLABEL( x,y,clr,txt )         FDI_CONTROL( DI_TEXT,x,y,0,0,DIF_SETCOLOR|(clr),txt )
#define FDI_EDIT( x,y,x1 )                    FDI_CONTROL( DI_EDIT,x,y,x1,y,0,NULL )
#define FDI_DISABLEDEDIT( x,y,x1 )            FDI_CONTROL( DI_EDIT,x,y,x1,y,DIF_DISABLE,NULL )
#define FDI_CHECK( x,y,txt )                  FDI_CONTROL( DI_CHECKBOX,x,y,0,0,0,txt )
#define FDI_RADIO( x,y,txt )                  FDI_CONTROL( DI_RADIOBUTTON,x,y,0,0,0,txt )
#define FDI_STARTRADIO( x,y,txt )             FDI_CONTROL( DI_RADIOBUTTON,x,y,0,0,DIF_GROUP,txt )
#define FDI_BUTTON( x,y,txt )                 FDI_CONTROL( DI_BUTTON,x,y,0,0,0,txt )
#define FDI_DEFBUTTON( x,y,txt )              FDI_CONTROL( DI_BUTTON|FFDI_DEFAULT,x,y,0,0,0,txt )</pre>

<p class=plain>Их назначение:
<ul>
<li><dfn>FDI_CONTROL( Тип,x,y,x1,y1,Флаги,Текст )</dfn><br>
         описание произвольного объекта диалога
<li><dfn>FDI_LABEL( x,y,Текст )</dfn><br>
         описание метки (неактивного текста)
<li><dfn>FDI_COLORLABEL( x,y,Цвет,Текст )</dfn><br>
         описание цветной метки
<li><dfn>FDI_EDIT( x,y,x1 )</dfn><br>
         описания поля редактирования
<li><dfn>FDI_DISABLEDEDIT( x,y,x1 )</dfn><br>
         описание поля редактирования в ReadOnly режиме
<li><dfn>FDI_CHECK( x,y,Текст )</dfn><br>
         описание переключателя
<li><dfn>FDI_RADIO( x,y,Текст )</dfn><br>
         описание элемента выбора
<li><dfn>FDI_STARTRADIO( x,y,Текст )</dfn><br>
         описание первого элемента выбора
<li><dfn>FDI_BUTTON( x,y,Текст )</dfn><br>
         описание кнопки
<li><dfn>FDI_DEFBUTTON( x,y,Текст )</dfn><br>
         описание кнопки по умолчанию
</ul>

<p class=plain>Пример использования описания диалога, используя эту структуру
хранения:

<pre class=code>bool DoConfigure( void )
{
  static FDialogItem itm[] = {
      FDI_CONTROL( DI_SINGLEBOX, 0, 0,70,14,  0, "Caption" ),
    FDI_DEFBUTTON( 58,13, "  O&amp;K  " ),
        FDI_LABEL(  2, 1, "&amp;Options" ),
        FDI_CHECK(  3, 2, "Show hidden files" ),
        FDI_LABEL( 10, 5, "Tree &amp;width" ),
         FDI_EDIT(  5, 5, 8 ),
        FDI_LABEL( 38, 1, "&amp;Action functional keys" ),
       FDI_BUTTON( 39, 2, "&amp;Normal" ),
       FDI_BUTTON( 39, 3, "&amp;Control" ),
       FDI_BUTTON( 39, 4, "A&amp;lt" ),
     };
    ...
}</pre>

<p class=plain>Очень похоже на оригинал за тем исключением, что немного более
   читабельно, не так ли ?

<p class=plain>Вторая задача, которую нужно решить это реализация некоего
   интерфейса, который бы позволил хранить массивы структур
   FarDialogItem, используя для их инициализации данные из
   FDialogItem.

<p class=plain>ФАР требует, чтобы элементы которые будут переданы в
   <a href="../dialogapi/dialog.html">Dialog</a> были расположены в
   непрерывном массиве.

<p class=plain>Т.к. нас интересует результат, то не стоит противоречить этому
   требованию.

<p class=plain>Для реализации этой организации можно использовать разные методы,
   от глупостей типа:

<pre class=code>static FarDialogItem *LastItems = NULL;
FarDialogItem *AllocFarDialogItems( int Count );</pre>
   до реализаций массивов из STL.

<p class=plain>Первого я боюсь, а второе ненавижу, поэтому остановимся на среднем
   варианте.

<p class=plain>Для реализации массива используем шаблон с нужной нам
   функциональностью:

<pre class=code>template &lt;class T&gt; class RefArray {
  T   *items;
  int  count;
 public:
  MyRefArray( int Count ) { items = new T[ count = Count ]; memset(items,0,sizeof(T)*count); }
  virtual ~MyRefArray()   { delete[] items; }

  T     *Item( int num )       const { return (T*)((num &gt;= 0 &amp;&amp; num &lt; count)?(items + num):NULL); }
  T     *operator[]( int num ) const { return Item(num); }
  int    Count( void )         const { return count; }
  T     *Items( void )         const { return (T*)items; }
};</pre>

<p class=plain>И организуем работу с нашими данными, используя этот шаблон:

<pre class=code>class FDialog : public RefArray&lt;FarDialogItem&gt; {
  public:
    FDialog( int NumElemens );
    FDialog( int NumElemens,PFDialogItem Elements,int FNumElements = -1 );

    PFarDialogItem Setup( int num,const FDialogItem&amp; p );
    void           Setup( int From,PFDialogItem p,int count );

    int            Execute( int w,int h,CONSTSTR Help = NULL );
};</pre>

<p>который умеет следующее:
<ul>
<li><dfn>FDialog( int NumElemens )</dfn><br>
      создает массив из NumElemens пустых элементов
<li><dfn>FDialog( int NumElemens,PFDialogItem Elements,int FNumElements = -1 )</dfn><br>
      создает массив из NumElemens пустых элементов, в первые
      FNumElements или NumElemens которых записывает данные из массива
      структур FDialogItem
<li><dfn>PFarDialogItem Setup( int num,const FDialogItem&amp; p );</dfn><br>
      Записывает в элемент массива num данные из структуры DialogItem
<li><dfn>Setup( int From,PFDialogItem p,int count );</dfn><br>
      Записывает все элементы количеством count в элементы массива
      начиная c From
<li><dfn>Execute( int w,int h,CONSTSTR Help = NULL );</dfn><br>
      выполняте центрированный диалог с заданными размерами и
      возвращает результат выполнения
</ul>

<p class=plain>Реализация методов описана ниже.
  Обратите внимание на то, что в функции FDialog::Setup используется
<pre class=code>StrCpy( p-&gt;Data,FGetMsg(it.Text),sizeof(p-&gt;Data) );</pre>
  т.е. строка, которую задали в структуре FDialogItem может быть как
  реальной константной строкой, так и результатом использования
  макроса FLANGID.
  Таким образом, чтобы сделать диалог с поддержкой языков средствами
  ФАР нужно всего лишь изменить явное использование строки на макрос
  FLANGID с той константой, которую вы будете использовать для этой
  строки.

<pre class=code>FDialog::FDialog( int NumElemens )
  : RefArray&lt;FarDialogItem&gt;(NumElemens)
{}
FDialog::FDialog( int NumElemens,PFDialogItem Elements,int FNumElements )
  : MyRefArray&lt;FarDialogItem&gt;( NumElements )
 {
   Setup( 0,Elements,(FNumElements==-1)?NumElements:FNumElements );
}
void FDialog::Setup( int From,PFDialogItem p,int ECount )
  {
    for ( int n = 0; n &lt; ECount; n++ )
      Setup( From+n,p[n] );
}
PFarDialogItem FDialog::Setup( int num,const FDialogItem&amp; it )
  {  PFarDialogItem p = Item(num);
     if ( !p ) return NULL;
       p-&gt;Type           = (int)(it.Type &amp; 0xFFFF);
       p-&gt;X1             = it.X1;
       p-&gt;Y1             = it.Y1;
       p-&gt;X2             = it.X2;
       p-&gt;Y2             = it.Y2;
       p-&gt;Focus          = IS_FLAG(it.Type,FFDI_FOCUSED);
       p-&gt;Selected       = IS_FLAG(it.Type,FFDI_SELECTED);
       p-&gt;Flags          = it.Flags;
       p-&gt;DefaultButton  = IS_FLAG(it.Type,FFDI_DEFAULT);
       strcpy( p-&gt;Data,FGetMsg(it.Text),sizeof(p-&gt;Data) );
 return p;
}
int FDialog::Execute( int w,int h,CONSTSTR Help )
  {
 return Info.Dialog( Info.ModuleNumber,-1,-1,w,h,
                     (char*)Help,
                     (PFarDialogItem)Items(),
                     Count() );
}</pre>


<h2>Примеры использования</h2>

<p class=plain>Рассмотрим функцию, которая запрашивает у показывает пользователю
набор всех функциональных клавиш и позволяет отметить некоторые из
них.

<p class=plain>Выглядит на экране ФАРа это так:
<p><img src="../../images/a_static.gif" width=509 height=72>

<p class=plain>Эту функцию можно использовать, к примеру, в панельном плагине, для
задания маски переопределяемых плагином функциональных клавиш.
В качестве параметров эта функция принимает текстовое сообщение,
которое будет отображаться в заголовке диалога, маску текущих
выбранных и маску недоступных для выбора функциональных клавиш.

<p class=plain>Обратите внимание на то, что в статических данных находится только
один элемент - рамка диалога, остальные формируются во время
выполнения при первом вызове этой функции используя знание о том,
что все "пустые" элементы диалога будут установлены как элементы с
типом 0.

<pre class=code>bool GetKeyMaskDialog( CONSTSTR KeyName,DWORD&amp; Mask,DWORD Hide )
  {  static FDialogItem itm = FDI_CONTROL( DI_DOUBLEBOX,0,0,50,3,0,NULL );
     static FDialog     dlg( FK_MAX*2+1,&amp;itm,1 );

     int                n;
     PFarDialogItem     it;
     DWORD              dw;

#define IT_CAPTION  0
#define IT_FN       1

//Create FKey labels
     if ( dlg[IT_FN]-&gt;Type != DI_RADIOBUTTON )
       for ( n = 0; n &lt; FK_MAX; n++ ) {
        //Labels
         it = dlg[ IT_FN + n*2 ];
         it-&gt;Type  = DI_TEXT;
         it-&gt;X1    = 2 + n*4;
         it-&gt;X2    = 2 + n*4 + 4;
         it-&gt;Y1    = it-&gt;Y2 = 2;
         if ( n &lt; 9 )
           sprintf( it-&gt;Data,"F&amp;%d",n+1 );
          else
           sprintf( it-&gt;Data,"F%d",n+1 );
        //Radio
         it = dlg[ IT_FN + n*2 + 1 ];
         it-&gt;Type  = DI_CHECKBOX;
         it-&gt;X1    = 2 + n*4;
         it-&gt;X2    = 2 + n*4 + 4;
         it-&gt;Y1    = it-&gt;Y2 = 1;
       }
//Setup
     strcpy( dlg[IT_CAPTION]-&gt;Data,FGetMsg(KeyName) );
     for ( n = 0; n &lt; FK_MAX; n++ ) {
       it = dlg[IT_FN + n*2 ];
         it-&gt;Flags    = IS_FLAG(Hide,1UL&lt;&lt;n)?DIF_DISABLE:0;
       it = dlg[IT_FN + n*2+1 ];
         it-&gt;Selected = IS_FLAG(Mask,1UL&lt;&lt;n);
         it-&gt;Flags    = IS_FLAG(Hide,1UL&lt;&lt;n)?DIF_DISABLE:0;
     }
//Dialog
     n = dlg.Execute( 50,3,NULL );
     if ( n == -1 ) return false;
//Grab data
     dw = 0;
     for ( n = 0; n &lt; FK_MAX; n++ )
       if ( dlg[IT_FN + n*2+1 ]-&gt;Selected ) SET_FLAG( dw,1UL&lt;&lt;n );

     if ( dw != Mask ) {
       Mask = dw;
       return true;
     } else
       return false;
}</pre>

<h2>Приложения</h2>
<p class=plain>Здесь приведены реализации макросов, которые используются с
приведенных исходных текстах, для сокращения записи.

<pre class=code>#define MAX_WORD                  ((WORD)0xFFFFU)
#define MK_WORD( lb,hb )          ((WORD)(((((WORD)(hb))&amp;0x00FFU) &lt;&lt; 8) |(((BYTE)(lb))&amp;0x00FFU)))
#define MK_DWORD( lw,hw )         (((((DWORD)hw)&amp;0x0000FFFFUL) &lt;&lt; 16) |(((WORD)lw)&amp;0x0000FFFFUL))
#define MK_ID( v,v1,v2,v3 )       MK_DWORD( MK_WORD(v,v1),MK_WORD(v2,v3) )
#define PRESTRUCT( cl )           typedef struct cl *P##cl; struct cl
#define PRECLASS( cl )            typedef class cl *P##cl; class cl
#define STRUCT( name )            PRESTRUCT(name) {
#define CLASS( name )             PRECLASS(name) {
#define IS_FLAG( val,flag )       (((val)&amp;(flag))==(flag))
#define SET_FLAG( val,flag )      (val |= (flag))
#define CLR_FLAG( val,flag )      (val &amp;= ~(flag))
#ifndef bool
  #define bool BOOL
  #define true TRUE
  #define false FALSE
#endif
typedef const char *CONSTSTR;</pre>


<div align=right><code>
<br>&nbsp;<br>
21.02.2001
</code></div>

<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>