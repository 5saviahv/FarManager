<html>
<head>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<title>Работа с &quot;временной панелью&quot; в своем плагине</title>
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:spinoza@mail.ru">
<meta name="Author" content="Ivan Sintyurin">
<meta name="description" content="Работа с временной панелью в своем плагине">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<body>

<a name="top"></a>
<h1>Работа с &quot;временной панелью&quot; в своем плагине</h1>

<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
Иван Синтюрин <a href="mailto:Ivan%20Sintyurin%20<spinoza@mail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[spinoza@mail.ru]" width="16" height="16" align="middle">spinoza@mail.ru</a>
<br><a href="http://www.moris.ru/~spinoza">http://www.moris.ru/~spinoza</a>
</code></div>
<hr color="#003399">

  <p class=plain>Причиной написания данной статьи послужил, как мне
  кажется, наиболее <dfn>эффективный</dfn> на текущий день способ
  решения проблемы добавления собственным плагином &quot;<a
  href="http://www.moris.ru/~spinoza/download/index.html">Поиск и Замена
  (S&amp;R)</a>&quot; файлов на стандартную &quot;временную панель&quot;
  FAR, которым я и хочу поделиться с вами.</p>

<p class=note><img src="../../images/note.gif" alt="Немного истории" width="10" height="10"> Немного истории
<em>(можно абзац пропустить и не читать, тут выстраданное мною, поэтому не могу не написать :-)</em>.</p>
<UL class=note><LI>
<p>С временной
  панелью S&amp;R научился работать пять лет назад (в 2001 г.),
  функционально решение было оформлено достаточно &quot;топорно&quot; - в
  виде написания своей собственной &quot;временной панели&quot;. Почему я
  называю это &quot;топорным&quot; - фактически все сведено к
  copy-and-paste исходного кода стандартной &quot;временной панели&quot;,
  т.е. один и тот же одинаково работающий код загружается в память дважды.
  Да что там &quot;одинаково работающий&quot;... Со временем приходится
  периодически тратить время на синхронизацию своего кода с кодом
  стандартного плагина, чтобы не путать пользователя фактом существования
  двух &quot;временных панелей&quot; (если код синхронизировать, то
  пользователь как бы не замечает, что панелей две). В конце концов мне это
  надоело я с решил научить плагин помещать файлы на стандартную
  &quot;временную панель&quot;, дабы не плодить сущности. Первое, что
  пришло мне в голову - делать LoadLibrary(стандартный плагин), а потом
  дергать его функции. Казалось бы, простое решение моментально обнаружило
  ряд трудностей: мне в своем плагине пришлось бы эмулировать ряд сервисных
  функций FAR (<a href="../service_functions/getmsg.html">GetMsg</a>,
  <a href="../service_functions/message.html">Message</a>,
  <a href="../dialogapi/dialog.html">Dialog</a>,
  <a href="../service_functions/menu.html">Menu</a>), потому что они требуют в
  качестве параметра ModuleNumber, который в общем случае мне не известен.
  Таким образом, избавившись от одного дублирования кода, я автоматически
  получал другое, еще более сложное в реализации. Кроме того, из-за того,
  что стандартный плагин &quot;временная панель&quot; загружается FAR'ом в
  память по мере необходимости, а не тогда, когда нужно моему плагину, мы
  получали потенциальный глюкодром - в какой-то момент времени функции
  инициализации/деинициализации стандартной &quot;временной панели&quot;
  (<a href="../exported_functions/setstartupinfo.html">SetStartupInfo</a>,
  <a href="../exported_functions/exitfar.html">ExitFAR</a>) могли быть вызваны дважды - моим плагином и
  FAR'ом, причем в заранее неизвестном порядке. В подобной ситуации в
  лучшем случае происходило бы &quot;падение&quot; FAR'а или того или иного
  плагина (проверять я не стал :-). В связи с изложенным, мне пришло в
  голову решение, излагаемое в следующем абзаце. Причем оно такое простое,
  что даже обидно, что я не догадался об этом пять лет назад.
</LI></UL>

  <p class=plain>Итак, не нужно загружать при помощи <a href="win32/loadlibrary.html">LoadLibrary</a>
  стандартный плагин tmppanel.dll в память самому из своего плагина, нужно
  попросить сделать это FAR, тогда точно будет известно, что к моменту
  необходимости работы с &quot;временной панелью&quot; из своего плагина,
  она будет уже загружена в память и нужным образом проинициализирована.
  Для этого нужно, чтобы в tmppanel.dll выставлялся флаг <a href="../structures/plugininfo.html#PF_PRELOAD">PF_PRELOAD</a>. В
  tmppanel.dll версии 1.70 build 27 (входит в релиз FAR 1.70) этот флаг не
  выставляется, поэтому я произвел все необходимые изменения в стандартном
  плагине и его версия 1.71 build 28 (ищите на <a
  href="http://www.farmanager.com/updates.php">официальном сайте</a>) делает все,
  что нам нужно.</p>

  <p class=plain>Вместо LoadLibrary мы получаем указатель на загруженную
  &quot;временную панель&quot; при помощи GetModuleHandle:</p>

<pre class=code>
HMODULE hPluginDll=GetModuleHandle(&quot;TmpPanel.dll&quot;);
</pre>

  <p class=plain>Соответственно, выгружать нам потом тоже ничего вручную не
  нужно.</p>

  <p class=plain>Модуль tmppanel.dll экспортирует следующие функции:
  <dfn><a href="../exported_functions/closeplugin.html">ClosePlugin</a>,
  <a href="../exported_functions/configure.html">Configure</a>,
  <a href="../exported_functions/exitfar.html">ExitFAR</a>,
  <a href="../exported_functions/getfinddata.html">GetFindData</a>,
  <a href="../exported_functions/getminfarversion.html">GetMinFarVersion</a>,
  <a href="../exported_functions/getopenplugininfo.html">GetOpenPluginInfo</a>,
  <a href="../exported_functions/getplugininfo.html">GetPluginInfo</a>,
  <a href="../exported_functions/openfileplugin.html">OpenFilePlugin</a>,
  <a href="../exported_functions/openplugin.html">OpenPlugin</a>,
  <a href="../exported_functions/processevent.html">ProcessEvent</a>,
  <a href="../exported_functions/processkey.html">ProcessKey</a>,
  <a href="../exported_functions/putfiles.html">PutFiles</a>,
  <a href="../exported_functions/setdirectory.html">SetDirectory</a>,
  <a href="../exported_functions/setfindlist.html">SetFindList</a>,
  <a href="../exported_functions/setstartupinfo.html">SetStartupInfo</a>
  </dfn>.</p>

  <p class=plain>Нам потребуется задействовать все из них, за исключением
  <dfn>SetStartupInfo, ExitFAR, GetPluginInfo, GetMinFarVersion, Configure,
  OpenFilePlugin</dfn>, т.к. они представляют интерес только для самого FAR'а.
  Для получения адресов указанных функций используется <a href="win32/getprocaddress.html">GetProcAddress</a>. У
  меня это выглядит приблизительно вот так:</p>

<pre class=code>
typedef HANDLE (WINAPI *PLUGINOPENPLUGIN)(int OpenFrom,int Item);
typedef void (WINAPI *PLUGINCLOSEPLUGIN)(HANDLE hPlugin);
typedef void (WINAPI *PLUGINGETOPENPLUGININFO)(HANDLE hPlugin,
                                               struct OpenPluginInfo *Info);
typedef int (WINAPI *PLUGINPUTFILES)(HANDLE hPlugin,struct PluginPanelItem *PanelItem,
                                     int ItemsNumber,int Move,int OpMode);
typedef int (WINAPI *PLUGINGETFINDDATA)(HANDLE hPlugin,
                                        struct PluginPanelItem **pPanelItem,
                                        int *pItemsNumber,int OpMode);
typedef int (WINAPI *PLUGINSETDIRECTORY)(HANDLE hPlugin,const char *Dir,int OpMode);
typedef int (WINAPI *PLUGINSETFINDLIST)(HANDLE hPlugin,
                                        const struct PluginPanelItem *PanelItem,
                                        int ItemsNumber);
typedef int (WINAPI *PLUGINPROCESSKEY)(HANDLE hPlugin,int Key,
                                       unsigned int ControlState);
typedef int (WINAPI *PLUGINPROCESSEVENT)(HANDLE hPlugin,int Event,void *Param);

struct TEMPPANEL
{
  PLUGINOPENPLUGIN        OpenPlugin;
  PLUGINCLOSEPLUGIN       ClosePlugin;
  PLUGINSETFINDLIST       SetFindList;
  PLUGINPROCESSKEY        ProcessKey;
  PLUGINPROCESSEVENT      ProcessEvent;
  PLUGINGETOPENPLUGININFO GetOpenPluginInfo;
  PLUGINGETFINDDATA       GetFindData;
  PLUGINSETDIRECTORY      SetDirectory;
  PLUGINPUTFILES          PutFiles;
  BOOL Init(HMODULE hDll)
  {
    OpenPlugin=NULL;
    ClosePlugin=NULL;
    SetFindList=NULL;
    ProcessKey=NULL;
    ProcessEvent=NULL;
    GetOpenPluginInfo=NULL;
    GetFindData=NULL;
    SetDirectory=NULL;
    PutFiles=NULL;
    if(hDll)
    {
      OpenPlugin=reinterpret_cast<PLUGINOPENPLUGIN>(GetProcAddress(hDll,"OpenPlugin"));
      ClosePlugin=reinterpret_cast<PLUGINCLOSEPLUGIN>(GetProcAddress(hDll,"ClosePlugin"));
      SetFindList=reinterpret_cast<PLUGINSETFINDLIST>(GetProcAddress(hDll,"SetFindList"));
      ProcessKey=reinterpret_cast<PLUGINPROCESSKEY>(GetProcAddress(hDll,"ProcessKey"));
      ProcessEvent=reinterpret_cast<PLUGINPROCESSEVENT>(GetProcAddress(hDll, "ProcessEvent"));
      GetOpenPluginInfo=reinterpret_cast<PLUGINGETOPENPLUGININFO>(GetProcAddress(hDll, "GetOpenPluginInfo"));
      GetFindData=reinterpret_cast<PLUGINGETFINDDATA>(GetProcAddress(hDll, "GetFindData"));
      SetDirectory=reinterpret_cast<PLUGINSETDIRECTORY>(GetProcAddress(hDll, "SetDirectory"));
      PutFiles=reinterpret_cast<PLUGINPUTFILES>(GetProcAddress(hDll, "PutFiles"));
    }
    return OpenPlugin && ClosePlugin && SetFindList && ProcessKey && ProcessEvent &&
           GetOpenPluginInfo && GetFindData && SetDirectory && PutFiles;
  }
};
...
HMODULE hPluginDll=GetModuleHandle(&quot;TmpPanel.dll&quot;);
// тут код проверки hPluginDll, на случай, если вызов GetModuleHandle
// окончился неудачей, вывод соответствующих сообщений и т.п.
TEMPPANEL TmpPanel;
if(TmpPanel.Init(hPluginDll))
{
  // если инициализация указателей на функции успешная
}
else
{
  // ...если облом
}
</pre>

  <p class=plain>Чтобы добавить наши файлы на &quot;временную панель&quot;
  нужно получить указатель на эту самую панель при помощи
  <dfn>TmpPanel.OpenPlugin</dfn>, затем вызвать
  <dfn>TmpPanel.SetFindList</dfn> и, наконец, вернуть FAR'у указатель на
  созданную временную панель. Схематично выглядеть это будет вот так:</p>

<pre class=code>
HANDLE WINAPI _export OpenPlugin(int OpenFrom, int Item)
{
  HANDLE retCode=INVALID_HANDLE_VALUE;
  ...
  PluginPanelItem *ppi=NULL; // тут будет перечень файлов, которые
                             // надо поместить на временную панель
  DWORD ppi_total=0;         // количество этих файлов
  ...
  if(ppi_total)
  {
    // TmpPanel мы инициализировали где-то раньше!
    HANDLE hTmp=TmpPanel.OpenPlugin(OPEN_FINDLIST,0);
    if(INVALID_HANDLE_VALUE!=hTmp)
    {
      // временная панель успешно создана,
      // теперь добавим в нее файлы
      if(!TmpPanel.SetFindList(hTmp, ppi, ppi_total))
      {
        // не удалось поместить файлы на панель,
        // закроем ее
        TmpPanel.ClosePlugin(hTmp);
        hTmp=INVALID_HANDLE_VALUE;
      }
      retCode=hTmp;
    }
    else
    {
      // создать временную панель не удалось
    }
  }
  ...
  return retCode;
}
</pre>

  <p class=plain> Ну, и наконец, следует экспортировать все прочие функции,
  которые которые мы цепляем из tmppanel.dll (кроме SetFindList - зачем
  плодить сущности?!), в противном случае, пользователь не сможет
  полноценно работать с &quot;временной панелью&quot;, открытой путем
  вызова нашего плагина. Код экспортируемых функций простейший: </p>

<pre class=code>
void WINAPI ClosePlugin(HANDLE hPlugin)
{
  TmpPanel.ClosePlugin(hPlugin);
}

void WINAPI GetOpenPluginInfo(HANDLE hPlugin, struct OpenPluginInfo *Info)
{
  TmpPanel.GetOpenPluginInfo(hPlugin, Info);
}

int WINAPI GetFindData(HANDLE hPlugin, struct PluginPanelItem **pPanelItem,
                       int *pItemsNumber, int OpMode)
{
  return TmpPanel.GetFindData(hPlugin, pPanelItem, pItemsNumber, OpMode);
}

int WINAPI SetDirectory(HANDLE hPlugin,const char *Dir,int OpMode)
{
  return TmpPanel.SetDirectory(hPlugin, Dir, OpMode);
}

int WINAPI PutFiles(HANDLE hPlugin, struct PluginPanelItem *PanelItem,
                    int ItemsNumber,int Move, int OpMode)
{
  return TmpPanel.PutFiles(hPlugin, PanelItem, ItemsNumber, Move, OpMode);
}

int WINAPI ProcessEvent(HANDLE hPlugin, int Event, void *Param)
{
  return TmpPanel.ProcessEvent(hPlugin, Event, Param);
}

int WINAPI ProcessKey(HANDLE hPlugin, int Key, unsigned int ControlState)
{
  return TmpPanel.ProcessKey(hPlugin, Key, ControlState);
}
</pre>

<br><br>

  <p class=plain>Это все, буду рад, если указанная статья поможет кому-то
  при написании собственного плагина.</p>

<div align=right><code>
<br>&nbsp;<br>
15.04.2006<br>
</code></div>

  <p class=plain>P.S. На момент написания данной статьи соответствующая версия
  S&amp;R публично не доступна, т.к. находится все еще в стадии разработки.
  Следите за рекламой! :-) </p>

<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>
