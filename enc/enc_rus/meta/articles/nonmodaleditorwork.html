<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Несколько приемов работы с окнами FAR.</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:corwinnt@yahoo.com">
<meta name="Author" content="Alexander Nazarenko">
<meta name="description" content="Несколько приемов работы с окнами FAR...">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<!-- History of modification:
 Date: Jan 13 2002
   Author: Alexander Nazarenko
   E-mail: corwinnt@yahoo.com
-->
<body>

<a name="top"></a>
<h1>Несколько приемов работы с окнами FAR.</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>

<div align=right><code>
Александр Назаренко <a href="mailto:Alexander%20Nazarenko%20<corwinnt@yahoo.com>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[corwinnt@yahoo.com]" width="16" height="16" align="middle">corwinnt@yahoo.com
</a></code></div>
<hr color="#003399">

<p class=plain>
О написании плагинов к редактору написано много, но большинство примеров
подобных плагинов работает только с одним окном редактора. А как быть, если
нужно переключаться между несколькими открытыми редакторами? Как сохранить все
измененные файлы например? Или как перейти на известную позицию в уже открытом
на редактирование файле? Поскольку я, похоже, первый наступил на эти
<em>&laquo;грабли&raquo;</em>, то мне и приводить рецепты.

<h3>FAR Manager до 1.70 beta 3 (включительно)</h3>

<p class=plain>К сожалению здесь нормально реализовать работу с несколькими
окнами редактора не получится потому, что стандартному API не хватает
функциональности, а именно <b>нормального способа переключится в нужное
окно</b>. Единственный &quot;нормальный&quot; путь - вызов функции
<b>Info.<a href="../service_functions/editor.html">Editor</a>(...,EF_NONMODAL,...);</b>.
При этом, если файл уже открыт в редакторе, FAR &laquo;переспрашивает&raquo; у
пользователя, хочет ли он использовать уже открытый файл, перегрузить его или
отказаться от открытия файла. При использовании плагина, обеспечивающего
переход в нужное место исходного текста на основании анализа листинга
компилятора, при таком подходе нетрудно предугадать реакцию пользователя.
Выхода здесь два: </p>

<div class=descr>
  <p>Первое - просить FAR Group переписать API с поддержкой дополнительных
  флагов типа <b>Info.<a href="../service_functions/editor.html">Editor</a>(...,EF_USEEXISTING,...);</b>,
  которые подавляли бы это предупреждение.<br>
  Второе - использовать модальный редактор и таким образом просто
  запретить переключение между окнами.</p>
</div>

<h3>FAR Manager 1.70 beta 4 (и выше)</h3>

<p class=plain>
Но не о том здесь речь. Третье решение - использовать оконное API от
&laquo;четверки&raquo; с ее расширенным набором функций ACTL_*. Покажу это
на примере реализации сохранения всех файлов, открытых на редактирование, и
перехода на известную позицию в <b>возможно</b> уже открытом на редактирование
файле.</p>

<p class=plain>
В примере, приведенном ниже, показано как реализовать отсутствующую в
стандартном API функцию
<b>Info.<a href="../service_functions/editorcontrol.html">EditorControl</a>(ECTL_SAVEALL,&amp;rec)</b>.</p>

<pre class=code>void EditorSaveAll(void)
{
  struct WindowInfo wi;
  // <em>получим информацию о окне текущего файла</em>
  wi.Pos = -1;
  Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_GETWINDOWINFO, (void*)&amp;wi);
  int home = wi.Pos;
  int n = Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_GETWINDOWCOUNT, NULL);
  for ( int i = 0 ; i &lt; n ; i++ )
  {
    wi.Pos = i;
    Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_GETWINDOWINFO, (void*)&amp;wi);
    if ( ( wi.Type == WTYPE_EDITOR ) &amp;&amp; wi.Modified )
    {
      // <em>сохраним каждый измененный файл</em>
      Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_SETCURRENTWINDOW, (void*)i);
      Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_COMMIT, NULL);
      Info.<a href="../service_functions/editorcontrol.html">EditorControl</a>(ECTL_SAVEFILE, NULL);
    }
  }
  // <em>восстановим сохраненное окно редактора</em>
  Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_SETCURRENTWINDOW, (void*)home);
  Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_COMMIT, NULL);
}</pre>

<p class=plain>
Все достаточно просто, но эта простота обманчива:
<blockquote>
Во первых, при написании этого куска кода я достаточно долго искал причину
того, что приведенный кусок не работал. Сохранялся только текущий файл.
Причина оказалась в том, что я не использовал
<b>Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_COMMIT, NULL)</b> и фактического
переключения в нужное окно не происходило.

<p>Во вторых, вместо использования <b>wi.Pos = -1</b> я сначала получал имя
текущего редактируемого файла через
<b>Info.<a href="../service_functions/editorcontrol.html">EditorControl</a>(ECTL_GETINFO,&amp;ei);</b>
и проверял его совпадение с <b>wi.Name</b> в цикле перебора окон FAR.<br>
Надеюсь, что на эти <em>&laquo;грабли&raquo;</em> теперь уже никто не наступит.</p>
</blockquote>

<p class=plain>
Теперь о переходе на <em>&laquo;нужный&raquo;</em> редактор. То есть реализуем
отсутствующую в стандартном API функцию
<b>Info.<a href="../service_functions/editor.html">Editor</a>(...,EF_NONMODAL|EF_USEEXISTING,...)</b>.</p>

<p class=plain>
Исходные данные, которые мы имеем, это <b>полное</b> имя нужного файла, строка и
столбец в нем. Здесь тоже есть тонкие моменты. Нужно отследить два момента.<br>
Во первых, нужно проверить, нужно ли вообще куда-то переходить. То есть, не
редактируем ли мы этот файл в данный момент.<br>
Во вторых, нужно проверить, открыт ли этот файл на редактирование вообще или
нужно открывать новое окно редактора.</p>

<pre class=code>// <em>переход на нужную позицию в текущем редакторе</em>
<a name="EditorSetPos"></a>
void EditorSetPos(int line, int col, int topline = -1, int leftcol = -1)
{
  EditorSetPosition sp;
  sp.CurLine = line;
  sp.CurPos = col;
  sp.TopScreenLine = topline;
  sp.LeftPos = leftcol;
  sp.CurTabPos = sp.Overtype = -1;
  Info.<a href="../service_functions/editorcontrol.html">EditorControl</a>(ECTL_SETPOSITION, &amp;sp);
}

bool OpenEditor(const char *FileName, int line, int col)
{
  if ( ( FileName != NULL) &amp;&amp; ( *FileName != 0 ) )
  {
    struct WindowInfo wi;
    // <em>получим информацию о имени текущего файла</em>
    wi.Pos = -1;
    Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_GETWINDOWINFO, (void*)&amp;wi);
    if ( !FSF.LStricmp(wi.Name, FileName) )
      <a href="#EditorSetPos">EditorSetPos</a>(line, col);
    else
    {
      // <em>ищем нужный файл среди открытых</em>
      int n = Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_GETWINDOWCOUNT, NULL);
      for ( int i = 0 ; i &lt; n ; i++ )
      {
        wi.Pos = i;
        Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_GETWINDOWINFO, (void*)&amp;wi);
        if ( ( wi.Type == WTYPE_EDITOR ) &amp;&amp; ( !FSF.LStricmp(wi.Name, FileName) ) )
        {
          Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_SETCURRENTWINDOW, (void*)i);
          Info.<a href="../service_functions/advcontrol.html">AdvControl</a>(Info.ModuleNumber, ACTL_COMMIT, NULL);
          <a href="#EditorSetPos">EditorSetPos</a>(line, col);
          return true;
        }
      }
      // <em>ничего не поделаешь, придется открывать</em>
      Info.<a href="../service_functions/editor.html">Editor</a>(FileName, NULL, 0, 0, -1, -1, EF_NONMODAL, line, col);
      return true;
    }
  }
  return false;
}</pre>

<p class=plain>
Возможно это многим покажется очевидным, но лично к этому коду я пришел далеко
не сразу :)<br>
</p>

<div align=right><code>
<br>&nbsp;<br>
13.01.2002<br>
</code></div>
<div class=seecont><a href="#top">наверх</a></div>

</body>
</html>
