<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Локализация плагинов второго уровня</title>
<meta http-equiv="Content-Type" Content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../styles/styles.css">
<link REV="made" href="mailto:spinoza@mail.ru">
<meta name="Author" content="Ivan Sintyurin">
<meta name="description" content="Локализация плагинов второго уровня">
<script language="JavaScript" src='../links.js' type="text/javascript"></script>
</head>
<body>

<a name="top"></a>
<h1>Локализация плагинов второго уровня</h1>
<div class=navbar>
<a href="../index.html">главная</a> |
<a href="index.html">статьи</a>
</div>


<div align=right><code>
<code>Иван Синтюрин <a href="mailto:Ivan%20Sintyurin%20<spinoza@mail.ru>?subject=Articles">
<img src="../../images/email.gif" border="0" alt="[spinoza@mail.ru]" width="16" height="16" align="middle">spinoza@mail.ru
</a></code></div>
<hr color="#003399">


<p class=plain>Одним из самых очевидных достоинств FAR'a является возможность его локализации. <a name="Локализация">Локализация</a> означает то, что сообщения и справка показываются на понятном для пользователя языке, и никто не запрещает ему перевести эти сообщения на любой другой язык (чем я иногда и занимался раньше). Такие же возможности предоставлены подключаемым к FAR'у внешним модулям - т.н. &laquo;плагинам&raquo;. [Почти] все сообщения и вся [полностью] помощь размещаются соответственно в LNG и HLF-файлах, которые можно перевести на нужный язык (было б желание).</p>
<p class=plain>Урезаны в своих правах лишь плагины для плагинов, т.н. &laquo;плагины второго уровня&raquo;, &laquo;подплагины&raquo;, "субплагины". Плагинов, поддерживающих субплагины, правда, мало, но кто знает, что будет завтра? В чём проблема? В том, что <dfn>FAR не подерживает обработку нескольких файлов типа LNG или HLF на одном языке в одном каталоге</dfn>, каждому языку соответствует только пара файлов - LNG и HLF. Одно дело плагин второго уровня для multiarc'а, ему никаких сообщений выводить не нужно, другое дело плагины типа AddressBook (by Pavel Kostromitinov, рекомендую), для их субплагинов необходима возможность локализации. Как последнюю предусмотреть?</p>
<center><h3>ЧАСТЬ ПЕРВАЯ. ЛОКАЛИЗАЦИЯ СООБЩЕНИЙ</h3></center>
<p class=plain>Локализация бывает 3-х видов:
<ol>
<li>&quot;Отсутствующая&quot; - все сообщения прошиты в теле плагина. Вариант, который нас не устраивает.
<li>Локализация конкретного плагина второго уровня - недостаток - пара подплагинов локализована, остальные на ... языке, хорошо ещё, если на английском [в конце концов, для него и словарь можно найти], а если на суахили?
<li>Глобальная локализация - автор плагина предусмотрел локализацию всех плагинов второго уровня.
</ol></p>
<p class=plain>Для локализации 2 и 3 вида можно использовать запись строковых сообщений в реестр [но <dfn>я не люблю, когда всякая ерунда пишется в реестр, да и править
эту информацию не так удобно</dfn>] или в файл, а оттуда их считывать, когда потребуется.</p>
<p class=plain> Посидел я минут 10 и написал свою функцию, которая возвращает указатель на запрашиваемую строку в соответствии с настройками FAR'а. Она находится в файле <em>LocMsg.cpp</em> (см. ниже), посмотрите - всё просто, &laquo;как два пальца об ...&raquo;. Для 2 вида локализации Вы можете включать данный файл в свою программы директивой препроцессора <em>include</em>, например, так:</p>
<pre class=code>#include "LocMsg.cpp"</pre>
<p class=plain>Для возможности глобальной локализации автор основного плагина должен предоставить субплагину указатель на данную функцию, т.е. включать данный код в субплагин уже не нужно. Вот содержимое моего файла <em>LocMsg.cpp</em>:</p>
<pre class=code>/*
LocMsg - Скажем локализации: &laquo;ДА!&raquo;
Author - Ivan Sintyurin. Copyright (c) 2000. All Rights Reserved.

  Я буду рад, если данная функция поможет Вам писать программы  с
возможностью локализации. Прошу Вас только об одном -  указывайте
мой copyright (в readme, например).

  Функция LocMsg возвращает указатель на строку в соответствие  с
языковыми  настройками  FAR'а  (учитывает  настройки   конкретных
пользователей - фича FAR 1.63).

  В каталоге с плагином должен быть файл с сообщениями  с  именем
"ИмяПлагина.msg" Описание формата находится в файле template.msg.

Передаваемые параметры:
MsgName - название нужного сообщения
Var     - если не NULL, то сюда копируется полученная строка

Должна также быть определена и заполнена глобальная структура
PluginStartupInfo Info, из неё берутся данные:
Info.RootKey - место, где хранятся данные плагинов
Info.ModuleName - полный путь к плагину
*/
char *LocMsg(char *MsgName, char *Var)
{
        HKEY hKey;
        DWORD Type;
        static char Msg[80];
        char msgfile[MAX_PATH], //имя файла с данными
             Lang[80]="Russian",/*Название языковой секции,
                                по умолчанию=Russian*/
             LangKey[80]="";    //Языковые настройки FAR'а

        lstrcpy(msgfile,Info.ModuleName);//Определяем имя файла
        char *ptr=strrchr(msgfile,'.');  //с сообщениями.
        if(ptr) lstrcpy(ptr,".msg");     //У Вас это может
        else lstrcat(msgfile,".msg");    //выглядеть иначе.

        lstrcat(LangKey,Info.RootKey);//Определяем:
        ptr=strrchr(LangKey,'\\');    //откуда читать
        lstrcpy(ptr+1,"Language");    //языковые настройки.

        //Читаем языковые настройки текущего пользователя
        if(RegOpenKeyEx(HKEY_CURRENT_USER,LangKey,0,
        KEY_READ,&hKey)==ERROR_SUCCESS)
        {
               DWORD DataSize=80;
               RegQueryValueEx(hKey,"Main",NULL,&Type,
                               (BYTE *)&Lang,&DataSize);
               RegCloseKey(hKey);
        }

        if(!<a href="win32/getprivateprofilesection.html">GetPrivateProfileSection</a>(Lang,Msg,80,msgfile))
        {
               /*если требуемой секции нет, то прочитать имя
               секции по умолчанию*/
               <a href="win32/getprivateprofilestring.html">GetPrivateProfileString</a>("Default","Language",
                                      "Russian",Lang,80,msgfile);
               if(!GetPrivateProfileSection(Lang,Msg,80,msgfile))
                  /*если нет требуемой секции с именем, равным
                  имя по умолчанию, то читать будем первую
                  попавшуюся секцию*/
                  <a href="win32/getprivateprofilesectionnames.html">GetPrivateProfileSectionNames</a>(Lang,80,msgfile);
        }

        //читаем нужную строку
        GetPrivateProfileString(Lang,MsgName,MsgName,Msg,80,
                                msgfile);

        /*Если раскомментировать следующую строку, то в msg-файле
        будут автоматически создаваться отсутствующие секции*/
        /*if(lstrcmp(MsgName,Msg)==0)
           <a href="win32/writeprivateprofilestring.html">WritePrivateProfileString</a>(Lang,MsgName,Msg,msgfile);*/

        //Копируем в Var полученную строку, если надо
        if(Var)lstrcpy(Var,Msg);
        return(Msg);
}</pre>
<p class plain>Файл с сообщениями должен называться ИмяПлагина.msg  и является обыкновенным ini-файлом. Его структура такова (содержимое упомянутого выше <em>template.msg</em>):</p>
<pre class=code>[Default]
//Данная секция сообщает из какой секции брать строки, если в
//данном файле не найдено требуемой языковой секции. Данная секция
//может отсутствовать, в этом случае языковой секцией по умолчанию
//считается первая.
Language=Russian

//Далее идёт описания языковых секций.
//Названия ДОЛЖНЫ формироваться следующим образом:
//В lng-файлах первая строка такая
//.Language=Russian,Russian (Русский)
//          ^^^^^^^
//А вот так должна называться языковая секция

[Russian]
String1=Текст первого сообщения
String2=Текст второго сообщения

[English]
String1=Text of the first message
String2=Text of the second message
//и т.д.
</pre>
<p class=plain>Демонстрация работы с данной функцией находится в архиве <em><a target="_blank" href="http://plugring.farmanager.com/downld/files/devel/localization.rar">localization.rar</a></em>, который можно взять <a target="_blank" href="http://www.moris.ru/~spinoza">здесь</a> или ещё где-нибудь.<p>
<center><h3>ЧАСТЬ ВТОРАЯ. ЛОКАЛИЗАЦИЯ СПРАВКИ</h3></center>
<p class=plain>К сожалению, <dfn>Евгений Рошал не предусмотрел в API функции,
выводящей определённый топик нужного hlf-файла</dfn>. Но в данном случае это
не страшно.</p>
<div class=alert2>
<blockquote><blockquote>
Статья писалась в то время, когда о FAR 1.70 ещё и слышно не
было :), поэтому данное заявление уже неверно. В FAR Manager версии 1.70 и
выше вы можете для вывода нужного топика нужного hlf-файла функцией
<a href="../service_functions/showhelp.html">ShowHelp</a>.
</blockquote></blockquote>
</div>

<p class=plain>Допустим, существует плагин с поддержкой субплагинов, и имя ему <em>mainplugin.dll</em>, файлы помощи имеют имена <em>mainpluginR.hlf</em> и <em>mainpluginE.hlf</em>. Пользователь захочет посмотреть справку под названием <em>MainDialog</em> (например) для субплагинов по имени <em>subplugin1</em> и <em>subplugin2</em>. Для этого нужно просто добавить имена данных топиков в параметры функции <em>Dialog</em> у данных субплагинов, а сами топики дописать к файлам <em>mainpluginR.hlf</em> и <em>mainpluginE.hlf</em>. Для первого субплагина это будет топик с именем <em>subplugin1_MainDialog</em> (рекомендую в качестве префикса к топику писать название субплагина, тогда не будет совпадений/противоречий с другими субплагинами), для второго - <em>subplugin2_MainDialog</em>. В результате нужная справка будет для субплагина показываться также как и для основного плагина.</p>
<p class=plain>That's all,  folks :-)</p>

<div align=right><code>
<br>&nbsp;<br>
07.01.2000
</code></div>
<div class=seecont><a href="#top">наверх</a></div>
</body>
</html>