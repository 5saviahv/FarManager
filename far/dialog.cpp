/*
dialog.cpp

Класс диалога

*/

/* Revision: 1.208 11.02.2002 $ */

/*
Modify:
  11.02.2002 SVS
    + DM_LISTGETDATASIZE
    ! dialog.cpp::MsgToName() - syslog.cpp::_DLGMSG_ToName()
    - Падение при поиске - забыл проверить CurItem->ListItems на NULL
    - BugZ#294. Колесо, блин... не работало в списках.
  04.02.2002 SVS
    ! Первая попытка "урегулировать отношения" диалога с редактором в плане
      DIF_READONLY
    ! По поводу "невозвратов" информации о списках после возврата из диалога
  30.01.2002 DJ
    ! DM_SETLISTMOUSEREACTION -> DM_LISTSETMOUSEREACTION
  21.01.2002 SVS
    + Добавлены 2 месага - DM_SETCURSORSIZE/DM_GETCURSORSIZE. Работают с
      редакторами и UserControl
    ! Изменены данные для UserControl
  16.01.2002 SVS
    ! DIF_NOFOCUS шалит
  08.01.2002 SVS
    + DM_SETLISTMOUSEREACTION
    ! Неверно учитывался размер диалога (для примера - S&R имеет высоту 25 строк)
  03.01.2002 SVS
    ! Уточнение для обрезания заголовков в DI_SINGLEBOX.
  28.12.2001 SVS
    ! Правка с учетом изменений структур (про анонимный union)
  28.12.2001 SVS
    ! Уточнение для обрезания заголовков в DI_SINGLEBOX.
  21.12.2001 SVS
    - Если DI_LISTBOX был не в фокусе, то... все равно гад реагировал на мышу.
    ! (unsigned char) -> (short)
  19.12.2001 SVS
    ! Раз уж пред.патч влез в область клиппинга, то... сделаем это самое
      отсечение для максимального количества элементов (читай - не для всех).
  17.12.2001 KM
    ! Пусть диалог сам заботится о ширине собственного заголовка.
      > IS "Если ввести слишком длинную маску, то она рисуется за краями
      диалога. TruncStr забыл что ли сделать?"
  12.12.2001 SVS
    - BugZ#172 - unchanged & history
  10.12.2001 SVS
    - Бага для KEY_SPACE+DI_RADIOBUTTON - переменная не инициализировалась
    ! DM_SETREDRAW=DM_REDRAW, DM_SETTEXTLENGTH -> DM_SETMAXTEXTLENGTH,
      DM_LISTGET -> DM_LISTGETITEM
    + struct FarListGetItem для DM_LISTGETITEM
  09.12.2001 DJ
    ! косметика в Dialog API:
      - проверять валидность ID элемента для DM_KEY и юзерских мессаг не надо!
      - DM_SETDROPDOWNOPENED неприменим к DI_PSWEDIT
      - обработка DIF_USELASTHISTORY вынесена в отдельную функцию
  07.12.2001 SVS
    ! Небольшая оптимизация кода
    - Бага в GetDialogObjectsData() - для DI_LISTBOX кусок не работал, т.к.
      у него нету ObjPtr
  07.12.2001 IS
    ! флаг DIF_EDITOR не сбрасывается также для DI_FIXEDIT и DI_PSWEDIT
      (теряли совместимость со старым api)
  04.12.2001 SVS
    ! забыли отцентрировать кпопки (DIF_CENTERGROUP) после расширябильности
  04.12.2001 SVS
    ! сбросим флаг DIF_EDITOR для строки ввода, отличной от DI_EDIT
  03.12.2001 SVS
    ! Уточнение работы DM_SETHISTORY: для DI_EDIT с флагом DIF_USELASTHISTORY
      ФАР сам подставит Line0 из истории, при условии, что строка ввода пуста.
  01.12.2001 KM
    + DM_LISTSET - новое сообщение, отличается от DM_LISTADD тем, что
      если в списке есть строки, то сначала удалим их, т.с. "чистая"
      установка.
  28.11.2001 SVS
    ! DM_EDITCLEARFLAG заменен на более корректное DM_EDITUNCHANGEDFLAG
    ! Закрыта небольшая лазейка для все того же clearflags.
  28.11.2001 SVS
    + DM_EDITCLEARFLAG - управление состоянием флага ClearFlag редактора
  27.11.2001 DJ
    - memory leak
  27.11.2001 SVS
    ! небольшое уточнение при DM_SETTEXT - не вызывать InitDialogObjects()
      для строковых редакторов
  23.11.2001 SVS
    - Бага - если в singleline есть 0x0A или 0x0D, то... в общем не
      выводятся они
  23.11.2001 VVM
    ! Раз уж мы наследники фрейма, неплохо бы посмотреть на лок прорисовки
  21.11.2001 SVS
    + Автоматизация (часть I - для внутренного использования).
    + DM_GETITEMDATA, DM_SETITEMDATA
  15.11.2001 SVS
    - уточнение для DI_COMBOBOX - здесь еще и Edit нужно корректно заполнить
  14.11.2001 SVS
    ! DN_EDITCHANGE: Path#1047:
      "...Уточнение повендения DN_EDITCHANGE при выборе из истории..."
      "...баг прибит в лучших традициях прогрАммерского искусства, те
      наполовину :). почему отмена выбора ESC'ом в комбобоксе все равно
      генерит DN_EDITCHANGE?..."
      Блин,  урод он. Так бы и говорил,  что это про COMBOBOX.
  12.11.2001 SVS
    ! Уточнение по поводу поведения DN_LISTCHANGE (в т.ч. прорисовка во время
      открытого комбобокса)
    ! Уточнение повендения DN_EDITCHANGE при выборе из истории
    ! Уточнение поведения DIF_SELECTONENTRY
  09.11.2001 SVS
    - Падение при раскрытии комбобокса с количеством итемов = 0
  08.11.2001 SVS
    + IsDialogParent - а родитель у нас кто для строк редактирования?
    ! Добавка в виде BitFlags - управление флагами текущего режима диалога
  06.11.2001 SVS
    ! DM_LIST[G|S]ETTITLE -> DM_LIST[G|S]ETTITLES
    - BugZ#36: проблемы с перерисовкой истории после записи макроса
      откройте диалог с  историей,  например,  alt-f7,  откройте  историю
      (ctrl-down), запишите  макрос,  после  назначения  горячей  клавиши
      история как бы пропадает, видны только ее ошметки, если  понажимать
      вверх/вниз, то появляются прочие куски истории
      Сделано через одно место :-( Но работает.
  04.11.2001 SVS
    ! Если DropDown теряет фокус, то не будем отображать его как селектед.
  02.11.2001 SVS
    ! DM_SETNOTIFYMOUSEEVENT -> DM_SETMOUSEEVENTNOTIFY
    ! Выкинем ненужный код (а кое-где добавим :-))
  29.10.2001 SVS
    ! DM_RESIZEDIALOG возвращает новый размер!
  23.10.2001 SVS
    ! FarListTitle -> FarListTitles
    ! Эксперимент - в ProcessMouse делаем обход контролов с конца на начало,
      т.е. учитываем (как бы) Z-order (IMHO так будет вернее, но чем черт
      не шутит)
  21.10.2001 SVS
    ! вызов CALLBACK-функции (в месаге DN_RESIZECONSOLE) перемещен в "нужное место"
    ! Изменена логина добавления в историю:
      "если в истории есть строка, равная без учета регистра той,
      которую добавляем, то удалить старую строку и добавить новую".
      (на самом деле, просто добавляем не оригинал, а добавляемую строку!)
  18.10.2001 SVS
    + DIF_SEPARATOR2 - двойной сепаратор
    + вызов CALLBACK-функции (в месаге DN_RESIZECONSOLE)
      для избавления от BugZ#85
  15.10.2001 SVS
   + _DIALOG - для трассировки сообщений и событий в диалогах.
  15.10.2001 SVS
   ! BugZ#71: "Если "редактор" имеет флаг DIF_NOFOCUS..." - Неверно было
     сделано исправление от 10.10.2001. Теперь все верно - всегда в таком
     случае кажем Unchanged-цветом
  15.10.2001 SVS
   ! if Opt.DlgSelectFromHistory == 0 then (ctrl-down в строке с историей
     курсор устанавливался на самую верхнюю строку)
   - "Если в истории диалоги все 64 элемента залочены..."
  10.10.2001 SVS
   ! Если "редактор" имеет флаг DIF_NOFOCUS, то показывать его нефокусным
     цветом (BugZ#71)
  08.10.2001 SVS
   - Неверно рассчитывались координаты элементов DI_TEXT & DI_VTEXT
  04.10.2001 SVS
   ! УБЕДИТЕЛЬНАЯ ПРОСЬБА!!!
     Функции Dialog::DefDlgProc и Dialog::SendDlgMessage должны быть всегда
     в конце этого файла. Если что-то добавлять - то перед Dialog::DefDlgProc()
     Обоснование: Мне так удобнее ;-)
   - DN_GOTFOCUS -> DM_SETFOCUS - получаем цикл с падением
  04.10.2001 SVS
   - Для DI_USERCONTROL не высвечивался курсор
  27.09.2001 IS
   - Левый размер при использовании strncpy
  16.09.2001 SVS
   ! Отключаемые исключения
  08.09.2001 VVM
   + Использовать Opt.DialogsEditBlock для строк ввода
  05.09.2001 SVS
   - Горячая клавиша, фокус ввода становится, но прорисовка не идет :-((
  30.08.2001 VVM
   + Для обычных строк отрубим постоянные блоки
  15.08.2001 SVS
   + DN_MOUSEEVENT, DM_SETNOTIFYMOUSEEVENT, DMODE_MOUSEEVENT
  13.10.2001 SVS
   - Если у элемента X2 < X1, то ФАР отжирает кучу памяти и сваливается в пике.
  11.10.2001 KM
   - Ещё одно уточнение при ресайзинге, с учётом предполагаемого
     выхода краёв диалога за границу экрана.
  10.08.2001 KM
   - Неправильно работал DM_RESIZEDIALOG. Заметил когда делал
     ресайзинг Alt-F7 при изменении размеров консоли.
   - В SetItemRect неверно выставлялся X1 в 0 при переданном
     параметре -1 (центрировать строку).
  08.08.2001 SVS
   + DM_GETITEMPOSITION
  07.08.2001 SVS
   + DN_RESIZECONSOLE
  06.08.2001 SVS
   ! DM_GETTEXTLENGTH возвращает размер строки без учета '\0'
   ! заголовок ФАР меняет только если DM_SETTEXT был вызван для
     соответствующих элементов (SetFarTitle(Dlg->GetDialogTitle()))
   ! Проверка на видимость диалога (будет полезна в следующих патчах,
     когда манагер будет вызывать Hide() диалога - для Alt-F7+CAS)
   ! Немного скорректированы цвета для строки редактирования (2IS: проверь
     на себе)
  05.08.2001 SVS
   ! Перетрях в математике добавления истории (Dialog::AddToEditHistory)
   - Бага с селекшинами при выборе из хистори.
   ! DM_GETTEXTLENGTH корректно возвращает размер текущего итема для DI_LISTBOX
   ! Изменилось поведение DI_RADIOBUTTON
       Param2 = 0|1 - включен или выключен
  05.08.2001 SVS
   - Проблемы с хелпом в диалогах из-под плагинов.
   ! Отрисовка(?) после DI_EDITCHANGE
   - Ctrl-Enter или Enter при задисабленной дефолтовой кнопке
  01.08.2001 SVS
   + Новая идеология создания топика - пусть об этом позаботится ядро Help`а
  27.07.2001 SVS
   + DM_ALLKEYMODE - для нужд MacroBrowse (пока только для него :-)
  26.07.2001 SVS
   ! VFMenu уничтожен как класс
  24.07.2001 SVS
   ! Учтем новую опцию Opt.Confirm.HistoryClear при очистки истории
  23.07.2001 OT
   - Исправление отрисовки меню в новом MA в макросах
  23.07.2001 VVM
   + При удалении строки из истории курсор оставлять на месте.
   + При очистке истории спросить об этом пользователя.
  23.07.2001 SVS
   ! DIF_SEPARATOR пока не обрабатываем для DI_VTEXT
  23.07.2001 SVS
   - Не освобождалась память, занятая под списки в DeleteDialogObjects()
  22.07.2001 SVS
   ! Пересмотрены параметры функции SelectFromComboBox() - ведь и так
     передаем указатель аж на цельный класс строки, так что...
  18.07.2001 OT
   !  VFMenu
  16.07.2001 SVS
   + DM_SETHISTORY - управление историей
  12.07.2001 OT
   - Исправление ситуации (после 816) F11->F4->Esc-> :(
  11.07.2001 OT
   ! Перенос CtrlAltShift в Manager
  10.07.2001 SVS
   + Обработка KEY_MACROXLAT
  09.07.2001 OT
   - Исправление MacroMode для диалогов
  04.07.2001 SVS
   + DIF_SEPARATOR для DI_VTEXT
   + {-1,-1} для DI_VTEXT
  04.07.2001 SVS
   - XLat в строках ввода - не снималось состояние Unchanged
   - Немного проверок...
  02.07.2001 KM
   - Избавимся от потенциального (и кажется не только) бага
     при Param1==-1 в SendDlgMessage (в основном) и DefDlgProc.
   - Убраны некоторые ворнинги об неиспользуемых переменных.
  30.06.2001 KM
   ! LIFIND_NOPATTER -> LIFIND_NOPATTERN
   ! DM_LISTGETCURPOS: Param2 содержит указатель на FarListPos.
   ! DM_LISTSETCURPOS: Param2 содержит указатель на FarListPos.
   ! Подадим сообщение DN_LISTCHANGE в ProcessMouse на DI_LISTBOX.
  29.06.2001 SVS
   - Бага - двое добавление первоначальных данных в комбобокс
   + ЗАКОММЕНЧЕНО: Во время навигации в открытом боксе (дропдовн)
                   отображаем это в связанной строке редактирования
                   (медленно! :-(
   ! Проблемы с выбором из комбобокса
  26.06.2001 KM
   ! Подадим перед DM_LISTSETCURPOS сообщение DN_LISTCHANGE.
  26.06.2001 SVS
   ! __except -> EXCEPT
  26.06.2001 KM
   - Не работал клик на скролбаре в DI_LISTBOX.
  23.06.2001 KM
   - Не снимался признак активности комбобокса если с него
     уходили мышкой на DI_EDIT.
   + DM_GETDROPDOWNOPENED - определить, открыт ли в диалоге комбобокс или хистори.
   + DM_SETDROPDOWNOPENED - открыть или закрыть программным путём комбобокс или хистори.
  20.06.2001 SVS
   - "функция DM_GETTEXTLENGTH возвращает 0 длину для всех DI_EDIT"
  19.06.2001 SVS
   + DN_DRAGGED
  19.06.2001 SVS
   ! Операция автозавершения не работает во время записи и исполнения макроса.
   - устранение потенциальной проблемы (выход за границу массива) при выборе
     значения из истории.
  14.06.2001 SVS
   ! число -> VMENU_COLOR_COUNT
  14.06.2001 OT
   - баг Панели->F5->CtrlDown->трап
     неверно инициализировался массив цветов для меню истории :((
  12.06.2001 KM
   ! Зачем-то была убрана инициализация DI_COMBOBOX через FarDialogItem.
     Восстановлено!!!
  11.06.2001 KM
   ! Сделана нормальная работа мыши в DI_LISTBOX.
  10.06.2001 SVS
   ! Для DM_LISTFINDSTRING вызовен немного другу функцию.
  08.06.2001 SVS
   + Пока возился с "вылезанием" клеаред-строки за пределы диалога...
     подумалось - а фигля это так несправедливо, что когда раскрываем
     хистори со строки редактирования не снимается клеаред-флаг?
  06.06.2001 SVS
   ! Mix/Max
  05.06.2001 KM
   ! Изменился тип возвращаемого значения у DM_LISTSETTITLE - стал TRUE и
     DM_LISTGETTITLE - стал TRUE, если получен Title или Bottom и FALSE если
     не получили ни того ни другого.
  04.06.2001 SVS
   + Shift-Del очищает текущий пункт истории команд.
  04.06.2001 SVS
   ! выкинут LIF_PTRDATA - изжил себя как класс :-)
   ! SelectFromEditHistory полностью переписана, в т.ч. исключена ненужная
     рекурсия.
   ! В связи с переделкой SelectFromEditHistory() появилась возможность
     обрабатывать неограниченное количество пунктов хистори (в данном случае
     64 - под общий стандарт, т.с. :-)
   ! AddToEditHistory() - параметр про размер теперь нафиг ненужен.
   + При занесении в хистори нового значения, после сортировки...
     происходит удаление неиспользуемых пунктов хистори.
  03.06.2001 KM
   + Добавлены сообщения DM_LISTSETTITLE и DM_LETSGETTITLE для установки/получения
     заголовков DI_LISTBOX. Используется структура FarListTitle.
   ! При каждой перерисовке диалога, кроме режима перемещения, устанавливаем
     заголовок консоли, в противном случае он не всегда восстанавливался.
   ! Исправлена подсветка в DI_LISTBOX и DI_COMBOBOX, теперь на самом деле :)
     для чего используется флаг DIF_LISTAUTOHIGHLIGHT.
  03.06.2001 SVS
   ! Коррекция SelectFromEditHistory с учетом нового ListUserData
     (запонимаем полностью весь текст, который есть в реестре и пихаем
      к итему списка)
   + DM_LISTGETDATA, DM_LISTSETDATA
  30.05.2001 KM
   - Косячило центрирование диалога и изменение размера диалога
     при использовании DM_MOVEDIALOG и DM_RESIZEDIALOG
   + Запущен в действие DM_SETITEMPOSITION:
     Param1 = ID элемента диалога.
     Param2 = Указатель на структуру SMALL_RECT с новыми координатами.
     Возвращает TRUE для верного ID, FALSE в противном случае.
  28.05.2001 SVS
   ! RegKey[80] -> RegKey[NM]
  27.05.2001 SVS
   ! Для RO элемента редактирования сами отслеживаем RO состояние.
   ! Для DM_SHOWITEM нужно перерисовать элемент для случая
  26.05.2001 OT
   - Выпрямление логики вызовов в NFZ
   + Добавление признака способа "конструирования" объекта
  24.05.2001 SVS
   ! Если используется USeLastHistory, то учитываем флаг в реестре, который
     нам подскажет - а нужно ли вообще...
     Т.е. если последний раз мы оставили строку пустой, то в следующий раз
     нефига заполнять поле ввода в следующий раз.
  23.05.2001 VVM
   ! Отменил раскрытие комбобокса по KEY_DOWN. Ну невозможно работать...
  23.05.2001 SVS
   - Проблемы с горячими клавишами в меню - Part II (гады, в другом месте
     вылезли :-( )
  23.05.2001 SVS
   - Проблемы с горячими клавишами в меню.
  21.05.2001 DJ
   + обработка смены фокуса
  21.05.2001 SVS
   + DM_SETITEMPOSITION - резерв на будущее (кусок еще не оттестирован)
   + DM_RESIZEDIALOG
   ! struct MenuData|MenuItem
     Поля Selected, Checked, Separator и Disabled преобразованы в DWORD Flags
  18.05.2001 DJ
   ! Dialog унаследован от Frame
  18.05.2001 SVS
   + DM_GETCHECK/DM_SETCHECK/DM_SET3STATE
   + DM_LISTINFO/DM_LISTFINDSTRING/DM_LISTINSERT
   ! DM_MOVEDIALOG - если Param1 == -1, то Param2=COORD=ResizeDialog
  17.05.2001 SVS
   + DM_LISTUPDATE - совсем забыл про эту хрень ;-(
  15.05.2001 KM
   - Терерь подсветка в DI_LISTBOX работает. Для её включения
     используется флаг DIF_LISTNOAMPERSAND (блин горелый, он уже был).
   ! В связи с предыдущим пунктом удалён дублирующий флаг DIF_LISTHIGHLIGHT.
   ! Подсветка в DI_COMBOBOX сделана с использованием DIF_LISTNOAMPERSAND.
   - Убран баг с зависанием при нажатии KEY_END в DI_LISTBOX.
  14.05.2001 SVS
   ! DMODE_SMALLDILAOG -> DMODE_SMALLDIALOG
   ! DIF_CENTERGROUP только для DI_BUTTON, DI_CHECKBOX, DI_RADIOBUTTON, DI_TEXT.
   - небольшая опЯчатка в InitDialogObjects.
   - В AdjustEditPos не был учтен тот факт, что ListBox "живет" в
     DialogItem.ListPtr
  13.05.2001 SVS
   + DIF_LISTWRAPMODE, DIF_LISTHIGHLIGHT
   ! Для DI_COMBOBOX&DIF_DROPDOWNLIST нажатие клавиши KEY_DOWN эквивалентно
     Ctrl-Down, т.е. список раскроется.
   ! сбросим флаг DIF_CENTERGROUP для редакторов
   - небольшая бага с сепараторами после введения DMODE_SMALLDILAOG
   + Новое сообщение DM_LISTADDSTR (Param1=ID Param2=String)
   ! DI_LISTBOX теперь "живет в DialogItem.ListPtr"
  08.05.2001 SVS
    + обработка флага DMODE_SMALLDILAOG
  07.05.2001 SVS
    + DM_LISTSORT, DM_LISTADD, DM_LISTDELETE, DM_LISTGET, DM_LISTGETCURPOS,
      DM_LISTSETCURPOS
    ! SysLog(); -> _D(SysLog());
  07.05.2001 SVS
    ! При отключенном автодополнении можно воспользоваться клавишами Ctrl-End
  06.05.2001 DJ
    ! перетрях #include
  04.05.2001 SVS
    ! Наконец то дошли руки до DI_LISTBOX ;-) - новый член FarDialogItem.ListPos
    - Бага с DN_INIT* - переведен "на уровень выше", т.е. до запоминания
      области отображения диалога.
    - какого хрена засунули DialogEdit->FastShow() в функцию инициализации?
  28.04.2001 SVS
   + Функция GetItemRect() получения геометрии итема.
   - DN_MOUSECLICK фактически не работал, если рамка стояла первой в списке.
  27.04.2001 SVS
   - Не работали позиционирование в хистори и в комбобоксах - вместо
     MaxLen, стояло sizeof(MaxLen) :-((
  27.04.2001 VVM
   + Обработка KEY_MSWHEEL_XXXX
   - Убрал подмену клавиш при прокрутке.
  26.04.2001 SVS
   - Проблема с DM_SETTEXTLENGTH: выставляем максимальный размер в том
     случае, если он еще не выставлен.
  25.04.2001 SVS
   + уточнения по поводу DM_SETTEXTLENGTH & DIF_VAREDIT
  24.04.2001 SVS
   ! Подмена клавиш при прокрутке колеса.
   ! Если в ответ на событие DN_MOUSECLICK (Param=-1) обработчик диалога
     вернет TRUE, то диалог не будет закрыт. Если игнорировать
     {DN_MOUSECLICK,-1} или вернуть FALSE, то диалог не закроется.
   ! Клик мышой вне диталога - обрабатываются только левая и правая клавиши
     остальные клавиши не имеют значения
  23.04.2001 SVS
   - Забыл послать месаг DN_EDITCHANGE при выборе из хистори.
  22.04.2001 SVS
   + DIF_SHOWAMPERSAND для DI_BUTTON, DI_CHECKBOX, DI_RADIOBUTTON
  16.04.2001 SVS
   + Tab в списке хистори - аналог Enter
   ! Перерисовка в автодополнении должна идти после DN_EDITCHANGE (imho)
  12.04.2001 SVS
   + DM_ADDHISTORY - добавить строку в историю
   + DIF_MANUALADDHISTORY - добавлять в историю только "ручками"
   ! функция AddToEditHistory теперь возвращает результат операции
     добавления строки в историю
  12.04.2001 SVS
   ! Дополнительная проверка для DM_SETDLGITEM на смену типа котрола.
     Нефига пока менять - ядро еще не готово к метаморфозам. Потом как нить.
   + CheckDialogCoord() - проверка и корректировка координат диалога
   ! не был реализован механизм центрирования диалога для DM_MOVEDIALOG
     это когда координаты = -1, и задано абсолютное смещение.
  02.04.2001 SVS
   + исключим смену режима RO для поля ввода с клавиатуры
  23.03.2001 SVS
   ! У функции ConvertItem() новый параметр InternalCall - сейчас
     используется только для DN_EDITCHANGE
  22.03.2001 SVS
   - немного подправлен механизЪм DN_EDITCHANGE
  05.03.2001 SVS
   - Бага в хоткеях :-(
  21.02.2001 IS
   ! Opt.EditorPersistentBlocks -> Opt.EdOpt.PersistentBlocks
  21.02.2001 IS
   - Избавился от утечки памяти в SelectFromEditHistory (проявлялось не у всех,
     но проявлялось же!)
  20.02.2001 SVS
   ! Пересмотр алгоритма IsKeyHighlighted с добавками Alt- на
     сколько это возможно
  20.02.2001 SVS
   ! Уточнение поведения горячих клавиш с учетом Disabled & Hidden...
  20.02.2001 SVS
   - Бага в SelectFromComboBox
  13.02.2001 SVS
   ! HISTORY_COUNT - константа для размера истории.
   + Дополнительный параметр у FindInEditForAC, SelectFromEditHistory,
     AddToEditHistory и SelectFromComboBox - MaxLen - максимальный размер
     строки назначения.
   + DI_COMBOBOX тоже мАгет работать с DIF_VAREDIT
   ! Рисование "салазок" перенесено в DefDlgProc(DN_DRAWDIALOG,1)
   ! Если функция обработчик в ответ на DN_DRAWDIALOG вернула FALSE,
     то диалог отрисовываться не будет
   ! Если функция обработчик в ответ на DN_DRAWDLGITEM вернула FALSE,
     то элемент диалога отрисовываться не будет
  12.02.2001 SVS
   + Добавка на реакцию DOUBLE_CLICK - чекбоксы стали шустрее переключаться :-)
     AN> ...Пробелом те же чекбоксы переключаются очень шустро.
     AN> Это именно отсутствие реакции на (MouseEvent.dwEventFlags==DOUBLE_CLICK).
  11.02.2001 SVS
   ! DIF_VAREDIT - только для DI_EDIT!!!
  11.02.2001 SVS
   ! Несколько уточнений кода в связи с изменениями в структуре MenuItem
  23.01.2001 SVS
   ! Изменены функции DeleteDialogObjects() и GetDialogObjectsData()
   + Введены ексепшины в DataToItem и ConvertItem
   ! Введена проверка на NULL объектов ObjPtr
  04.01.2001 SVS
   - Bug - DM_KEY не реагировал на то, что возвращает пользовательская функция
  04.01.2001 SVS
   - Bug при использовании DM_SETDLGITEM - неверно устанавливался фокус ввода
  28.12.2000 SVS
   + добавлена обработка Opt.HotkeyRules
  25.12.2000 SVS
   - Забыл сделать возврат из функции для DM_GETTEXTPTR
  21.12.2000 SVS
   ! Ctr-Break теперь недействителен, т.е. все зависит от того
     что вернет обработчик.
   + DIF_SHOWAMPERSAND для DI_*BOX
   + DM_GETTEXTPTR, DM_SETTEXTPTR
  15.12.2000 SVS
   ! При перемещении диалога повторяем поведение "бормандовых" сред.
   ! Новый движок мышиного перемещения
  14.12.2000 SVS
   ! Дополнение цветов (пропустил :-)
   + Отмена реакции хоткеев для DIF_DISABLE
  08.12.2000 SVS
   ! DM_SET(GET)TEXT - Param2 указатель на структуру FarDialogItemData
  06.12.2000 SVS
   - Охрененная бага с SelectOnEntry() - эта функция вызывалась
     до создания редактора!!!
   ! Обработка кликания мыши вне диалога вынесена в DefDlgProc
   ! Уточним логику работы:
     1) DI_BUTTON: Если не старый стиль и кнопка "не для закрытия"
                   (DIF_BTNNOCLOSE), то ничего не делаем, иначе -
                   предлагаем закрыть диалог.
     2) Если нажали Enter не на DI_BUTTON, то отрабатываем как и раньше
        при условии, что есть кнопка с Default=1 и у этой кнопки не
        выставлен флаг DIF_BTNNOCLOSE.
  05.12.2000 IS
   ! Все удалил в блоке, где проверяем, автодополнять или нет,
     и написал заново
  04.12.2000 SVS
   - перебор с DIF_NOFOCUS :-(
   - При удаление в предыдущем патче - прихватил нужную строку :-(
   ! Для DI_USERCONTROL - для копирования Data используется memmove()
  04.12.2000 SVS
   ! Проблемы с фокусом ввода:
     "Ctrl-A Alt-N Enter - фокус ввода не устанавливался в поле даты."
   ! Автодополнение - чтобы не работало во время проигрывания макросов.
   ! Оптимизация функций ConvertItem() и DataToItem() - с указателями
     будет генериться компактный и быстрый код (MSVC - это сам делает :-(
   + DIF_3STATE - 3-х уровневый CheckBox
   ! Уточним на что влияет флаг DIF_DROPDOWNLIST - только для DI_COMBOBOX.
   - Исключаем из списка оповещаемых о мыши недоступные элементы
   ! Для DI_PSWEDIT и DI_FIXEDIT обработка DIF_EDITEXPAND не нужна
   ! Отрисовка Disabled
  03.12.2000 IS
   ! Не автодополнять, если после курсора есть невыделенные символы.
     Работает это правило, естественно, только с постоянными блоками.
  21.11.2000 SVS
   - Не стиралась последняя строка в многострочном редакторе
  08.11.2000 SVS
   ! Изменен пересчет кодов клавишь для hotkey (используются сканкоды)
  04.11.2000 SVS
   + Проверка на альтернативную клавишу при XLat-перекодировке
  26.10.2000 SVS
   ! DM_SETEDITPOS/DM_GETEDITPOS -> DM_SETCURSORPOS/DM_GETCURSORPOS
   + Работа с курсором для DI_USERCONTROL в ограниченном варианте.
  23.10.2000 SVS
   + DM_SETEDITPOS, DM_GETEDITPOS -
      позиционирование курсора в строках редактирования.
  20.10.2000 SVS
   + DM_GETFOCUS - получить ID элемента имеющего фокус ввода
  16.10.2000 tran 1.47
   + для EDIT полей выставляется ограничение в 511 символов
  27.09.2000 SVS
   ! Alt-Up/Down/Left/Right - убрал (чтобы в будущем не пересекались
     с MultiEdit)
   ! Ctrl-Alt-Shift - реагируем, если надо.
  24.09.2000 SVS
   + Движение диалога - Alt-стрелки
   + вызов функции Xlat
  22.09.2000 SVS
   ! Уточнение AutoComplete при постоянных блоках.
  20.09.2000 SVS
   ! Enter в строках ввода (кроме DIF_EDITOR) завершает диалог.
  18.09.2000 SVS
   + DIF_READONLY - флаг для строк редактирования
      (пока! для строк редактирования).
  18.09.2000 SVS
   ! Уточнения для SelectOnEntry
   ! Маска не должна быть пустой (строка из пробелов не учитывается)!
  14.09.2000 SVS
   + Флаг DIF_LISTNOAMPERSAND. По умолчанию для DI_LISTBOX
      выставляется флаг MENU_SHOWAMPERSAND. Этот флаг подавляет такое
      поведение
  12.09.2000 SVS
   ! Задаем поведение для кнопки с DefaultButton=1:
     Такая кнопка независимо от стиля диалога инициирует сообщение DM_CLOSE.
   ! Исправляем ситуацию с BackSpace в DIF_EDITOR
   ! Решаем проблему, если Del нажали в позиции большей, чем длина
     строки (DIF_EDITOR)
  11.09.2000 SVS
   + Ctrl-U в строках ввода снимает пометку блока
  09.09.2000 SVS
   + DIF_NOFOCUS - элемент не получает фокуса ввода (клавиатурой)
   + Стиль диалога DMODE_OLDSTYLE - диалог в старом стиле.
   ! вывалить из диалога, ткнув вне диалога, сможем только в старом стиле.
   + Функция SelectOnEntry - выделение строки редактирования
     (Обработка флага DIF_SELECTONENTRY)
  08.09.2000 SVS
   - Если коротко, то DM_SETFOCUS вроде как и работал :-)
   ! Уточнение для DN_MOUSECLICK
  31.08.2000 SVS
   + DM_ENABLE (не полностью готов :-)
   - Бага с вызовом файлов помощи.
  30.08.2000 SVS
   + Метод Hide()
   + Режим диалога DMODE_SHOW - Диалог виден?
   ! уточнения для IsEnableRedraw
   + DM_MOVEDIALOG - перемещение диалога.
   ! Изменение цветов для ComboBox(DowpDownList)
  29.08.2000 SVS
   ! При подмене темы помощи из диаловой процедуры...
     короче, нужно вновь формировать контент!
  29.08.2000 SVS
   - Первый официальный альфа-баг - функция ProcessHighlighting
     MY> Работа с диалогами стала ГЛЮЧНАЯ. Я имею в виду горячие клавиши.
     MY> Входим в настройку чего угодно, жмем Alt-нужную букву и
     MY> наблюдаем разнообразные глюки.
  28.08.2000 SVS
   - баг рук кривых (или не внимательности!) :-)
  25.08.2000 SVS
   + DM_GETDLGRECT - получить координаты диалогового окна
   ! Уточнение для DN_MOUSECLICK
  25.08.2000 SVS
   ! Уточнения, относительно фокуса ввода - ох уж эти сказочки, блин.
  24.08.2000 SVS
   + InitDialogObjects имеет параметр - для выборочной реинициализации
     элементов
  24.08.2000 SVS
   ! Охрененная дыра!!!! (дальше только матом)... это про ComboBox
     Этого лучше не знать...
   + CtrlAltShift - спрятать/показать диалог...
   + Элемент DI_USERCONTROL - отрисовкой занимается плагин.
  24.08.2000 SVS
   ! Критическая ошибка - с фокусов не порядки...
     перестарался с ChangeFocus()
  23.08.2000 SVS
   ! Уточнения категорий DMSG_* -> DM_ (месаг) & DN_ (нотифи)
   + DM_KEY        - послать/получить клавишу(ы)
   + DM_GETDLGDATA - взять данные диалога.
   + DM_SETDLGDATA - установить данные диалога.
   + DM_SHOWDIALOG - показать/спрятать диалог
   + Переменная класса FocusPos - всегда известно какой элемент в фокусе
   ! Переменные IsCanMove, InitObjects, CreateObjects, WarningStyle, Dragged
     удалены -> битовые флаги в DialogMode
   + множество мелких уточнений ;-)
  22.08.2000 SVS
   ! С моим английским вообще ни как :-((
     IsMovedDialog -> IsCanMove
   ! DMSG_PAINT -> DMSG_DRAWDIALOG
   ! DMSG_DRAWITEM -> DMSG_DRAWDLGITEM
   ! DMSG_CHANGELIST -> DMSG_LISTCHANGE
   ! ShowDialog - дополнительный параметр - какой элемент отрисовывать
  21.08.2000 SVS 1.23
   ! Описание сообщений убрано - смотрите в хелпе :-)))
   ! Самыми последними в этом файле должны быть DefDlgProc и SendDlgMessage
     (мне так удобно :-)
   + Перед отрисовкой DI_LISTBOX спросим об изменении цветовых атрибутов
   ! DIF_HISTORY имеет более высокий приоритет, чем DIF_MASKEDIT
   - глюк в AutoComplete при включенных постоянных блоках
   ! DMSG_CHANGEITEM -> DMSG_EDITCHANGE
   + DMSG_BTNCLICK
  12.08.2000 KM 1.20
   + Добавление работы DI_FIXEDIT с флагом DIF_MASKEDIT для установки
     маски в строку ввода.
  18.08.2000 SVS
   + DialogMode - Флаги текущего режима диалога
   + Флаг IsEnableRedraw - разрешающий/запрещающий перерисовку диалога
   + Сообщения: DMSG_ENABLEREDRAW, DMSG_MOUSECLICK
   + DI_BUTTON тоже теперь может иметь DIF_SETCOLOR
   + Флаг для DI_BUTTON - DIF_BTNNOCLOSE - "кнопка не для закрытия диалога"
   - Если на выход процедура ответила "НЕТ", то диалог зацикливался, т.к.
     не был сброшен флаг выхода.
  15.08.2000 SVS
   ! Для DropDownList цвета обрабатываем по иному.
   + Сделаем так, чтобы ткнув мышкой в DropDownList список раскрывался сам.
  11.08.2000 SVS
   + Данные, специфические для конкретного экземпляра диалога
   + Для того, чтобы послать DMSG_CLOSE нужно переопределить Process
   ! Уточнение для DMSG_CLOSE
  11.08.2000 KM 1.18
   ! Убран дублирующий код, исправляющий некорректное перемещение диалога
     мышкой. Оказывается мы с Андреем сделали патчик в один день :)
   ! Чуть-чуть переделано таскание мышкой диалога. Было: после первого нажатия
     мышкой на диалоге отображение режима перемещения не включалось до тех пор
     пока не начиналось само движение диалога, после чего и происходило
     отображение начала этого режима, что есть в корне идеологически неверно :)
   ! Артефакт: если после первого запуска фара, не пермещая мышь
     нажать левую кнопку, чтобы переместить диалог (диалог находится под мышью),
     то из-за того, что к этому моменту PrevMouseX и PrevMouseY ещё не определены,
     также неопределённым получался прыжок диалога.
  10.08.2000 SVS
   + переменная IsMovedDialog - можно ли двигать диалог :-)
   + функция установки IsMovedDialog
  09.08.2000 tran 1.16
   - убраны "салазки"
  09.08.2000 KM
   ! При включении режима перемещения диалога добавлено
     отключение мигающего курсора. Так косметика.
   ! Поправлено перемещение диалога мышкой, Андрей-то не захотел
     исправлять :). Теперь перемещение стало корректным, без прокатывания
     диалога по экрану.
   ! При выходе за край экрана диалогом, тень, по возможности, продолжает
     рисоваться.

     Номер редакции остался прежним - здесь было
     забегание вперёд.
  07.08.2000 SVS
   + В Функции выравнивания кооржинат про ListBox забыли!
  04.08.2000 SVS
    + FarListItems.CountItems -> FarListItems.ItemsNumber
  03.08.2000 tran
   + мышиный перетаск диалога - хватание за пустое место
     внимание - ограничение невыхода за границы экрана посталено не зря
     иначе ползут глюки...
     изменена индикация - по углам красные палки
     с MOVE в угла могут быть глюки в изображении.
     строки про MOVE закоментарены "//# "
  01.08.2000 SVS
   ! History теперь ВСЕГДА имеет ScrollBar, т.к. этот элемент ближе
     к ComboBox`у, нежели к меню.
   - переменная класса lastKey удалена за ненадобностью :-)
   + Обычный ListBox
   - Небольшой глючек с AutoComplete
   ! В History должно заносится значение (для DIF_EXPAND...) перед
     расширением среды!
   + Еже ли стоит флаг DIF_USELASTHISTORY и непустая строка ввода,
     то подстанавливаем первое значение из History
   - Отключена возможность для DI_PSWEDIT иметь History...
     ...Что бы небыло повадно... и для повыщения защиты, т.с.
  31.07.2000 tran & SVS
   + перемещение диалога по экрану клавишами. Ctrl-F5 включает режим
     перемещения. Индикация перемещения - "Move" в левом верхнем углу
  28.07.2000 SVS
   ! Переметр Edit *EditLine в функции FindInEditForAC нафиг ненужен!
   - Небольшой баг с автозавершением:
       ...Есть в хистори на F7 - "templates". Жму F7, нажимаю shift+t=T и ...
       получаю маленькую t. В итоге большую добился только набиранием её
       после маленькой и стиранием оной...
   - Если плагин не выставил ни одного эелемента с фокусом,
     то придется самому об этом позаботиться, и выставить
     фокус на первом вразумительном элементе ;-)
   + AutoComplite: Для DI_COMBOBOX.
   ! SelectFromComboBox имеет дополнительный параметр с тем, чтобы
     позиционировать item в меню со списком в соответсвии со строкой ввода
   ! FindInEditHistory -> FindInEditForAC
     Поиск как в истории, так и в ComboBox`е (чтобы не пладить кода)
   + Функция IsFocused, определяющая - "Может ли элемент диалога
     иметь фокус ввода"
   + Функция ConvertItem - преобразования из внутреннего представления
     в FarDialogItem и обратно
   + Некоторое количество сообщений:
        DMSG_INITDIALOG, DMSG_ENTERIDLE, DMSG_HELP, DMSG_PAINT,
        DMSG_SETREDRAW, DMSG_DRAWITEM, DMSG_GETDLGITEM, DMSG_KILLFOCUS,
        DMSG_GOTFOCUS, DMSG_SETFOCUS, DMSG_GETTEXTLENGTH, DMSG_GETTEXT,
        DMSG_CTLCOLORDIALOG, DMSG_CTLCOLORDLGITEM, DMSG_CTLCOLORDLGLIST,
        DMSG_SETTEXTLENGTH, DMSG_SETTEXT, DMSG_CHANGEITEM, DMSG_HOTKEY,
        DMSG_CLOSE,
  26.07.2000 SVS
   + Ну наконец-то - долгожданный нередактируемый ComboBox
  26.07.2000 SVS
   + AutoComplite: Для DIF_HISTORY.
  25.07.2000 SVS
   + Новый параметр в конструкторе
  23.07.2000 SVS
   + Куча ремарок в исходниках :-)
   + Изменен вызов конструтора - добавка в виде функции обработки
   ! Строковые константы "SavedDialogHistory\\%s",
     "Locked%d" и "Line%d" сделаны поименованными.
   + Функция обработки диалога (по умолчанию) DefDlgProc() - забито место :-)
  19.07.2000 SVS
   ! "...В редакторе команд меню нажмите home shift+end del
     блок не удаляется..."
     DEL у итемов, имеющих DIF_EDITOR, работал без учета выделения...
  18.07.2000 SVS
   + Обработка элемента DI_COMBOBOX (пока все еще редактируемого)
   + Функция-обработчик выбора из списка - SelectFromComboBox
  11.07.2000 SVS
   ! Изменения для возможности компиляции под BC & VC
  05.07.2000 SVS
   + добавлена проверка на флаг DIF_EDITEXPAND - расширение переменных
     среды в элементе диалога DI_EDIT
  25.06.2000 SVS
   ! Подготовка Master Copy
   ! Выделение в качестве самостоятельного модуля
*/

#include "headers.hpp"
#pragma hdrstop

#include "farconst.hpp"
#include "dialog.hpp"
#include "lang.hpp"
#include "fn.hpp"
#include "global.hpp"
#include "keys.hpp"
#include "ctrlobj.hpp"
#include "chgprior.hpp"
#include "vmenu.hpp"
#include "edit.hpp"
#include "help.hpp"
#include "scrbuf.hpp"
#include "manager.hpp"
#include "savescr.hpp"

static char HisLocked[16]="Locked", *PHisLocked=NULL;
static char HisLine[16]  ="Line", *PHisLine=NULL;
static char fmtSavedDialogHistory[]="SavedDialogHistory\\%s";

//////////////////////////////////////////////////////////////////////////
/* Public:
   Конструктор класса Dialog
*/
Dialog::Dialog(struct DialogItem *Item,    // Набор элементов диалога
               int ItemCount,              // Количество элементов
               FARWINDOWPROC DlgProc,      // Диалоговая процедура
               long InitParam)             // Ассоцированные с диалогом данные
{
  _DIALOG(CleverSysLog CL("Create Dialog"));
  _DIALOG(SysLog("Item=%p, ItemCount=%d, DlgProc=%p, Param2=0x%08X",Item,ItemCount,DlgProc,InitParam));
  _tran(SysLog("[%p] Dialog::Dialog()",this));

  if(!PHisLocked) // если некоторые элементы не инициализированы - сделаем это сейчас
  {
    PHisLocked=HisLocked+strlen(HisLocked);
    PHisLine=HisLine+strlen(HisLine);
  }
  SetDynamicallyBorn(FALSE); // $OT: По умолчанию все диалоги создаются статически
  /* $ 17.05.2001 DJ */
  CanLoseFocus = FALSE;
  HelpTopic = NULL;
  /* DJ $ */
  /* $ 19.05.2001 DJ */
  OwnsItems = FALSE;
  /* DJ $ */
  /* $ 29.08.2000 SVS
    Номер плагина, вызвавшего диалог (-1 = Main)
  */
  PluginNumber=-1;
  /* SVS $ */
  /* $ 11.08.2000 SVS
    + Данные, специфические для конкретного экземпляра диалога
  */
  Dialog::DataDialog=InitParam;
  /* SVS $ */
  DialogTooLong=0;
  /* $ 10.08.2000 SVS
     Изначально диалоги можно таскать
  */
  DialogMode.Set(DMODE_ISCANMOVE|DMODE_MOUSELIST);
  /* SVS $ */
  /* $ 23.06.2001 KM */
  SetDropDownOpened(FALSE);
  /* KM $ */
  /* $ 18.08.2000 SVS
  */
  /*
    + Флаг IsEnableRedraw - разрешающий/запрещающий перерисовку диалога
      =0 - разрешена, другие значение - не перерисовывать
        Когда посылается сообщение DMSG_ENABLEREDRAW, то этот флаг
        при Param1=TRUE увеличивается, при Param1 = FALSE - уменьшается
  */
  IsEnableRedraw=0;

  FocusPos=-1;
  PrevFocusPos=-1;

  if(!DlgProc) // функция должна быть всегда!!!
  {
    DlgProc=(FARWINDOWPROC)Dialog::DefDlgProc;
    // знать диалог в старом стиле - учтем этот факт!
    DialogMode.Set(DMODE_OLDSTYLE);
  }
  Dialog::DlgProc=DlgProc;

  Dialog::Item=Item;
  Dialog::ItemCount=ItemCount;

  if (CtrlObject!=NULL)
  {
    // запомним пред. режим макро.
    PrevMacroMode=CtrlObject->Macro.GetMode();
    // макросить будет в диалогах :-)
    CtrlObject->Macro.SetMode(MACRO_DIALOG);
  }
//_SVS(SysLog("Dialog =%d",CtrlObject->Macro.GetMode()));

  // запоминаем предыдущий заголовок консоли
  GetConsoleTitle(OldConsoleTitle,sizeof(OldConsoleTitle));
}


//////////////////////////////////////////////////////////////////////////
/* Public, Virtual:
   Деструктор класса Dialog
*/
Dialog::~Dialog()
{
  _tran(SysLog("[%p] Dialog::~Dialog()",this));
  INPUT_RECORD rec;

  GetDialogObjectsData();
  DeleteDialogObjects();

  if (CtrlObject!=NULL)
    CtrlObject->Macro.SetMode(PrevMacroMode);

  Hide();
  ScrBuf.Flush();

  /* $ 17.05.2001 DJ */
  if (HelpTopic)
    delete [] HelpTopic;
  /* DJ $ */

  /* $ 19.05.2001 DJ
     если мы владеем айтемами, удаляем их
  */
  if (OwnsItems)
    delete [] Item;
  /* DJ $ */

  PeekInputRecord(&rec);
  SetConsoleTitle(OldConsoleTitle);
  _DIALOG(CleverSysLog CL("Destroy Dialog"));
}

void Dialog::CheckDialogCoord(void)
{
  DialogTooLong=0; // Т.к. консоль у нас может постоянно изменяться, то эта
                   // инициализация необходима как воздух

  if(X2 > ScrX)
  {
    X1=-1;
    X2=ScrX-1;
  }

  if (X1 < 0) // задано центрирование диалога по горизонтали?
  {             //   X2 при этом = ширине диалога.
    X1=(ScrX - X2 + 1)/2;

    if (X1 <= 0) // ширина диалога больше ширины экрана?
    {
      DialogTooLong=X2-1;
      X1=0;
      X2=ScrX;
    }
    else
      X2+=X1-1;
  }

  if(Y1 == -1 && Y2 > ScrY+1)
  {
    Y1=-1;
    Y2=ScrY-1;
  }

  if (Y1 < 0) // задано центрирование диалога по вертикали?
  {             //   Y2 при этом = высоте диалога.
    Y1=(ScrY - Y2 + 1)/2;

    if (Y1>1)
      Y1--;

    if(!DialogMode.Check(DMODE_SMALLDIALOG)) //????
      if (Y1>5)
        Y1--;

    if (Y1<0)
    {
       Y1=0;
       Y2=ScrY;
    }
    else
      Y2+=Y1-1;
  }
}

//////////////////////////////////////////////////////////////////////////
/* Public, Virtual:
   Расчет значений координат окна диалога и вызов функции
   ScreenObject::Show() для вывода диалога на экран.
*/
void Dialog::Show()
{
  _tran(SysLog("[%p] Dialog::Show()",this));

  if(PreRedrawFunc)
     PreRedrawFunc();

  if (!DialogMode.Check(DMODE_INITOBJECTS))      // самодостаточный вариант, когда
  {                      //  элементы инициализируются при первом вызове.
    /* $ 28.07.2000 SVS
       Укажем процедуре, что у нас все Ок!
    */
    CheckDialogCoord();
    if(DlgProc((HANDLE)this,DN_INITDIALOG,InitDialogObjects(),DataDialog))
    {
      // еще разок, т.к. данные могли быть изменены
      InitDialogObjects();
    }
    SetFarTitle(GetDialogTitle());
    // все объекты проинициализированы!
    DialogMode.Set(DMODE_INITOBJECTS);
  }
  CheckDialogCoord();
  DialogMode.Set(DMODE_SHOW);
  /* $ 23.11.2001 VVM
    ! Раз уж мы наследники фрейма, неплохо бы посмотреть на лок прорисовки */
  if (!LockRefreshCount)
    ScreenObject::Show();
  /* VVM $ */
}

/* $ 30.08.2000 SVS
  Цель перехвата данной функции - управление видимостью...
*/
void Dialog::Hide()
{
  _tran(SysLog("[%p] Dialog::Hide()",this));
  DialogMode.Skip(DMODE_SHOW);
  ScreenObject::Hide();
}
/* SVS $*/

//////////////////////////////////////////////////////////////////////////
/* Private, Virtual:
   Инициализация объектов и вывод диалога на экран.
*/
void Dialog::DisplayObject()
{
  if(DialogMode.Check(DMODE_SHOW))
  {
    ChangePriority ChPriority(THREAD_PRIORITY_NORMAL);
    if(!DialogMode.Check(DMODE_SMALLDIALOG))
      Shadow();              // "наводим" тень
    ShowDialog();          // "нарисуем" диалог.
  }
}

// пересчитать координаты для элементов с DIF_CENTERGROUP
void Dialog::ProcessCenterGroup(void)
{
  int I, J;
  int Length,StartX;
  int Type;
  struct DialogItem *CurItem, *JCurItem;
  DWORD ItemFlags;

  for (I=0, CurItem=Item; I < ItemCount; I++, ++CurItem)
  {
    Type=CurItem->Type;
    ItemFlags=CurItem->Flags;

    // Последовательно объявленные элементы с флагом DIF_CENTERGROUP
    // и одинаковой вертикальной позицией будут отцентрированы в диалоге.
    // Их координаты X не важны. Удобно использовать для центрирования
    // групп кнопок.
    if ((ItemFlags & DIF_CENTERGROUP) &&
        (I==0 ||
          (I > 0 &&
            ((Item[I-1].Flags & DIF_CENTERGROUP)==0 ||
             Item[I-1].Y1!=CurItem->Y1)
          )
        )
       )
    {
      Length=0;

      for (J=I, JCurItem=&Item[J]; J < ItemCount &&
                (JCurItem->Flags & DIF_CENTERGROUP) &&
                JCurItem->Y1==CurItem->Y1; J++, ++JCurItem)
      {
        Length+=LenStrItem(J);

        if (JCurItem->Type==DI_BUTTON && *JCurItem->Data!=' ')
          Length+=2;
      }

      if (Type==DI_BUTTON && *CurItem->Data!=' ')
        Length-=2;

      StartX=(X2-X1+1-Length)/2;

      if (StartX<0)
        StartX=0;

      for (J=I, JCurItem=&Item[J]; J < ItemCount &&
                (JCurItem->Flags & DIF_CENTERGROUP) &&
                JCurItem->Y1==CurItem->Y1; J++, ++JCurItem)
      {
        JCurItem->X1=StartX;
        StartX+=LenStrItem(J);

        if (JCurItem->Type==DI_BUTTON && *JCurItem->Data!=' ')
          StartX+=2;
      }
    }
  }
}

//////////////////////////////////////////////////////////////////////////
/* Public:
   Инициализация элементов диалога.
*/
/* $ 28.07.2000 SVS
   Теперь InitDialogObjects возвращает ID элемента
   с фокусом ввода
*/
/* $ 24.08.2000 SVS
  InitDialogObjects имеет параметр - для выборочной реинициализации
  элементов. ID = -1 - касаемо всех объектов
*/
int Dialog::InitDialogObjects(int ID)
{
  int I, J;
  int Length,StartX;
  int Type;
  struct DialogItem *CurItem;
  int InitItemCount;
  DWORD ItemFlags;

  _DIALOG(CleverSysLog CL("Init Dialog"));

  if(ID+1 > ItemCount)
    return -1;

  if(ID == -1) // инициализируем все?
  {
    ID=0;
    InitItemCount=ItemCount;
  }
  else
  {
    InitItemCount=ID+1;
  }

  /* 04.01.2001 SVS
     если FocusPos в пределах и элемент задисаблен, то ищем сначала. */
  if(FocusPos >= 0 && FocusPos < ItemCount &&
     (Item[FocusPos].Flags&(DIF_DISABLE|DIF_NOFOCUS|DIF_HIDDEN)))
    FocusPos = -1; // будем искать сначала!
  /* SVS $ */

  // предварительный цикл по поводу кнопок
  for(I=ID, CurItem=&Item[I]; I < InitItemCount; I++, ++CurItem)
  {
    ItemFlags=CurItem->Flags;
    Type=CurItem->Type;

    // для кнопок не имеющи стиля "Показывает заголовок кнопки без скобок"
    //  добавим энти самые скобки
    if (Type==DI_BUTTON &&
        (ItemFlags & DIF_NOBRACKETS)==0 &&
        *CurItem->Data != '[')
    {
      char BracketedTitle[200];
      sprintf(BracketedTitle,"[ %s ]",CurItem->Data);
      strcpy(CurItem->Data,BracketedTitle);
    }

     // предварительный поик фокуса
     if(FocusPos == -1 &&
        IsFocused(Type) &&
        CurItem->Focus &&
        !(ItemFlags&(DIF_DISABLE|DIF_NOFOCUS|DIF_HIDDEN)))
       FocusPos=I; // запомним первый фокусный элемент
     CurItem->Focus=0; // сбросим для всех, чтобы не оказалось,
                       //   что фокусов - как у дурочка фантиков

     // сбросим флаг DIF_CENTERGROUP для редакторов
     switch(Type)
     {
       case DI_BUTTON:
       case DI_CHECKBOX:
       case DI_RADIOBUTTON:
       case DI_TEXT:
         break;
       default:
         if(ItemFlags&DIF_CENTERGROUP)
           CurItem->Flags&=~DIF_CENTERGROUP;
     }
  }

  // Опять про фокус ввода - теперь, если "чудо" забыло выставить
  // хотя бы один, то ставим на первый подходящий
  if(FocusPos == -1)
  {
    for (I=0, CurItem=Item; I < ItemCount; I++, ++CurItem) // по всем!!!!
    {
      if(IsFocused(CurItem->Type) &&
         !(CurItem->Flags&(DIF_DISABLE|DIF_NOFOCUS|DIF_HIDDEN)))
      {
        FocusPos=I;
        break;
      }
    }
  }
  if(FocusPos == -1) // ну ни хрена себе - нет ни одного
  {                  //   элемента с возможностью фокуса
     FocusPos=0;     // убится, блин
  }

  // ну вот и добрались до!
  Item[FocusPos].Focus=1;

  // а теперь все сначала и по полной программе...
  ProcessCenterGroup(); // сначала отцентрируем
  for (I=ID, CurItem=&Item[I]; I < InitItemCount; I++, ++CurItem)
  {
    Type=CurItem->Type;
    ItemFlags=CurItem->Flags;

    /* $ 01.08.2000 SVS
       Обычный ListBox
    */
    if (Type==DI_LISTBOX)
    {
      if (!DialogMode.Check(DMODE_CREATEOBJECTS))
      {
        CurItem->ListPtr=new VMenu(NULL,NULL,0,CurItem->Y2-CurItem->Y1+1,
                        VMENU_ALWAYSSCROLLBAR|VMENU_LISTBOX,NULL/*,this*/);
        CurItem->OriginalListItems=CurItem->ListItems;
      }

      if(CurItem->ListPtr)
      {
        VMenu *ListPtr=CurItem->ListPtr;
        /* $ 13.09.2000 SVS
           + Флаг DIF_LISTNOAMPERSAND. По умолчанию для DI_LISTBOX &
             DI_COMBOBOX выставляется флаг MENU_SHOWAMPERSAND. Этот флаг
             подавляет такое поведение
        */
        /* $ 15.05.2001 KM
           ! Исправлена подсветка в DI_LISTBOX
        */
        /* $ 03.06.2001 KM
           ! Исправлена подсветка в DI_LISTBOX, теперь на самом деле :)
             для чего используется флаг DIF_LISTAUTOHIGHLIGHT.
        */
        if(!(ItemFlags&DIF_LISTNOAMPERSAND))
          ListPtr->SetFlags(VMENU_SHOWAMPERSAND);
        if(ItemFlags&DIF_LISTNOBOX)
          ListPtr->SetFlags(VMENU_SHOWNOBOX);
        if(ItemFlags&DIF_LISTWRAPMODE)
          ListPtr->SetFlags(VMENU_WRAPMODE);
        if(ItemFlags&DIF_LISTAUTOHIGHLIGHT)
          ListPtr->AssignHighlights(FALSE);
        ListPtr->SetPosition(X1+CurItem->X1,Y1+CurItem->Y1,
                             X1+CurItem->X2,Y1+CurItem->Y2);
        ListPtr->SetBoxType(SHORT_SINGLE_BOX);
        // удалим все итемы
        //ListBox->DeleteItems(); //???? А НАДО ЛИ ????
        if(CurItem->ListItems && !DialogMode.Check(DMODE_CREATEOBJECTS))
          ListPtr->AddItem(CurItem->ListItems);
        /* KM $ */
        /* KM $ */
      }
    }
    /* SVS $*/
    // "редакторы" - разговор особый...
    else if (IsEdit(Type))
    {
      // сбросим флаг DIF_EDITOR для строки ввода, отличной от DI_EDIT,
      // DI_FIXEDIT и DI_PSWEDIT
      if((ItemFlags&DIF_EDITOR) &&
         Type != DI_EDIT && Type != DI_FIXEDIT && Type != DI_PSWEDIT)
        ItemFlags&=~DIF_EDITOR;

      if (!DialogMode.Check(DMODE_CREATEOBJECTS))
      {
        CurItem->ObjPtr=new Edit;
        if(Type == DI_COMBOBOX)
        {
          CurItem->ListPtr=new VMenu("",NULL,0,8,VMENU_ALWAYSSCROLLBAR,NULL/*,Parent*/);
          CurItem->OriginalListItems=CurItem->ListItems;
        }
      }

      Edit *DialogEdit=(Edit *)CurItem->ObjPtr;
      DialogEdit->SetDialogParent((Type != DI_COMBOBOX && (ItemFlags & DIF_EDITOR))?
                                  EDPARENT_MULTILINE:EDPARENT_SINGLELINE);
      DialogEdit->ReadOnly=0;
      /* $ 26.07.2000 SVS
         Ну наконец-то - долгожданный нередактируемый ComboBox
      */
      /* $ 30.11.200? SVS
         Уточним на что влияет флаг DIF_DROPDOWNLIST
      */
      if (Type == DI_COMBOBOX)
      {
        CurItem->ListPtr->SetBoxType(SHORT_SINGLE_BOX);
        if(ItemFlags & DIF_DROPDOWNLIST)
           DialogEdit->DropDownBox=1;
        if(ItemFlags&DIF_LISTWRAPMODE)
          CurItem->ListPtr->SetFlags(VMENU_WRAPMODE);
        /* $ 15.05.2001 KM
           Добавим подсветку в DI_COMBOBOX
        */
        /* $ 03.06.2001 KM
           ! Исправлена подсветка в DI_COMBOBOX, теперь на самом деле :)
             для чего используется флаг DIF_LISTAUTOHIGHLIGHT.
        */
        if(!(ItemFlags&DIF_LISTNOAMPERSAND))
          CurItem->ListPtr->SetFlags(VMENU_SHOWAMPERSAND);
        if(ItemFlags&DIF_LISTAUTOHIGHLIGHT)
          CurItem->ListPtr->AssignHighlights(FALSE);
        /* $ 12.06.2001 KM
           ! Зачем-то была убрана инициализация DI_COMBOBOX через FarDialogItem
              Восстановлено!!!
        */
        if(CurItem->ListItems && !DialogMode.Check(DMODE_CREATEOBJECTS))
          CurItem->ListPtr->AddItem(CurItem->ListItems);
        /* KM $ */
        /* KM $ */
        /* KM $ */
      }

      /* SVS $ */
      /* SVS $ */
      /* $ 15.10.2000 tran
        строка редакторирование должна иметь максимум в 511 символов */
      // выставляем максимальный размер в том случае, если он еще не выставлен
      if(DialogEdit->GetMaxLength() == -1)
      {
        if((CurItem->Type==DI_EDIT || CurItem->Type==DI_COMBOBOX) &&
           (ItemFlags&DIF_VAREDIT))
          DialogEdit->SetMaxLength(CurItem->Ptr.PtrLength);
        else
          DialogEdit->SetMaxLength(511);
      }
      /* tran $ */
      DialogEdit->SetPosition(X1+CurItem->X1,Y1+CurItem->Y1,
                              X1+CurItem->X2,Y1+CurItem->Y2);
//      DialogEdit->SetObjectColor(
//         FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
//             ((ItemFlags&DIF_DISABLE)?COL_WARNDIALOGEDITDISABLED:COL_WARNDIALOGEDIT):
//             ((ItemFlags&DIF_DISABLE)?COL_DIALOGEDITDISABLED:COL_DIALOGEDIT)),
//         FarColorToReal((ItemFlags&DIF_DISABLE)?COL_DIALOGEDITDISABLED:COL_DIALOGEDITSELECTED));
      if (CurItem->Type==DI_PSWEDIT)
      {
        DialogEdit->SetPasswordMode(TRUE);
        /* $ 01.08.2000 SVS
          ...Что бы небыло повадно... и для повыщения защиты, т.с.
        */
        ItemFlags&=~DIF_HISTORY;
        /* SVS $ */
      }

      if (Type==DI_FIXEDIT)
      {
        /* $ 21.08.2000 SVS
           DIF_HISTORY имеет более высокий приоритет, чем DIF_MASKEDIT
        */
        if(ItemFlags&DIF_HISTORY)
          ItemFlags&=~DIF_MASKEDIT;
        /* SVS $ */
        // если DI_FIXEDIT, то курсор сразу ставится на замену...
        //   ай-ай - было недокументированно :-)
        DialogEdit->SetMaxLength(CurItem->X2-CurItem->X1+1);
        DialogEdit->SetOvertypeMode(TRUE);
        /* $ 12.08.2000 KM
           Если тип строки ввода DI_FIXEDIT и установлен флаг DIF_MASKEDIT
           и непустой параметр CurItem->Mask, то вызываем новую функцию
           для установки маски в объект Edit.
        */
        /* $ 18.09.2000 SVS
          Маска не должна быть пустой (строка из пробелов не учитывается)!
        */
        if ((ItemFlags & DIF_MASKEDIT) && CurItem->Mask)
        {
          char *Ptr=CurItem->Mask;
          while(*Ptr && *Ptr == ' ') ++Ptr;
          if(*Ptr)
            DialogEdit->SetInputMask(CurItem->Mask);
          else
          {
            CurItem->Mask=NULL;
            ItemFlags&=~DIF_MASKEDIT;
          }
        }
        /* SVS $ */
        /* KM $ */
      }
      else
        // "мини-редактор"
        // Последовательно определенные поля ввода (edit controls),
        // имеющие этот флаг группируются в редактор с возможностью
        // вставки и удаления строк
        if (!(ItemFlags & DIF_EDITOR))
        {
          DialogEdit->SetEditBeyondEnd(FALSE);
          if (!DialogMode.Check(DMODE_INITOBJECTS))
            DialogEdit->SetClearFlag(1);
        }

      /* $ 01.08.2000 SVS
         Еже ли стоит флаг DIF_USELASTHISTORY и непустая строка ввода,
         то подстанавливаем первое значение из History
      */
      if(CurItem->Type==DI_EDIT &&
        (ItemFlags&(DIF_HISTORY|DIF_USELASTHISTORY)) == (DIF_HISTORY|DIF_USELASTHISTORY))
      {
        /* $ 09.12.2001 DJ
           вынесем в отдельную функцию
        */
        ProcessLastHistory (CurItem, -1);
        /* DJ $ */
      }
      /* SVS $ */
      if((ItemFlags&DIF_MANUALADDHISTORY) && !(ItemFlags&DIF_HISTORY))
        ItemFlags&=~DIF_MANUALADDHISTORY; // сбросим нафиг.

      /* $ 18.03.2000 SVS
         Если это ComBoBox и данные не установлены, то берем из списка
         при условии, что хоть один из пунктов имеет Selected != 0
      */
      if (Type==DI_COMBOBOX &&
          (!(ItemFlags&DIF_VAREDIT) && CurItem->Data[0] == 0 ||
            (ItemFlags&DIF_VAREDIT) && *(char*)CurItem->Ptr.PtrData == 0) &&
          CurItem->ListItems)
      {
        struct FarListItem *ListItems=CurItem->ListItems->Items;
        int Length=CurItem->ListItems->ItemsNumber;

        //CurItem->ListPtr->AddItem(CurItem->ListItems);

        for (J=0; J < Length; J++)
        {
          if(ListItems[J].Flags & LIF_SELECTED)
          {
            // берем только первый пункт для области редактирования
            if(ItemFlags&DIF_VAREDIT)
              strncpy((char *)CurItem->Ptr.PtrData, ListItems[J].Text,CurItem->Ptr.PtrLength-1);
            else
              strncpy(CurItem->Data, ListItems[J].Text,sizeof(CurItem->Data)-1);
            break;
          }
        }
      }
      /* SVS $ */
      if((CurItem->Type==DI_EDIT || CurItem->Type==DI_COMBOBOX) &&
         (ItemFlags&DIF_VAREDIT))
        DialogEdit->SetString((char *)CurItem->Ptr.PtrData);
      else
        DialogEdit->SetString(CurItem->Data);

      if (Type==DI_FIXEDIT)
        DialogEdit->SetCurPos(0);

      /* $ 30.08.2001 VVM
        + Для обычных строк отрубим постоянные блоки */
      if (!(ItemFlags&DIF_EDITOR))
        DialogEdit->SetPersistentBlocks(Opt.DialogsEditBlock);
      /*  VVM $ */
      if(ItemFlags&DIF_READONLY)
        DialogEdit->ReadOnly=1;
    }
    else if (Type == DI_USERCONTROL)
    {
      if (!DialogMode.Check(DMODE_CREATEOBJECTS))
        CurItem->UCData=new DlgUserControl;
    }

    CurItem->Flags=ItemFlags;
  }
  // если будет редактор, то обязательно будет выделен.
  SelectOnEntry(FocusPos,TRUE);

  // все объекты созданы!
  DialogMode.Set(DMODE_CREATEOBJECTS);
  return FocusPos;
}
/* 24.08.2000 SVS $ */


/* $ 19.05.2001 DJ
   определение Title вытащено в отдельную функцию
*/

char *Dialog::GetDialogTitle()
{
  struct DialogItem *CurItem;
  int I;
  for(CurItem=Item,I=0; I < ItemCount; I++, CurItem++)
  {
    // по первому попавшемуся "тексту" установим заголовок консоли!
    if ((CurItem->Type==DI_TEXT ||
          CurItem->Type==DI_DOUBLEBOX ||
          CurItem->Type==DI_SINGLEBOX))
    {
      char *Ptr=CurItem->Data;
      for (; *Ptr; Ptr++)
        if (LocalIsalpha(*Ptr))
          return(Ptr);
    }
  }
  return "";
}

/* DJ $ */

/* $ 09.12.2001 DJ
   обработка DIF_USELASTHISTORY вынесена в отдельную функцию
*/

void Dialog::ProcessLastHistory (struct DialogItem *CurItem, int MsgIndex)
{
  char RegKey[NM];
  char *PtrData;
  int PtrLength;
  if(CurItem->Flags&DIF_VAREDIT)
  {
    PtrData  =(char *)CurItem->Ptr.PtrData;
    PtrLength=CurItem->Ptr.PtrLength;
  }
  else
  {
    PtrData  =CurItem->Data;
    PtrLength=sizeof(CurItem->Data);
  }
  if(!PtrData[0])
  {
    DWORD UseFlags;
    sprintf(RegKey,fmtSavedDialogHistory,(char*)CurItem->History);
    UseFlags=GetRegKey(RegKey,"Flags",1);
    if(UseFlags)
    {
      GetRegKey(RegKey,"Line0",PtrData,"",PtrLength);
      if (MsgIndex != -1)
      {
        // обработка DM_SETHISTORY => надо пропустить изменение текста через
        // диалоговую функцию
        Dialog::SendDlgMessage(this,DM_SETTEXTPTR,MsgIndex,(long)PtrData);
      }
    }
  }
}

/* DJ $ */

/* $ 30.05.2001 KM
   Изменение координат и/или размеров итема диалога.
*/
BOOL Dialog::SetItemRect(int ID,SMALL_RECT *Rect)
{
  if (ID >= ItemCount)
    return FALSE;

  DialogItem *CurItem=&Item[ID];
  int Type=CurItem->Type;

  /* $ 10.08.2001 KM
    - Ошибочно выставлялся X1 в 0 при Rect->Left=-1 (центрировать текст).
  */
  CurItem->X1=(short)Rect->Left;
  /* KM $ */
  CurItem->Y1=(Rect->Top<0)?0:Rect->Top;

  if (IsEdit(Type))
  {
      Edit *DialogEdit=(Edit *)CurItem->ObjPtr;
      CurItem->X2=(short)Rect->Right;
      CurItem->Y2=0;
      DialogEdit->SetPosition(X1+Rect->Left, Y1+Rect->Top,
                                   X1+Rect->Right,Y1+Rect->Top);
  }
  else if (Type==DI_LISTBOX)
  {
      CurItem->X2=(short)Rect->Right;
      CurItem->Y2=(short)Rect->Bottom;
      CurItem->ListPtr->SetPosition(X1+Rect->Left, Y1+Rect->Top,
                                    X1+Rect->Right,Y1+Rect->Bottom);
  }
  switch(Type)
  {
    case DI_DOUBLEBOX:
    case DI_SINGLEBOX:
    case DI_USERCONTROL:
      CurItem->X2=(short)Rect->Right;
      CurItem->Y2=(short)Rect->Bottom;
      break;
  }

  if(DialogMode.Check(DMODE_SHOW))
  {
    ShowDialog(-1);
    ScrBuf.Flush();
  }
  return TRUE;
}
/* KM $ */

BOOL Dialog::GetItemRect(int I,RECT& Rect)
{
  if(I >= ItemCount)
    return FALSE;

  struct DialogItem *CurItem=&Item[I];
  DWORD ItemFlags=CurItem->Flags;
  int Type=CurItem->Type;
  int Len;

  Rect.left=(int)CurItem->X1;
  Rect.top=(int)CurItem->Y1;
  Rect.right=(int)CurItem->X2;
  Rect.bottom=(int)CurItem->Y2;

  switch(Type)
  {
    case DI_COMBOBOX:
    case DI_EDIT:
    case DI_FIXEDIT:
    case DI_PSWEDIT:
    case DI_LISTBOX:
      break;
    default:
      Len=((ItemFlags & DIF_SHOWAMPERSAND)?strlen(CurItem->Data):HiStrlen(CurItem->Data));
      break;
  }

  switch(Type)
  {
    case DI_TEXT:
      if (CurItem->X1==(short)-1)
        Rect.left=(X2-X1+1-Len)/2;
      if(Rect.left < 0)
        Rect.left=0;

      if (CurItem->Y1==(short)-1)
        Rect.top=(Y2-Y1+1)/2;

      if(Rect.top < 0)
        Rect.top=0;

      Rect.bottom=Rect.top;
      Rect.right=Rect.left+Len;

      if (ItemFlags & (DIF_SEPARATOR|DIF_SEPARATOR2))
      {
        Rect.bottom=Rect.top;
        Rect.left=(!DialogMode.Check(DMODE_SMALLDIALOG)?3:0); //???
        Rect.right=X2-X1-(!DialogMode.Check(DMODE_SMALLDIALOG)?5:0); //???
      }
      break;

    case DI_VTEXT:
      if (CurItem->X1==(short)-1)
        Rect.left=(X2-X1+1)/2;
      if(Rect.left < 0)
        Rect.left=0;

      if (CurItem->Y1==(short)-1)
        Rect.top=(Y2-Y1+1-strlen(CurItem->Data))/2;

      if(Rect.top < 0)
        Rect.top=0;

      Rect.right=Rect.left;
      Rect.bottom=Rect.top+Len;
      /* Закроем до поры до времени.
      if (ItemFlags & (DIF_SEPARATOR|DIF_SEPARATOR2))
      {
        Rect.right=Rect.left;
        Rect.top=(!DialogMode.Check(DMODE_SMALLDIALOG)?1:0); //???
        Rect.bottom=Y2-Y1-(!DialogMode.Check(DMODE_SMALLDIALOG)?1:0); //???
        break;
      }
      */
      break;

    case DI_BUTTON:
      Rect.bottom=Rect.top;
      Rect.right=Rect.left+Len;
      break;

    case DI_CHECKBOX:
    case DI_RADIOBUTTON:
      Rect.bottom=Rect.top;
      Rect.right=Rect.left+Len+((Type == DI_CHECKBOX)?4:
                                 (ItemFlags & DIF_MOVESELECT?3:4)
                               );
      break;

    case DI_COMBOBOX:
    case DI_EDIT:
    case DI_FIXEDIT:
    case DI_PSWEDIT:
      Rect.bottom=Rect.top;
      break;
  }
  return TRUE;
}


//////////////////////////////////////////////////////////////////////////
/* Private:
   Получение данных и удаление "редакторов"
*/
void Dialog::DeleteDialogObjects()
{
  int I;
  struct DialogItem *CurItem;

  for (I=0, CurItem=Item; I < ItemCount; I++, ++CurItem)
  {
    switch(CurItem->Type)
    {
      case DI_EDIT:
      case DI_FIXEDIT:
      case DI_PSWEDIT:
      case DI_COMBOBOX:
        if(CurItem->ObjPtr)
          delete (Edit *)(CurItem->ObjPtr);
      case DI_LISTBOX:
        if((CurItem->Type == DI_COMBOBOX || CurItem->Type == DI_LISTBOX) &&
            CurItem->ListPtr)
           delete CurItem->ListPtr;
        break;
      case DI_USERCONTROL:
        if(CurItem->UCData)
          delete CurItem->UCData;
        break;
    }
    if(CurItem->Flags&DIF_AUTOMATION)
      if(CurItem->AutoPtr)
        free(CurItem->AutoPtr);
  }
}


//////////////////////////////////////////////////////////////////////////
/* Public:
   Сохраняет значение из полей редактирования.
   При установленном флаге DIF_HISTORY, сохраняет данные в реестре.
*/
void Dialog::GetDialogObjectsData()
{
  int I, Type;
  struct DialogItem *CurItem;

  for (I=0,CurItem=Item; I < ItemCount; I++, ++CurItem)
  {
    DWORD IFlags=CurItem->Flags;
    switch(Type=CurItem->Type)
    {
      case DI_EDIT:
      case DI_FIXEDIT:
      case DI_PSWEDIT:
      case DI_COMBOBOX:
      {
        if(CurItem->ObjPtr)
        {
          char *PtrData;
          int PtrLength;
          Edit *EditPtr=(Edit *)(CurItem->ObjPtr);
          // подготовим данные
          if((Type==DI_EDIT || Type==DI_COMBOBOX) && (IFlags&DIF_VAREDIT))
          {
            PtrData  =(char *)CurItem->Ptr.PtrData;
            PtrLength=CurItem->Ptr.PtrLength;
          }
          else
          {
            PtrData  =CurItem->Data;
            PtrLength=sizeof(CurItem->Data);
          }

          // получим данные
          EditPtr->GetString(PtrData,PtrLength);

          if (ExitCode >=0 &&
              (IFlags & DIF_HISTORY) &&
              !(IFlags & DIF_MANUALADDHISTORY) && // при мануале не добавляем
              CurItem->History &&
              Opt.DialogsEditHistory)
            AddToEditHistory(PtrData,CurItem->History);

          /* $ 01.08.2000 SVS
             ! В History должно заносится значение (для DIF_EXPAND...) перед
              расширением среды!
          */
          /*$ 05.07.2000 SVS $
          Проверка - этот элемент предполагает расширение переменных среды?
          т.к. функция GetDialogObjectsData() может вызываться самостоятельно
          Но надо проверить!*/
          /* $ 04.12.2000 SVS
            ! Для DI_PSWEDIT и DI_FIXEDIT обработка DIF_EDITEXPAND не нужна
             (DI_FIXEDIT допускается для случая если нету маски)
          */
          if((IFlags&DIF_EDITEXPAND) && Type != DI_PSWEDIT && Type != DI_FIXEDIT)
             ExpandEnvironmentStr(PtrData, PtrData,PtrLength-1);
          /* SVS $ */
          /* SVS $ */
          /* 01.08.2000 SVS $ */
        }
        break;
      }

      case DI_LISTBOX:
        if(CurItem->ListPtr)
        {
          CurItem->ListPos=CurItem->ListPtr->GetSelectPos();
          break;
        }
      /**/
    }

    if((Type == DI_COMBOBOX || Type == DI_LISTBOX) &&
       CurItem->ListPtr && CurItem->ListItems &&
       CurItem->OriginalListItems == CurItem->ListItems)
    {
      int ListPos=CurItem->ListPtr->GetSelectPos();
      if(ListPos < CurItem->ListItems->ItemsNumber)
      {
        for(int J=0; J < CurItem->ListItems->ItemsNumber; ++J)
          CurItem->ListItems->Items[J].Flags&=~LIF_SELECTED;
        CurItem->ListItems->Items[ListPos].Flags|=LIF_SELECTED;
      }
    }
  }
}


//////////////////////////////////////////////////////////////////////////
/* $ 22.08.2000 SVS
  ! ShowDialog - дополнительный параметр - какой элемент отрисовывать
*/
/* Private:
   Отрисовка элементов диалога на экране.
*/
void Dialog::ShowDialog(int ID)
{
  char Str[1024];
  struct DialogItem *CurItem;
  int X,Y;
  int I,DrawItemCount;
  unsigned long Attr;

  /* $ 18.08.2000 SVS
     Если не разрешена отрисовка, то вываливаем.
  */
  if(IsEnableRedraw ||                 // разрешена прорисовка ?
     (ID+1 > ItemCount) ||             // а номер в рамках дозволенного?
     DialogMode.Check(DMODE_DRAWING) || // диалог рисуется?
     !DialogMode.Check(DMODE_SHOW) ||   // если не видим, то и не отрисовываем.
     !DialogMode.Check(DMODE_INITOBJECTS))
    return;
  /* SVS $ */

  DialogMode.Set(DMODE_DRAWING);  // диалог рисуется!!!

  ChangePriority ChPriority(THREAD_PRIORITY_NORMAL);

  if(ID == -1) // рисуем все?
  {
    /* $ 28.07.2000 SVS
       Перед прорисовкой диалога посылаем сообщение в обработчик
    */
    if(!DlgProc((HANDLE)this,DN_DRAWDIALOG,0,0))
    {
      DialogMode.Skip(DMODE_DRAWING);  // конец отрисовки диалога!!!
      return;
    }
    /* SVS $ */

    /* $ 28.07.2000 SVS
       перед прорисовкой подложки окна диалога...
    */
    if(!DialogMode.Check(DMODE_SMALLDIALOG))
    {
      Attr=DlgProc((HANDLE)this,DN_CTLCOLORDIALOG,0,
          DialogMode.Check(DMODE_WARNINGSTYLE) ? COL_WARNDIALOGTEXT:COL_DIALOGTEXT);
      SetScreen(X1,Y1,X2,Y2,' ',Attr);
    }
    /* SVS $ */
  }

  if(ID == -1) // рисуем все?
  {
    ID=0;
    DrawItemCount=ItemCount;
  }
  else
  {
    DrawItemCount=ID+1;
  }

  for (I=ID,CurItem=&Item[I]; I < DrawItemCount; I++, ++CurItem)
  {
    if(CurItem->Flags&DIF_HIDDEN)
      continue;

    /* $ 28.07.2000 SVS
       Перед прорисовкой каждого элемента посылаем сообщение
       посредством функции SendDlgMessage - в ней делается все!
    */
    if(!Dialog::SendDlgMessage((HANDLE)this,DN_DRAWDLGITEM,I,0))
       continue;

    int LenText;
    short CX1=CurItem->X1;
    short CY1=CurItem->Y1;
    short CX2=CurItem->X2;
    short CY2=CurItem->Y2;
    short CW=CX2-CX1+1;
    BOOL DisabledItem=CurItem->Flags&DIF_DISABLE?TRUE:FALSE;

    switch(CurItem->Type)
    {
/* ***************************************************************** */
      case DI_SINGLEBOX:
      case DI_DOUBLEBOX:
      {
        Attr=MAKELONG(
          MAKEWORD(FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                      (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGBOXTITLE):
                      (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGBOXTITLE)), // Title LOBYTE
                 FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                      (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGHIGHLIGHTTEXT):
                      (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGHIGHLIGHTTEXT))),// HiText HIBYTE
          MAKEWORD(FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                  (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGBOX):
                  (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGBOX)), // Box LOBYTE
                 0)                                               // HIBYTE
        );
        Attr=DlgProc((HANDLE)this,DN_CTLCOLORDLGITEM,I,Attr);

        Box(X1+CX1,Y1+CY1,X1+CX2,Y1+CY2,
            LOBYTE(HIWORD(Attr)),
            (CurItem->Type==DI_SINGLEBOX) ? SINGLE_BOX:DOUBLE_BOX);

        if (*CurItem->Data)
        {
          /* $ 17.12.2001 KM
            ! Пусть диалог сам заботится о ширине собственного заголовка.
          */
          sprintf(Str," %s ",CurItem->Data);
          LenText=LenStrItem(I,Str);
          if(LenText > CW)
          {
            TruncStrFromEnd(Str,CW); // 5 ???
            strcat(Str," ");
            LenText=LenStrItem(I,Str);
          }

          X=X1+CX1+(CW-LenText)/2;

          if ((CurItem->Flags & DIF_LEFTTEXT) && X1+CX1+1 < X)
            X=X1+CX1+1;

          SetColor(Attr&0xFF);
          GotoXY(X,Y1+CY1);
          if (CurItem->Flags & DIF_SHOWAMPERSAND)
            Text(Str);
          else
            HiText(Str,HIBYTE(LOWORD(Attr)));
        }
        break;
      }

/* ***************************************************************** */
      case DI_TEXT:
      {
        strcpy(Str,CurItem->Data);
        LenText=LenStrItem(I,Str);
        Y=(CY1==-1)?(Y2-Y1+1)/2:CY1;
        X=(CX1==-1)?(X2-X1+1-LenText)/2:CX1;
        if(X < 0)
          X=0;

        if(X1+X+LenText > X2)
           Str[ObjWidth-1]=0;

        if (CurItem->Flags & DIF_SETCOLOR)
          Attr=CurItem->Flags & DIF_COLORMASK;
        else
          if (CurItem->Flags & DIF_BOXCOLOR)
            Attr=DialogMode.Check(DMODE_WARNINGSTYLE) ?
                  (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGBOX):
                  (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGBOX);
          else
            Attr=DialogMode.Check(DMODE_WARNINGSTYLE) ?
                  (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGTEXT):
                  (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGTEXT);

        Attr=MAKELONG(
           MAKEWORD(FarColorToReal(Attr),
                   FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                      (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGHIGHLIGHTTEXT):
                      (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGHIGHLIGHTTEXT))), // HIBYTE HiText
             0);
        Attr=DlgProc((HANDLE)this,DN_CTLCOLORDLGITEM,I,Attr);
        SetColor(Attr&0xFF);

        if (CurItem->Flags & (DIF_SEPARATOR|DIF_SEPARATOR2))
        {
          GotoXY(X1+(!DialogMode.Check(DMODE_SMALLDIALOG)?3:0),Y1+Y); //????
          if (DialogTooLong)
            ShowSeparator(DialogTooLong-(!DialogMode.Check(DMODE_SMALLDIALOG)?5:0),(CurItem->Flags&DIF_SEPARATOR2?3:1));
          else
            ShowSeparator(X2-X1-(!DialogMode.Check(DMODE_SMALLDIALOG)?5:0),(CurItem->Flags&DIF_SEPARATOR2?3:1));
        }

        GotoXY(X1+X,Y1+Y);

        if (CurItem->Flags & DIF_SHOWAMPERSAND)
          Text(Str);
        else
          HiText(Str,HIBYTE(LOWORD(Attr)));
        break;
      }

/* ***************************************************************** */
      case DI_VTEXT:
      {
        strncpy(Str,CurItem->Data,sizeof(Str)-1);
        X=(CX1==-1)?(X2-X1+1)/2:CX1;
        Y=(CY1==-1)?(Y2-Y1+1-strlen(Str))/2:CY1;
        if(Y < 0)
          Y=0;

        if(Y1+Y+LenText > Y2)
          Str[ObjHeight-1]=0;

        if (CurItem->Flags & DIF_BOXCOLOR)
          Attr=DialogMode.Check(DMODE_WARNINGSTYLE) ?
                   (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGBOX):
                   (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGBOX);
        else
          if (CurItem->Flags & DIF_SETCOLOR)
            Attr=(CurItem->Flags & DIF_COLORMASK);
          else
            Attr=(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                   (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGTEXT):
                   (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGTEXT));

        Attr=DlgProc((HANDLE)this,DN_CTLCOLORDLGITEM,I,FarColorToReal(Attr));
        SetColor(Attr&0xFF);

        /* Закроем до поры до времени.
        if (CurItem->Flags & (DIF_SEPARATOR|DIF_SEPARATOR2))
        {
          GotoXY(X1+X,Y1+(!DialogMode.Check(DMODE_SMALLDIALOG)?1:0)); //????
          if (DialogTooLong)
            ShowSeparator(DialogTooLong-(!DialogMode.Check(DMODE_SMALLDIALOG)?1:0),5);
          else
            ShowSeparator(Y2-Y1-(!DialogMode.Check(DMODE_SMALLDIALOG)?1:0),5);
        }
        */

        GotoXY(X1+X,Y1+Y);
        VText(Str);
        break;
      }

/* ***************************************************************** */
      case DI_CHECKBOX:
      case DI_RADIOBUTTON:
      {
        if (CurItem->Flags & DIF_SETCOLOR)
          Attr=(CurItem->Flags & DIF_COLORMASK);
        else
          Attr=(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                  (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGTEXT):
                  (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGTEXT));

        Attr=MAKEWORD(FarColorToReal(Attr),
             FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                   (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGHIGHLIGHTTEXT):
                   (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGHIGHLIGHTTEXT))); // HiText
        Attr=DlgProc((HANDLE)this,DN_CTLCOLORDLGITEM,I,Attr);

        SetColor(Attr&0xFF);

        GotoXY(X1+CX1,Y1+CY1);
        if (CurItem->Type==DI_CHECKBOX)
        {
          char *Chk3State=MSG(MCheckBox2State);
          sprintf(Str,"[%c] ",CurItem->Selected ?
             (((CurItem->Flags&DIF_3STATE) && CurItem->Selected == 2)?
                *Chk3State:'x'):' ');
        }
        else
        {
          if (CurItem->Flags & DIF_MOVESELECT)
            sprintf(Str," %c ",CurItem->Selected ? '\07':' ');
          else
            sprintf(Str,"(%c) ",CurItem->Selected ? '\07':' ');
        }

        strncat(Str,CurItem->Data,sizeof(Str)-1);
        LenText=LenStrItem(I,Str);
        if(X1+CX1+LenText > X2)
          Str[ObjWidth-1]=0;

        if (CurItem->Flags & DIF_SHOWAMPERSAND)
          Text(Str);
        else
          HiText(Str,HIBYTE(LOWORD(Attr)));

        if (CurItem->Focus)
        {
          /* $ 09.08.2000 KM
             Отключение мигающего курсора при перемещении диалога
          */
          if (!DialogMode.Check(DMODE_DRAGGED))
            SetCursorType(1,-1);
          MoveCursor(X1+CX1+1,Y1+CY1);
          /* KM $ */
        }

        break;
      }

/* ***************************************************************** */
      case DI_BUTTON:
      {
        GotoXY(X1+CX1,Y1+CY1);

        /* $ 18.08.2000 SVS
           + DI_BUTTON тоже теперь может иметь DIF_SETCOLOR
        */
        if (CurItem->Focus)
        {
          SetCursorType(0,10);
          Attr=MAKEWORD(
             (CurItem->Flags & DIF_SETCOLOR)?(CurItem->Flags & DIF_COLORMASK):
               FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                   (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGSELECTEDBUTTON):
                   (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGSELECTEDBUTTON)), // TEXT
             FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                   (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGHIGHLIGHTSELECTEDBUTTON):
                   (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGHIGHLIGHTSELECTEDBUTTON))); // HiText
        }
        else
        {
          Attr=MAKEWORD(
             (CurItem->Flags & DIF_SETCOLOR)?(CurItem->Flags & DIF_COLORMASK):
               FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                      (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGBUTTON):
                      (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGBUTTON)), // TEXT
             FarColorToReal(DialogMode.Check(DMODE_WARNINGSTYLE) ?
                      (DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGHIGHLIGHTBUTTON):
                      (DisabledItem?COL_DIALOGDISABLED:COL_DIALOGHIGHLIGHTBUTTON))); // HiText
        }
        /* SVS $ */
        Attr=DlgProc((HANDLE)this,DN_CTLCOLORDLGITEM,I,Attr);
        SetColor(Attr&0xFF);

        strncpy(Str,CurItem->Data,sizeof(Str)-1);
        //LenText=LenStrItem(I,Str);
        /*
           Здесь, для отсечения, необходимо учесть флаг DIF_NOBRACKETS
           Т.е. с флагом DIF_NOBRACKETS кнопка рисуется как "%s", без
           этого флага - "[ %s ]"
        */

        if (CurItem->Flags & DIF_SHOWAMPERSAND)
          Text(Str);
        else
          HiText(Str,HIBYTE(LOWORD(Attr)));
        break;
      }

/* ***************************************************************** */
      /* $ 18.07.2000 SVS
         + обработка элемента DI_COMBOBOX
      */
      case DI_EDIT:
      case DI_FIXEDIT:
      case DI_PSWEDIT:
      case DI_COMBOBOX:
      {
        Edit *EditPtr=(Edit *)(CurItem->ObjPtr);
        if(!EditPtr)
          break;

        /* $ 15.08.2000 SVS
           ! Для DropDownList цвета обрабатываем по иному
        */
        if(CurItem->Type == DI_COMBOBOX && (CurItem->Flags & DIF_DROPDOWNLIST))
        {
          if(DialogMode.Check(DMODE_WARNINGSTYLE))
            Attr=MAKELONG(
              MAKEWORD( //LOWORD
                // LOLO (Text)
                FarColorToReal(DisabledItem?COL_WARNDIALOGEDITDISABLED:COL_WARNDIALOGEDIT),
                // LOHI (Select)
                FarColorToReal(DisabledItem?COL_DIALOGEDITDISABLED:COL_DIALOGEDITSELECTED)
              ),
              MAKEWORD( //HIWORD
                // HILO (Unchanged)
                FarColorToReal(COL_DIALOGEDITUNCHANGED),
                // HIHI (History)
                FarColorToReal(DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGTEXT)
              )
            );
          else
            Attr=MAKELONG(
              MAKEWORD( //LOWORD
                // LOLO (Text)
                FarColorToReal(DisabledItem?COL_DIALOGEDITDISABLED:(!CurItem->Focus?COL_DIALOGEDIT:COL_DIALOGEDITSELECTED)),
                // LOHI (Select)
                FarColorToReal(DisabledItem?COL_DIALOGEDITDISABLED:(!CurItem->Focus?COL_DIALOGEDIT:COL_DIALOGEDITSELECTED))
              ),
              MAKEWORD( //HIWORD
                // HILO (Unchanged)
                FarColorToReal(COL_DIALOGEDITUNCHANGED),
                // HIHI (History)
                FarColorToReal(DisabledItem?COL_DIALOGDISABLED:COL_DIALOGTEXT)
              )
            );
        }
        else
        {
          if(DialogMode.Check(DMODE_WARNINGSTYLE))
            Attr=MAKELONG(
              MAKEWORD( //LOWORD
                // LOLO (Text)
                FarColorToReal(DisabledItem?COL_WARNDIALOGEDITDISABLED:
                  (CurItem->Flags&DIF_NOFOCUS?COL_DIALOGEDITUNCHANGED:COL_WARNDIALOGEDIT)),
                // LOHI (Select)
                FarColorToReal(DisabledItem?COL_DIALOGEDITDISABLED:COL_DIALOGEDITSELECTED)
              ),
              MAKEWORD( //HIWORD
                // HILO (Unchanged)
                FarColorToReal(COL_DIALOGEDITUNCHANGED),
                // HIHI (History)
                FarColorToReal(DisabledItem?COL_WARNDIALOGDISABLED:COL_WARNDIALOGTEXT)
              )
            );
          else
            Attr=MAKELONG(
              MAKEWORD( //LOWORD
                // LOLO (Text)
                FarColorToReal(DisabledItem?COL_DIALOGEDITDISABLED:
                  (CurItem->Flags&DIF_NOFOCUS?COL_DIALOGEDITUNCHANGED:COL_DIALOGEDIT)),
                // LOHI (Select)
                FarColorToReal(DisabledItem?COL_DIALOGEDITDISABLED:COL_DIALOGEDITSELECTED)
              ),
              MAKEWORD( //HIWORD
                // HILO (Unchanged)
                FarColorToReal(COL_DIALOGEDITUNCHANGED),
                // HIHI (History)
                FarColorToReal(DisabledItem?COL_DIALOGDISABLED:COL_DIALOGTEXT)
              )
            );
        }
        /* SVS $ */
        /* SVS $ */
        Attr=DlgProc((HANDLE)this,DN_CTLCOLORDLGITEM,I,Attr);

        EditPtr->SetObjectColor(Attr&0xFF,HIBYTE(LOWORD(Attr)),LOBYTE(HIWORD(Attr)));

        if (CurItem->Focus)
        {
          /* $ 09.08.2000 KM
             Отключение мигающего курсора при перемещении диалога
          */
          if (!DialogMode.Check(DMODE_DRAGGED))
            SetCursorType(1,-1);
          EditPtr->Show();
          /* KM $ */
        }
        else
        {
          EditPtr->FastShow();
          EditPtr->SetLeftPos(0);
        }

        /* $ 09.08.2000 KM
           Отключение мигающего курсора при перемещении диалога
        */
        if (DialogMode.Check(DMODE_DRAGGED))
          SetCursorType(FALSE,0);
        /* KM $ */

        if (CurItem->History && ((CurItem->Flags & DIF_HISTORY) && Opt.DialogsEditHistory ||
            CurItem->Type == DI_COMBOBOX))
        {
          int EditX1,EditY1,EditX2,EditY2;

          EditPtr->GetPosition(EditX1,EditY1,EditX2,EditY2);
          //Text((CurItem->Type == DI_COMBOBOX?"\x1F":"\x19"));
          Text(EditX2+1,EditY1,HIBYTE(HIWORD(Attr)),"\x19");
        }
        break;
        /* SVS $ */
      }

/* ***************************************************************** */
      /* $ 01.08.2000 SVS
         Обычный ListBox
      */
      case DI_LISTBOX:
      {
        if(CurItem->ListPtr)
        {
          /* $ 21.08.2000 SVS
             Перед отрисовкой спросим об изменении цветовых атрибутов
          */
          short Colors[VMENU_COLOR_COUNT];
          CurItem->ListPtr->GetColors(Colors);
          if(DlgProc((HANDLE)this,DN_CTLCOLORDLGLIST,
                          sizeof(Colors)/sizeof(Colors[0]),(long)Colors))
            CurItem->ListPtr->SetColors(Colors);
          /* SVS $ */
          if (CurItem->Focus)
            CurItem->ListPtr->Show();
          else
            CurItem->ListPtr->FastShow();
        }
        break;
      }
      /* 01.08.2000 SVS $ */


/* ***************************************************************** */
      case DI_USERCONTROL:
        if(CurItem->VBuf)
        {
          PutText(X1+CX1,Y1+CY1,X1+CX2,Y1+CY2,CurItem->VBuf);
          // не забудим переместить курсор, если он спозиционирован.
          if(FocusPos == I)
          {
            if(CurItem->UCData->CursorPos.X != -1 &&
               CurItem->UCData->CursorPos.Y != -1)
            {
              MoveCursor(CurItem->UCData->CursorPos.X+CX1+X1,CurItem->UCData->CursorPos.Y+CY1+Y1);
              SetCursorType(CurItem->UCData->CursorVisible,CurItem->UCData->CursorSize);
            }
            else
              SetCursorType(0,-1);
          }
        }
        break; //уже наприсовали :-)))

/* ***************************************************************** */
    } // end switch(...
  } // end for (I=...

  // КОСТЫЛЬ!
  // но работает ;-)
  for (I=0; I < ItemCount; I++)
  {
    CurItem=&Item[I];
    if(CurItem->ListPtr && GetDropDownOpened() && CurItem->ListPtr->IsVisible())
    {
      if((CurItem->Type == DI_COMBOBOX) ||
         ((CurItem->Type == DI_EDIT || CurItem->Type == DI_FIXEDIT) &&
         !(CurItem->Flags&DIF_HIDDEN) &&
         (CurItem->Flags&DIF_HISTORY)))
      {
        CurItem->ListPtr->Show();
      }
    }
  }
  /* $ 31.07.2000 SVS
     Включим индикатор перемещения...
  */
  if ( DialogMode.Check(DMODE_DRAGGED) ) // если диалог таскается
  {
    DlgProc((HANDLE)this,DN_DRAWDIALOG,1,0);
  }
  else
  {
    /* $ 03.06.2001 KM
       + При каждой перерисовке диалога, кроме режима перемещения, устанавливаем
         заголовок консоли, в противном случае он не всегда восстанавливался.
    */
    SetFarTitle(GetDialogTitle());
    /* KM $ */
  }
  /* SVS $ */

  DialogMode.Skip(DMODE_DRAWING);  // конец отрисовки диалога!!!
  DialogMode.Set(DMODE_SHOW); // диалог на экране!
}
/* SVS 22.08.2000 $ */

int Dialog::LenStrItem(int ID,char *Str)
{
  if(!Str)
    Str=Item[ID].Data;
  return (Item[ID].Flags & DIF_SHOWAMPERSAND)?strlen(Str):HiStrlen(Str);
}

//////////////////////////////////////////////////////////////////////////
/* Public, Virtual:
   Обработка данных от клавиатуры.
   Перекрывает BaseInput::ProcessKey.
*/
int Dialog::ProcessKey(int Key)
{
  int I,J;
  char Str[1024];
  Edit *CurEditLine;

  if (Key==KEY_NONE || Key==KEY_IDLE)
  {
    /* $ 28.07.2000 SVS
       Передадим этот факт в обработчик :-)
    */
    DlgProc((HANDLE)this,DN_ENTERIDLE,0,0);
    /* SVS $ */
    return(FALSE);
  }

  /* $ 31.07.2000 tran
     + перемещение диалога по экрану */
  if (DialogMode.Check(DMODE_DRAGGED)) // если диалог таскается
  {
    int rr=1;
    /* $ 15.12.2000 SVS
       При перемещении диалога повторяем поведение "бормандовых" сред.
    */
    switch (Key)
    {
        case KEY_CTRLLEFT:
        case KEY_CTRLHOME:
        case KEY_HOME:
            rr=Key == KEY_CTRLLEFT?10:X1;
        case KEY_LEFT:
            Hide();
            for ( I=0; I<rr; I++ )
                if ( X1>0 )
                {
                    X1--;
                    X2--;
                    AdjustEditPos(-1,0);
                }
            if(!DialogMode.Check(DMODE_ALTDRAGGED)) Show();
            break;
        case KEY_CTRLRIGHT:
        case KEY_CTRLEND:
        case KEY_END:
            rr=Key == KEY_CTRLRIGHT?10:abs(X1-(ScrX - (X2-X1+1)))+1;
        case KEY_RIGHT:
            Hide();
            for ( I=0; I<rr; I++ )
                if ( X2<ScrX )
                {
                    X1++;
                    X2++;
                    AdjustEditPos(1,0);
                }
            if(!DialogMode.Check(DMODE_ALTDRAGGED)) Show();
            break;
        case KEY_PGUP:
        case KEY_CTRLPGUP:
        case KEY_CTRLUP:
            rr=Key == KEY_CTRLUP?5:Y1;
        case KEY_UP:
            Hide();
            for ( I=0; I<rr; I++ )
                if ( Y1>0 )
                {
                    Y1--;
                    Y2--;
                    AdjustEditPos(0,-1);
                }
            if(!DialogMode.Check(DMODE_ALTDRAGGED)) Show();
            break;
        case KEY_CTRLDOWN:
        case KEY_CTRLPGDN:
        case KEY_PGDN:
            rr=Key == KEY_CTRLDOWN? 5: abs(Y1-(ScrY - (Y2-Y1+1)))+1;
        case KEY_DOWN:
            Hide();
            for ( I=0; I<rr; I++ )
                if ( Y2<ScrY )
                {
                    Y1++;
                    Y2++;
                    AdjustEditPos(0,1);
                }
            if(!DialogMode.Check(DMODE_ALTDRAGGED)) Show();
            break;
        case KEY_ENTER:
        case KEY_CTRLF5:
            DialogMode.Skip(DMODE_DRAGGED); // закончим движение!
            if(!DialogMode.Check(DMODE_ALTDRAGGED))
            {
              DlgProc((HANDLE)this,DN_DRAGGED,1,0);
              Show();
            }
            break;
        case KEY_ESC:
            Hide();
            AdjustEditPos(OldX1-X1,OldY1-Y1);
            X1=OldX1;
            X2=OldX2;
            Y1=OldY1;
            Y2=OldY2;
            DialogMode.Skip(DMODE_DRAGGED);
            if(!DialogMode.Check(DMODE_ALTDRAGGED))
            {
              DlgProc((HANDLE)this,DN_DRAGGED,1,TRUE);
              Show();
            }
            break;
    }
    /* SVS $ */
    if(DialogMode.Check(DMODE_ALTDRAGGED))
    {
      DialogMode.Skip(DMODE_DRAGGED|DMODE_ALTDRAGGED);
      DlgProc((HANDLE)this,DN_DRAGGED,1,0);
      Show();
    }
    return (TRUE);
  }
  /* $ 10.08.2000 SVS
     Двигаем, если разрешено! (IsCanMove)
  */
  if (Key == KEY_CTRLF5 && DialogMode.Check(DMODE_ISCANMOVE))
  /* SVS 10.08.2000 $*/
  {
    if(DlgProc((HANDLE)this,DN_DRAGGED,0,0)) // если разрешили перемещать!
    {
      // включаем флаг и запоминаем координаты
      DialogMode.Set(DMODE_DRAGGED);
      OldX1=X1; OldX2=X2; OldY1=Y1; OldY2=Y2;
      //# GetText(0,0,3,0,LV);
      Show();
    }
    return (TRUE);
  }
  /* tran 31.07.2000 $ */

  // "ХАчу глянуть на то, что под диалогом..."
/* $ KEY_CTRLALTSHIFTPRESS унесено в manager OT */

  int Type=Item[FocusPos].Type;

  if(!DialogMode.Check(DMODE_KEY))
    if(DlgProc((HANDLE)this,DM_KEY,FocusPos,Key))
      return TRUE;

  // небольшая оптимизация
  if(Type==DI_CHECKBOX)
  {
    if(!(Item[FocusPos].Flags&DIF_3STATE))
    {
      if((Key == KEY_ADD      && !Item[FocusPos].Selected) ||
         (Key == KEY_SUBTRACT &&  Item[FocusPos].Selected))
       Key=KEY_SPACE;
    }
    /*
      блок else не нужен, т.к. ниже клавиши будут обработаны...
    */
  }
  else if(Key == KEY_ADD)
    Key='+';
  else if(Key == KEY_SUBTRACT)
    Key='-';
  else if(Key == KEY_MULTIPLY)
    Key='*';

  if(Type == DI_LISTBOX)
  {
    switch(Key)
    {
      case KEY_HOME:
      case KEY_LEFT:
      case KEY_END:
      case KEY_RIGHT:
      case KEY_UP:
      case KEY_DOWN:
      case KEY_PGUP:
      case KEY_PGDN:
      case KEY_MSWHEEL_UP:
      case KEY_MSWHEEL_DOWN:
        VMenu *List=Item[FocusPos].ListPtr;
        int CurListPos=List->GetSelectPos();
        int CheckedListItem=List->GetSelection(-1);
        List->ProcessKey(Key);
        int NewListPos=List->GetSelectPos();
        if(NewListPos != CurListPos)
          if(!DlgProc((HANDLE)this,DN_LISTCHANGE,FocusPos,NewListPos))
          {
            List->SetSelection(CheckedListItem,CurListPos);
            if(DialogMode.Check(DMODE_SHOW) && !(Item[FocusPos].Flags&DIF_HIDDEN))
              ShowDialog(FocusPos);
          }
        return(TRUE);
    }
  }

  /* $ 23.05.2001 VVM
    ! Ну невозможно работать с диалгами стало. */
//  if(Key == KEY_DOWN && Type == DI_COMBOBOX && (Item[FocusPos].Flags&DIF_DROPDOWNLIST))
//    Key=KEY_CTRLDOWN;
  /* VVM $ */

  switch(Key)
  {
    case KEY_F1:
      // Перед выводом диалога посылаем сообщение в обработчик
      //   и если вернули что надо, то выводим подсказку
      if(Help::MkTopic(PluginNumber,
                 (char*)DlgProc((HANDLE)this,DN_HELP,FocusPos,
                                (HelpTopic?(long)HelpTopic:NULL)),
                 Str))
      {
        Help Hlp (Str);
      }
      return(TRUE);

    case KEY_TAB:
    case KEY_SHIFTTAB:
// Здесь с фокусом ОООЧЕНЬ ТУМАННО!!!
      if (Item[FocusPos].Flags & DIF_EDITOR)
      {
        I=FocusPos;
        while (Item[I].Flags & DIF_EDITOR)
          I=ChangeFocus(I,(Key==KEY_TAB) ? 1:-1,TRUE);
      }
      else
      {
        I=ChangeFocus(FocusPos,(Key==KEY_TAB) ? 1:-1,TRUE);
        if (Key==KEY_SHIFTTAB)
          while (I>0 && (Item[I].Flags & DIF_EDITOR)!=0 &&
                 (Item[I-1].Flags & DIF_EDITOR)!=0 &&
                 ((Edit *)Item[I].ObjPtr)->GetLength()==0)
            I--;
      }
      ChangeFocus2(FocusPos,I);
      ShowDialog();
      return(TRUE);

    case KEY_CTRLENTER:
      for (I=0;I<ItemCount;I++)
        if (Item[I].DefaultButton)
        {
          if(Item[I].Flags&DIF_DISABLE)
          {
             // ProcessKey(KEY_DOWN); // на твой вкус :-)
             return TRUE;
          }
          if (!IsEdit(Item[I].Type))
            Item[I].Selected=1;
          ExitCode=I;
          /* $ 18.05.2001 DJ */
          CloseDialog();
          /* DJ $ */
          return(TRUE);
        }
      if(!DialogMode.Check(DMODE_OLDSTYLE))
      {
        DialogMode.Skip(DMODE_ENDLOOP); // только если есть
        return TRUE; // делать больше не чего
      }

    case KEY_ENTER:
      if ((Item[FocusPos].Flags & DIF_EDITOR) && !(Item[FocusPos].Flags & DIF_READONLY))
      {
        int EditorLastPos;
        for (EditorLastPos=I=FocusPos;I<ItemCount;I++)
          if (IsEdit(Item[I].Type) && (Item[I].Flags & DIF_EDITOR))
            EditorLastPos=I;
          else
            break;
        if (((Edit *)(Item[EditorLastPos].ObjPtr))->GetLength()!=0)
          return(TRUE);
        for (I=EditorLastPos;I>FocusPos;I--)
        {
          int CurPos;
          if (I==FocusPos+1)
            CurPos=((Edit *)(Item[I-1].ObjPtr))->GetCurPos();
          else
            CurPos=0;
          ((Edit *)(Item[I-1].ObjPtr))->GetString(Str,sizeof(Str));
          int Length=strlen(Str);
          ((Edit *)(Item[I].ObjPtr))->SetString(CurPos>=Length ? "":Str+CurPos);
          if (CurPos<Length)
            Str[CurPos]=0;
          ((Edit *)(Item[I].ObjPtr))->SetCurPos(0);
          ((Edit *)(Item[I-1].ObjPtr))->SetString(Str);
          /* $ 28.07.2000 SVS
            При изменении состояния каждого элемента посылаем сообщение
            посредством функции SendDlgMessage - в ней делается все!
          */
          Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,I-1,0);
          Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,I,0);
          /* SVS $ */
        }
        if (EditorLastPos>FocusPos)
        {
          ((Edit *)(Item[FocusPos].ObjPtr))->SetCurPos(0);
          ProcessKey(KEY_DOWN);
        }
        else
        {
          ShowDialog();
        }
        return(TRUE);
      }
      else if (Type==DI_BUTTON)
      {
        /* $ 21.08.2000 SVS
           Нет срабатывания, если давим на кнопку
        */
        Item[FocusPos].Selected=1;
        // сообщение - "Кнокна кликнута"
        if(Dialog::SendDlgMessage((HANDLE)this,DN_BTNCLICK,FocusPos,0))
          return TRUE;
        /* $ 06.12.2000 SVS
           Если не старый стиль и кнопка "не для закрытия" (DIF_BTNNOCLOSE), то
           вываливаемся, иначе - предлагаем закрыть диалог.
        */
        if(!DialogMode.Check(DMODE_OLDSTYLE) && (Item[FocusPos].Flags&DIF_BTNNOCLOSE))
          return(TRUE);

        ExitCode=FocusPos;
        /* $ 18.05.2001 DJ */
        CloseDialog();
        /* DJ $ */
        /* SVS $ */
        /* SVS $ */
      }
#if 0
      else if(IsEdit(Type) || DialogMode.Check(DMODE_OLDSTYLE))
      {
        for (I=0;I<ItemCount;I++)
          if (Item[I].DefaultButton)
          {
            if (!IsEdit(Item[I].Type))
              Item[I].Selected=1;
            ExitCode=I;
          }

        DialogMode.Set(DMODE_ENDLOOP);
        if (ExitCode==-1)
          ExitCode=FocusPos;
      }
#else
      else
      {
        ExitCode=-1;
        for (I=0;I<ItemCount;I++)
          if (Item[I].DefaultButton && !(Item[I].Flags&DIF_BTNNOCLOSE))
          {
            if(Item[I].Flags&DIF_DISABLE)
            {
               // ProcessKey(KEY_DOWN); // на твой вкус :-)
               return TRUE;
            }
            if (!IsEdit(Item[I].Type))
              Item[I].Selected=1;
            ExitCode=I;
          }
      }

      if (ExitCode==-1)
        ExitCode=FocusPos;
      /* $ 18.05.2001 DJ */
      CloseDialog();
      /* DJ $ */
#endif
      return(TRUE);

    case KEY_ESC:
    case KEY_BREAK:
    case KEY_F10:
      ExitCode=(Key==KEY_BREAK) ? -2:-1;
      /* $ 18.05.2001 DJ */
      CloseDialog();
      /* DJ $ */
      return(TRUE);

    /* $ 04.12.2000 SVS
       3-х уровневое состояние
       Для чекбокса сюда попадем только в случае, если контрол
       имеет флаг DIF_3STATE
    */
    case KEY_ADD:
    case KEY_SUBTRACT:
    case KEY_MULTIPLY:
      if (Type==DI_CHECKBOX)
      {
        unsigned int CHKState=
           (Key == KEY_ADD?1:
            (Key == KEY_SUBTRACT?0:
             ((Key == KEY_MULTIPLY)?2:
              Item[FocusPos].Selected)));
        if(Item[FocusPos].Selected != CHKState)
          if(Dialog::SendDlgMessage((HANDLE)this,DN_BTNCLICK,FocusPos,CHKState))
          {
             Item[FocusPos].Selected=CHKState;
             ShowDialog();
          }
      }
      return(TRUE);
    /* SVS 22.11.2000 $ */

    case KEY_SPACE:
      if (Type==DI_BUTTON)
        return(ProcessKey(KEY_ENTER));
      else if (Type==DI_CHECKBOX)
      {
        /* $ 04.12.2000 SVS
           3-х уровневое состояние
        */
        int OldSelected=Item[FocusPos].Selected;

        if(Item[FocusPos].Flags&DIF_3STATE)
          (++Item[FocusPos].Selected)%=3;
        else
          Item[FocusPos].Selected = !Item[FocusPos].Selected;
        /* $ 28.07.2000 SVS
          При изменении состояния каждого элемента посылаем сообщение
           посредством функции SendDlgMessage - в ней делается все!
        */
        if(!Dialog::SendDlgMessage((HANDLE)this,DN_BTNCLICK,FocusPos,Item[FocusPos].Selected))
          Item[FocusPos].Selected = OldSelected;
        /* SVS $ */
        /* SVS 04.12.2000 $ */
        ShowDialog();
        return(TRUE);
      }
      else if (Type==DI_RADIOBUTTON)
      {
        int PrevRB=FocusPos;
        for (I=FocusPos;;I--)
        {
          if(I==0)
            break;

          if (Item[I].Type==DI_RADIOBUTTON && (Item[I].Flags & DIF_GROUP))
            break;

          if(Item[I-1].Type!=DI_RADIOBUTTON)
            break;
        }

        do
        {
          /* $ 28.07.2000 SVS
            При изменении состояния каждого элемента посылаем сообщение
            посредством функции SendDlgMessage - в ней делается все!
          */
          J=Item[I].Selected;
          Item[I].Selected=0;
          if(J)
          {
            PrevRB=I;
          }
          ++I;
          /* SVS $ */
        } while (I<ItemCount && Item[I].Type==DI_RADIOBUTTON &&
                 (Item[I].Flags & DIF_GROUP)==0);

        Item[FocusPos].Selected=1;
        /* $ 28.07.2000 SVS
          При изменении состояния каждого элемента посылаем сообщение
          посредством функции SendDlgMessage - в ней делается все!
        */
        if(!Dialog::SendDlgMessage((HANDLE)this,DN_BTNCLICK,PrevRB,0) ||
           !Dialog::SendDlgMessage((HANDLE)this,DN_BTNCLICK,FocusPos,1))
        {
           // вернем назад, если пользователь не захотел...
           Item[FocusPos].Selected=0;
           Item[PrevRB].Selected=1;
        }
        /* SVS $ */
        ShowDialog();
        return(TRUE);
      }
      else if (IsEdit(Type) && !(Item[FocusPos].Flags & DIF_READONLY))
      {
        /* $ 28.07.2000 SVS
          При изменении состояния каждого элемента посылаем сообщение
          посредством функции SendDlgMessage - в ней делается все!
        */
        if(((Edit *)(Item[FocusPos].ObjPtr))->ProcessKey(Key))
        {
          Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
          Redraw(); // Перерисовка должна идти после DN_EDITCHANGE (imho)
        }
        return(TRUE);
      }
      return(TRUE);

    case KEY_HOME:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;

      else if (IsEdit(Type))
      {
        ((Edit *)(Item[FocusPos].ObjPtr))->ProcessKey(Key);
        return(TRUE);
      }
      else
      {
        for (I=0;I<ItemCount;I++)
          if (IsFocused(Item[I].Type))
          {
            ChangeFocus2(FocusPos,I);
            /* $ 28.07.2000 SVS
              При изменении состояния каждого элемента посылаем сообщение
              посредством функции SendDlgMessage - в ней делается все!
            */
            //Dialog::SendDlgMessage((HANDLE)this,DN_CHANGEITEM,FocusPos,0);
            //Dialog::SendDlgMessage((HANDLE)this,DN_CHANGEITEM,I,0);
            /* SVS $ */
            ShowDialog();
            return(TRUE);
          }
      }
      return(TRUE);

    case KEY_LEFT:
    case KEY_RIGHT:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;
      else if (IsEdit(Type))
      {
        ((Edit *)(Item[FocusPos].ObjPtr))->ProcessKey(Key);
        return(TRUE);
      }
      else
      {
        int MinDist=1000,MinPos;
        for (I=0;I<ItemCount;I++)
          if (I!=FocusPos &&
              (IsEdit(Item[I].Type) ||
               Item[I].Type==DI_CHECKBOX ||
               Item[I].Type==DI_RADIOBUTTON) &&
              Item[I].Y1==Item[FocusPos].Y1)
          {
            int Dist=Item[I].X1-Item[FocusPos].X1;
            if (Key==KEY_LEFT && Dist<0 || Key==KEY_RIGHT && Dist>0)
              if (abs(Dist)<MinDist)
              {
                MinDist=abs(Dist);
                MinPos=I;
              }
          }
          if (MinDist<1000)
          {
            ChangeFocus2(FocusPos,MinPos);
            if (Item[MinPos].Flags & DIF_MOVESELECT)
              ProcessKey(KEY_SPACE);
            else
            {
              ShowDialog();
            }
            return(TRUE);
          }
      }

    case KEY_UP:
    case KEY_DOWN:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;
      else
      {
        int PrevPos=0;
        if (Item[FocusPos].Flags & DIF_EDITOR)
          PrevPos=((Edit *)(Item[FocusPos].ObjPtr))->GetCurPos();
        I=ChangeFocus(FocusPos,(Key==KEY_LEFT || Key==KEY_UP) ? -1:1,FALSE);
        Item[FocusPos].Focus=0;
        Item[I].Focus=1;
        ChangeFocus2(FocusPos,I);
        if (Item[I].Flags & DIF_EDITOR)
          ((Edit *)(Item[I].ObjPtr))->SetCurPos(PrevPos);
        if (Item[I].Flags & DIF_MOVESELECT)
          ProcessKey(KEY_SPACE);
        else
        {
          ShowDialog();
        }
      }
      return(TRUE);

    case KEY_END:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;
      else if (IsEdit(Type))
      {
        ((Edit *)(Item[FocusPos].ObjPtr))->ProcessKey(Key);
        return(TRUE);
      }
    case KEY_PGDN:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;
      else if (!(Item[FocusPos].Flags & DIF_EDITOR))
      {
        for (I=0;I<ItemCount;I++)
          if (Item[I].DefaultButton)
          {
            ChangeFocus2(FocusPos,I);
            ShowDialog();
            return(TRUE);
          }
      }
      else
      {
        ProcessKey(KEY_TAB);
        ProcessKey(KEY_UP);
      }
      return(TRUE);

    /* $ 27.04.2001 VVM
      + Обработка колеса мышки */
    case KEY_MSWHEEL_UP:
    case KEY_MSWHEEL_DOWN:
    /* VVM $ */
    case KEY_CTRLUP:
    case KEY_CTRLDOWN:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;

      CurEditLine=((Edit *)(Item[FocusPos].ObjPtr));
      if (IsEdit(Type) &&
           (Item[FocusPos].Flags & DIF_HISTORY) &&
           Opt.DialogsEditHistory &&
           Item[FocusPos].History &&
           !(Item[FocusPos].Flags & DIF_READONLY))
      /* $ 26.07.2000 SVS
         Передаем то, что в строке ввода в функцию выбора из истории
         для выделения нужного пункта в истории.
      */
      {
        char *PStr=Str;
        int MaxLen=sizeof(Item[FocusPos].Data);
        if(Item[FocusPos].Flags&DIF_VAREDIT)
        {
          MaxLen=Item[FocusPos].Ptr.PtrLength;
          if((PStr=(char*)malloc(MaxLen+1)) == NULL)
            return TRUE;//???
        }
        /* $ 27.04.2001 SVS
           Оху%$@#&^%$&$%*%^$*^%$*^%$*^%$&*
           Было: sizeof(MaxLen) ;-( - это типа размер данных.
        */
        CurEditLine->GetString(PStr,MaxLen);
        /* SVS $ */
        SelectFromEditHistory(Item+FocusPos,CurEditLine,Item[FocusPos].History,PStr,MaxLen);
        if(Item[FocusPos].Flags&DIF_VAREDIT)
          free(PStr);
      }
      /* SVS $ */
      /* $ 18.07.2000 SVS
         + обработка DI_COMBOBOX - выбор из списка!
      */
      else if(Type == DI_COMBOBOX && Item[FocusPos].ListPtr &&
              !(Item[FocusPos].Flags & DIF_READONLY) &&
              Item[FocusPos].ListPtr->GetItemCount() > 0) //??
      {
        int MaxLen=(Item[FocusPos].Flags&DIF_VAREDIT)?
                     Item[FocusPos].Ptr.PtrLength:
                     sizeof(Item[FocusPos].Data);
        if(SelectFromComboBox(CurEditLine,Item[FocusPos].ListPtr,MaxLen) != KEY_ESC)
          Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
      }
      /* SVS $ */
      return(TRUE);

    default:
      // для user-типа вываливаем
      if(Type == DI_USERCONTROL)
        return TRUE;

      /* $ 01.08.2000 SVS
         Обычный ListBox
      */
      if(Type == DI_LISTBOX)
      {
        Item[FocusPos].ListPtr->ProcessKey(Key);
        return(TRUE);
      }
      /* SVS $ */

      /* $ 21.08.2000 SVS
         Autocomplete при постоянных блоках и немного оптимизации ;-)
      */
      if (IsEdit(Type))
      {
        Edit *edt=(Edit *)Item[FocusPos].ObjPtr;
        int SelStart, SelEnd;

        if(Key == KEY_CTRLL) // исключим смену режима RO для поля ввода с клавиатуры
        {
          return TRUE;
        }

        /* $ 11.09.2000 SVS
           Ctrl-U в строках ввода снимает пометку блока
        */
        else if(Key == KEY_CTRLU)
        {
          edt->SetClearFlag(0);
          edt->Select(-1,0);
          edt->Show();
          return TRUE;
        }
        /* SVS $ */

        else if((Item[FocusPos].Flags & DIF_EDITOR) && !(Item[FocusPos].Flags & DIF_READONLY))
        {
          switch(Key)
          {
            /* $ 12.09.2000 SVS
              Исправляем ситуацию с BackSpace в DIF_EDITOR
            */
            case KEY_BS:
            {
              int CurPos=edt->GetCurPos();
              /* $ 21.11.2000 SVS
                 Не стиралась последняя строка в многострочном редакторе
              */
              // В начале строки????
              if(!edt->GetCurPos())
              {
                // а "выше" тоже DIF_EDITOR?
                if(FocusPos > 0 && (Item[FocusPos-1].Flags&DIF_EDITOR))
                {
                  // добавляем к предыдущему и...
                  Edit *edt_1=(Edit *)Item[FocusPos-1].ObjPtr;
                  edt_1->GetString(Str,sizeof(Str));
                  CurPos=strlen(Str);
                  edt->GetString(Str+CurPos,sizeof(Str)-CurPos);
                  edt_1->SetString(Str);

                  for (I=FocusPos+1;I<ItemCount;I++)
                  {
                    if (Item[I].Flags & DIF_EDITOR)
                    {
                      if (I>FocusPos)
                      {
                        ((Edit *)(Item[I].ObjPtr))->GetString(Str,sizeof(Str));
                        ((Edit *)(Item[I-1].ObjPtr))->SetString(Str);
                      }
                      ((Edit *)(Item[I].ObjPtr))->SetString("");
                    }
                    else // ага, значит  FocusPos это есть последний из DIF_EDITOR
                    {
                      ((Edit *)(Item[I-1].ObjPtr))->SetString("");
                      break;
                    }
                  }
                  ProcessKey(KEY_UP);
                  edt_1->SetCurPos(CurPos);
                }
              }
              /* SVS $ */
              else
              {
                edt->ProcessKey(Key);
              }
              Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
              ShowDialog();
              return(TRUE);
            }
            /* SVS $ */

            case KEY_CTRLY:
              for (I=FocusPos;I<ItemCount;I++)
                if (Item[I].Flags & DIF_EDITOR)
                {
                  if (I>FocusPos)
                  {
                    ((Edit *)(Item[I].ObjPtr))->GetString(Str,sizeof(Str));
                    ((Edit *)(Item[I-1].ObjPtr))->SetString(Str);
                  }
                  ((Edit *)(Item[I].ObjPtr))->SetString("");
                }
                else
                  break;
              /* $ 28.07.2000 SVS
                При изменении состояния каждого элемента посылаем сообщение
                посредством функции SendDlgMessage - в ней делается все!
              */
              Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
              /* SVS $ */
              ShowDialog();
              return(TRUE);

            case KEY_DEL:
              /* $ 19.07.2000 SVS
                 ! "...В редакторе команд меню нажмите home shift+end del
                   блок не удаляется..."
                   DEL у итемов, имеющих DIF_EDITOR, работал без учета
                   выделения...
              */
              if (FocusPos<ItemCount+1 && (Item[FocusPos+1].Flags & DIF_EDITOR))
              {
                int CurPos=edt->GetCurPos();
                int Length=edt->GetLength();
                int SelStart, SelEnd;

                edt->GetSelection(SelStart, SelEnd);
                edt->GetString(Str,sizeof(Str));
                int LengthStr=strlen(Str);
                if(SelStart > -1)
                {
                  memmove(&Str[SelStart],&Str[SelEnd],Length-SelEnd+1);
                  edt->SetString(Str);
                  edt->SetCurPos(SelStart);
                  /* $ 28.07.2000 SVS
                    При изменении состояния каждого элемента посылаем сообщение
                    посредством функции SendDlgMessage - в ней делается все!
                  */
                  Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
                  /* SVS $ */
                  ShowDialog();
                  return(TRUE);
                }
                else if (CurPos>=Length)
                {
                  Edit *edt_1=(Edit *)Item[FocusPos+1].ObjPtr;
                  /* $ 12.09.2000 SVS
                     Решаем проблему, если Del нажали в позиции
                     большей, чем длина строки
                  */
                  if (CurPos > Length)
                  {
                    LengthStr=CurPos;
                    memset(Str+Length,' ',CurPos-Length);
                  }
                  /* SVS $*/
                  edt_1->GetString(Str+LengthStr,sizeof(Str)-LengthStr);
                  edt_1->SetString(Str);
                  ProcessKey(KEY_CTRLY);
                  edt->SetCurPos(CurPos);
                  ShowDialog();
                  return(TRUE);
                }
              }
              break;
              /* SVS $*/
            case KEY_PGUP:
              ProcessKey(KEY_SHIFTTAB);
              ProcessKey(KEY_DOWN);
              return(TRUE);
          }
        }

        /* $ 24.09.2000 SVS
           Вызов функции Xlat
        */
        /* $ 04.11.2000 SVS
           Проверка на альтернативную клавишу
        */
        if((Opt.XLat.XLatDialogKey && Key == Opt.XLat.XLatDialogKey ||
           Opt.XLat.XLatAltDialogKey && Key == Opt.XLat.XLatAltDialogKey) ||
           Key == KEY_MACROXLAT && !(Item[FocusPos].Flags & DIF_READONLY))
        {
          edt->SetClearFlag(0);
          edt->Xlat();
          Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
          Redraw(); // Перерисовка должна идти после DN_EDITCHANGE (imho)
          return TRUE;
        }
        /* SVS $ */
        /* SVS $ */
        if(!(Item[FocusPos].Flags & DIF_READONLY) ||
            (Item[FocusPos].Flags & DIF_READONLY) && IsNavKey(Key))
        {
          if (edt->ProcessKey(Key))
          {
            if(Item[FocusPos].Flags & DIF_READONLY)
              return TRUE;

            //int RedrawNeed=FALSE;
            /* $ 26.07.2000 SVS
               AutoComplite: Если установлен DIF_HISTORY
                   и разрешено автозавершение!.
            */
            /* $ 04.12.2000 SVS
              Автодополнение - чтобы не работало во время проигрывания макросов.
              GetCurRecord() вернет 0 для случая, если нет ни записи ни проигрыша.
            */
            if(!CtrlObject->Macro.GetCurRecord(NULL,NULL) &&
               ((Item[FocusPos].Flags & DIF_HISTORY) || Type == DI_COMBOBOX))
            if((Opt.AutoComplete && Key < 256 && Key != KEY_BS && Key != KEY_DEL) ||
               (!Opt.AutoComplete && Key == KEY_CTRLEND)
              )
            {
              /* $ 05.12.2000 IS
                 Все удалил и написал заново ;)
              */
              int MaxLen=sizeof(Item[FocusPos].Data);
              char *PStr=Str;
              if(Item[FocusPos].Flags & DIF_VAREDIT)
              {
                MaxLen=Item[FocusPos].Ptr.PtrLength;
                if((PStr=(char*)malloc(MaxLen+1)) == NULL)
                  return TRUE; //???
              }
              int DoAutoComplete=TRUE;
              int CurPos=edt->GetCurPos();
              edt->GetString(PStr,MaxLen);
              int len=strlen(PStr);
              edt->GetSelection(SelStart,SelEnd);
              if(SelStart < 0 || SelStart==SelEnd)
                  SelStart=len;
              else
                  SelStart++;

              if(CurPos<SelStart) DoAutoComplete=FALSE;
              if(SelStart<SelEnd && SelEnd<len) DoAutoComplete=FALSE;

              if(Opt.EdOpt.PersistentBlocks)
              {
                if(DoAutoComplete && CurPos <= SelEnd)
                {
                  PStr[CurPos]=0;
                  edt->Select(CurPos,MaxLen); //select the appropriate text
                  edt->DeleteBlock();
                  edt->FastShow();
                }
              }
              /* IS $ */

              SelEnd=strlen(PStr);

              //find the string in the list
              /* $ 03.12.2000 IS
                   Учитываем флаг DoAutoComplete
              */
              if (DoAutoComplete && FindInEditForAC(Type == DI_COMBOBOX,
                           (void *)Item[FocusPos].Selected,PStr,MaxLen))
              /* IS $ */
              {
  //_D(SysLog("Coplete: Str=%s SelStart=%d SelEnd=%d CurPos=%d",Str,SelStart,SelEnd, CurPos));
                edt->SetString(PStr);
                edt->Select(SelEnd,MaxLen); //select the appropriate text
                //edt->Select(CurPos,sizeof(Str)); //select the appropriate text
                /* $ 01.08.2000 SVS
                   Небольшой глючек с AutoComplete
                */
                edt->SetCurPos(CurPos); // SelEnd
                //RedrawNeed=TRUE;
              }
              if(Item[FocusPos].Flags & DIF_VAREDIT)
                free(PStr);
            }
            /* SVS 03.12.2000 $ */
            Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
            /* SVS $ */
  //          if(RedrawNeed)
              Redraw(); // Перерисовка должна идти после DN_EDITCHANGE (imho)
            return(TRUE);
          }
        }
        else if(!(Key&(KEY_ALT|KEY_RALT)))
          return TRUE;
        /* SVS 21.08.2000 $ */
      }

      if (ProcessHighlighting(Key,FocusPos,FALSE))
        return(TRUE);

      return(ProcessHighlighting(Key,FocusPos,TRUE));
  }
}


//////////////////////////////////////////////////////////////////////////
/* Public, Virtual:
   Обработка данных от "мыши".
   Перекрывает BaseInput::ProcessMouse.
*/
/* $ 18.08.2000 SVS
   + DN_MOUSECLICK
*/
int Dialog::ProcessMouse(MOUSE_EVENT_RECORD *MouseEvent)
{
  int I;
  int MsX,MsY;
  int Type;
  RECT Rect;

  /* $ 11.06.2001 KM
     ! Сделана нормальная работа мыши в DI_LISTBOX.
  */
  if(!DialogMode.Check(DMODE_SHOW))
    return FALSE;

  if(!DialogMode.Check(DMODE_MOUSEEVENT))
   if(!DlgProc((HANDLE)this,DN_MOUSEEVENT,0,(long)MouseEvent))
     return TRUE;

  MsX=MouseEvent->dwMousePosition.X;
  MsY=MouseEvent->dwMousePosition.Y;

  //for (I=0;I<ItemCount;I++)
  for (I=ItemCount-1;I>=0;I--)
  {
    if(Item[I].Flags&(DIF_DISABLE|DIF_HIDDEN))
      continue;
    Type=Item[I].Type;
    if (Type == DI_LISTBOX && MsY >= Y1+Item[I].Y1 &&
        MsY <= Y1+Item[I].Y2 && MsX <= X1+Item[I].X2)
    {
      /* $ 30.06.2001 KM */
      VMenu *List=Item[I].ListPtr;
      int Pos=List->GetSelectPos();
      if((MouseEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED))
      {
        if(FocusPos != I)
        {
          ChangeFocus2(FocusPos,I);
          ShowDialog();
        }

        if (!SendDlgMessage((HANDLE)this,DN_MOUSECLICK,I,(long)MouseEvent))
        {
          if (SendDlgMessage((HANDLE)this,DN_LISTCHANGE,I,(long)Pos))
          {
            if (MsX==X1+Item[I].X2 && MsY >= Y1+Item[I].Y1 && MsY <= Y1+Item[I].Y2)
              Item[I].ListPtr->ProcessMouse(MouseEvent); // забыл проверить на клик на скролбар (KM)
            else
              ProcessKey(KEY_ENTER);
          }
        }
        return TRUE;
      }
      else
      {
        if ((I == FocusPos || DialogMode.Check(DMODE_MOUSELIST)) && // для нефокусного списка... не юзаем мышь
            SendDlgMessage((HANDLE)this,DN_LISTCHANGE,I,(long)Pos))
          Item[I].ListPtr->ProcessMouse(MouseEvent);
      }
      /* KM $ */
      return(TRUE);
    }
  }
  /* KM $ */

  if (MouseEvent->dwButtonState==0)
    return(FALSE);

  if (MsX<X1 || MsY<Y1 || MsX>X2 || MsY>Y2)
  {
    if(!DlgProc((HANDLE)this,DN_MOUSECLICK,-1,(long)MouseEvent))
    {
      if (MouseEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED)
        ProcessKey(KEY_ESC);
      else if (MouseEvent->dwButtonState & RIGHTMOST_BUTTON_PRESSED)
        ProcessKey(KEY_ENTER);
    }
    return(TRUE);
  }

//_D(SysLog("Ms (%d,%d)",MsX,MsY));
  if (MouseEvent->dwEventFlags==0 || MouseEvent->dwEventFlags==DOUBLE_CLICK)
  {
    // первый цикл - все за исключением рамок.
    //for (I=0; I < ItemCount;I++)
    for (I=ItemCount-1;I>=0;I--)
    {
      if(Item[I].Flags&(DIF_DISABLE|DIF_HIDDEN))
        continue;

      GetItemRect(I,Rect);
      Rect.left+=X1;  Rect.top+=Y1;
      Rect.right+=X1; Rect.bottom+=Y1;
//_D(SysLog("? %2d) Rect (%2d,%2d) (%2d,%2d) '%s'",I,Rect.left,Rect.top,Rect.right,Rect.bottom,Item[I].Data));

      if(MsX >= Rect.left && MsY >= Rect.top && MsX <= Rect.right && MsY <= Rect.bottom)
      {
        // для прозрачных :-)
        if(Item[I].Type == DI_SINGLEBOX || Item[I].Type == DI_DOUBLEBOX)
        {
          // если на рамке, то...
          if(((MsX == Rect.left || MsX == Rect.right) && MsY >= Rect.top && MsY <= Rect.bottom) || // vert
             ((MsY == Rect.top  || MsY == Rect.bottom) && MsX >= Rect.left && MsX <= Rect.right) )   // hor
          {
            if(DlgProc((HANDLE)this,DN_MOUSECLICK,I,(long)MouseEvent))
              return TRUE;
          }
          else
            continue;
        }

        if(Item[I].Type == DI_USERCONTROL)
        {
          // для user-типа подготовим координаты мыши
          MouseEvent->dwMousePosition.X-=(short)Rect.left;
          MouseEvent->dwMousePosition.Y-=(short)Rect.top;
        }

//_SVS(SysLog("+ %2d) Rect (%2d,%2d) (%2d,%2d) '%s' Dbl=%d",I,Rect.left,Rect.top,Rect.right,Rect.bottom,Item[I].Data,MouseEvent->dwEventFlags==DOUBLE_CLICK));
        if(DlgProc((HANDLE)this,DN_MOUSECLICK,I,(long)MouseEvent))
          return TRUE;

        if(Item[I].Type == DI_USERCONTROL)
        {
           ChangeFocus2(FocusPos,I);
           ShowDialog();
           return(TRUE);
        }
        break;
      }
    }

    if((MouseEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED))
    {
      //for (I=0;I<ItemCount;I++)
      int OldFocusPos=FocusPos;
      for (I=ItemCount-1;I>=0;I--)
      {
        /* $ 04.12.2000 SVS
           Исключаем из списка оповещаемых о мыши недоступные элементы
        */
        if(Item[I].Flags&(DIF_DISABLE|DIF_HIDDEN))
          continue;
        /* SVS $ */
        Type=Item[I].Type;
        if (MsX>=X1+Item[I].X1)
        {
          /* ********************************************************** */
          if (IsEdit(Type))
          {
            /* $ 15.08.2000 SVS
               + Сделаем так, чтобы ткнув мышкой в DropDownList
                 список раскрывался сам.
               Есть некоторая глюкавость - когда список раскрыт и мы
               мышой переваливаем на другой элемент, то список закрывается
               но перехода реального на указанный элемент диалога не происходит
            */
            int EditX1,EditY1,EditX2,EditY2;
            Edit *EditLine=(Edit *)(Item[I].ObjPtr);
            EditLine->GetPosition(EditX1,EditY1,EditX2,EditY2);

            if(MsY==EditY1 && Type == DI_COMBOBOX &&
               (Item[I].Flags & DIF_DROPDOWNLIST) &&
               MsX >= EditX1 && MsX <= EditX2+1)
            {
              EditLine->SetClearFlag(0);
              if(!(Item[I].Flags&DIF_NOFOCUS))
                ChangeFocus2(FocusPos,I);
              else
                FocusPos=I;
              ShowDialog();
              ProcessKey(KEY_CTRLDOWN);
              if(Item[I].Flags&DIF_NOFOCUS)
                FocusPos=OldFocusPos;
              return(TRUE);
            }

            if (EditLine->ProcessMouse(MouseEvent))
            {
              EditLine->SetClearFlag(0); // а может это делать в самом edit?
              if(!(Item[I].Flags&DIF_NOFOCUS)) //??? !!!
                ChangeFocus2(FocusPos,I);      //??? !!!
              else                             //??? !!!
                FocusPos=I;                    //??? !!!
              /* $ 23.06.2001 KM
                 ! Оказалось нужно перерисовывать весь диалог иначе
                   не снимался признак активности с комбобокса с которго уходим.
              */
              ShowDialog(); // нужен ли только один контрол или весь диалог?
              /* KM $ */
              return(TRUE);
            }
            else
            {
              // Проверка на DI_COMBOBOX здесь лишняя. Убрана (KM).
              if (MsX==EditX2+1 && MsY==EditY1 && Item[I].History &&
                  ((Item[I].Flags & DIF_HISTORY) && Opt.DialogsEditHistory
                   || Type == DI_COMBOBOX))
//                  ((Item[I].Flags & DIF_HISTORY) && Opt.DialogsEditHistory))
              {
                EditLine->SetClearFlag(0); // раз уж покусились на, то и...
                if(!(Item[I].Flags&DIF_NOFOCUS))
                  ChangeFocus2(FocusPos,I);
                else
                  FocusPos=I;
                if(!(Item[I].Flags&DIF_HIDDEN))
                  ShowDialog(I);
                ProcessKey(KEY_CTRLDOWN);
                if(Item[I].Flags&DIF_NOFOCUS)
                   FocusPos=OldFocusPos;
                return(TRUE);
              }
            }
          }

          /* ********************************************************** */
          if (Type==DI_BUTTON &&
              MsY==Y1+Item[I].Y1 &&
              MsX < X1+Item[I].X1+HiStrlen(Item[I].Data))
          {
            if(!(Item[I].Flags&DIF_NOFOCUS))
            {
              ChangeFocus2(FocusPos,I);
              ShowDialog();
            }
            else
              FocusPos=I;
            while (IsMouseButtonPressed())
              ;
            if (MouseX <  X1 ||
                MouseX >  X1+Item[I].X1+HiStrlen(Item[I].Data)+4 ||
                MouseY != Y1+Item[I].Y1)
            {
              if(!(Item[I].Flags&DIF_NOFOCUS))
              {
                ChangeFocus2(FocusPos,I);
                ShowDialog();
              }
              return(TRUE);
            }
            ProcessKey(KEY_ENTER);
            if(Item[I].Flags&DIF_NOFOCUS)
              FocusPos=OldFocusPos;
            return(TRUE);
          }

          /* ********************************************************** */
          if ((Type == DI_CHECKBOX ||
               Type == DI_RADIOBUTTON) &&
              MsY==Y1+Item[I].Y1 &&
              MsX < (X1+Item[I].X1+HiStrlen(Item[I].Data)+4-((Item[I].Flags & DIF_MOVESELECT)!=0)))
          {
            if(!(Item[I].Flags&DIF_NOFOCUS))
              ChangeFocus2(FocusPos,I);
            else
              FocusPos=I;
            ProcessKey(KEY_SPACE);
            if(Item[I].Flags&DIF_NOFOCUS)
              FocusPos=OldFocusPos;
            return(TRUE);
          }
        }
      } // for (I=0;I<ItemCount;I++)
      // ДЛЯ MOUSE-Перемещалки:
      //   Сюда попадаем в том случае, если мышь не попала на активные элементы
      //
      /* $ 10.08.2000 SVS
         Двигаем, если разрешено! (IsCanMove)
      */
      if (DialogMode.Check(DMODE_ISCANMOVE) && DlgProc((HANDLE)this,DN_DRAGGED,0,0))
      {
        /* $ 03.08.2000 tran
           ну раз попадаем - то будем перемещать */
        //DialogMode.Set(DMODE_DRAGGED);
        OldX1=X1; OldX2=X2; OldY1=Y1; OldY2=Y2;
        // запомним delta места хватания и Left-Top диалогового окна
        MsX=abs(X1-MouseX);
        MsY=abs(Y1-MouseY);
        while (1)
        {
            int mb=IsMouseButtonPressed();
            /* $ 15.12.2000 SVS
               Новый движок мышиного перемещения
            */
            int mx,my,X0,Y0;
            if ( mb==1 ) // left key, still dragging
            {
                Hide();
                X0=X1;
                Y0=Y1;
                if(MouseX==PrevMouseX)
                  mx=X1;
                else
                  mx=MouseX-MsX;
                if(MouseY==PrevMouseY)
                  my=Y1;
                else
                  my=MouseY-MsY;

                if(mx >= 0 && mx+(X2-X1)<=ScrX)
                {
                  X2=mx+(X2-X1);
                  X1=mx;
                  AdjustEditPos(X1-X0,0); //?
                }
                if(my >= 0 && my+(Y2-Y1)<=ScrY)
                {
                  Y2=my+(Y2-Y1);
                  Y1=my;
                  AdjustEditPos(0,Y1-Y0); //?
                }
                Show();
            }
            /* SVS $ */
            else if (mb==2) // right key, abort
            {
                Hide();
                AdjustEditPos(OldX1-X1,OldY1-Y1);
                X1=OldX1;
                X2=OldX2;
                Y1=OldY1;
                Y2=OldY2;
                DialogMode.Skip(DMODE_DRAGGED);
                DlgProc((HANDLE)this,DN_DRAGGED,1,TRUE);
                Show();
                break;
            }
            else  // release key, drop dialog
            {
                DialogMode.Skip(DMODE_DRAGGED);
                DlgProc((HANDLE)this,DN_DRAGGED,1,0);
                Show();
                break;
            }
        }// while (1)
        /* tran 03.08.2000 $ */
      }
      /* SVS 10.08.2000 $*/
    }
  }
  return(FALSE);
}
/* SVS 18.08.2000 $ */


//////////////////////////////////////////////////////////////////////////
/* Private:
   Изменяет фокус ввода (воздействие клавишами
     KEY_TAB, KEY_SHIFTTAB, KEY_UP, KEY_DOWN,
   а так же Alt-HotKey)
*/
/* $ 28.07.2000 SVS
   Довесок для сообщений DN_KILLFOCUS & DN_SETFOCUS
*/
/* $ 24.08.2000 SVS
   Добавка для DI_USERCONTROL
*/
int Dialog::ChangeFocus(int FocusPos,int Step,int SkipGroup)
{
  int Type,OrigFocusPos=FocusPos;
//  int FucusPosNeed=-1;
  // В функцию обработки диалога здесь передаем сообщение,
  //   что элемент - LostFocus() - теряет фокус ввода.
//  if(DialogMode.Check(DMODE_INITOBJECTS))
//    FucusPosNeed=DlgProc((HANDLE)this,DN_KILLFOCUS,FocusPos,0);
//  if(FucusPosNeed != -1 && IsFocused(Item[FucusPosNeed].Type))
//    FocusPos=FucusPosNeed;
//  else
  {
    while (1)
    {
      FocusPos+=Step;
      if (FocusPos>=ItemCount)
        FocusPos=0;
      if (FocusPos<0)
        FocusPos=ItemCount-1;

      Type=Item[FocusPos].Type;

      if(!(Item[FocusPos].Flags&(DIF_NOFOCUS|DIF_DISABLE|DIF_HIDDEN)))
      {
        if (Type==DI_LISTBOX || Type==DI_BUTTON || Type==DI_CHECKBOX || IsEdit(Type) || Type==DI_USERCONTROL)
          break;
        if (Type==DI_RADIOBUTTON && (!SkipGroup || Item[FocusPos].Selected))
          break;
      }
      // убираем зацикливание с последующим подвисанием :-)
      if(OrigFocusPos == FocusPos)
        break;
    }
  }

//  Dialog::FocusPos=FocusPos;
  // В функцию обработки диалога здесь передаем сообщение,
  //   что элемент GotFocus() - получил фокус ввода.
  // Игнорируем возвращаемое функцией диалога значение
//  if(DialogMode.Check(DMODE_INITOBJECTS))
//    DlgProc((HANDLE)this,DN_GOTFOCUS,FocusPos,0);
  return(FocusPos);
}
/* SVS $ */


//////////////////////////////////////////////////////////////////////////
/* $ 28.07.2000 SVS
   Private:
   Изменяет фокус ввода между двумя элементами.
   Вынесен отдельно с тем, чтобы обработать DN_KILLFOCUS & DM_SETFOCUS
*/
int Dialog::ChangeFocus2(int KillFocusPos,int SetFocusPos)
{
  int FucusPosNeed=-1;
  if(!(Item[SetFocusPos].Flags&(DIF_NOFOCUS|DIF_DISABLE|DIF_HIDDEN)))
  {
    if(DialogMode.Check(DMODE_INITOBJECTS))
      FucusPosNeed=DlgProc((HANDLE)this,DN_KILLFOCUS,KillFocusPos,0);

    if(FucusPosNeed != -1 && IsFocused(Item[FucusPosNeed].Type))
      SetFocusPos=FucusPosNeed;

    if(Item[SetFocusPos].Flags&DIF_NOFOCUS)
       SetFocusPos=KillFocusPos;

    Item[KillFocusPos].Focus=0;
    Item[SetFocusPos].Focus=1;

    Dialog::PrevFocusPos=Dialog::FocusPos;
    Dialog::FocusPos=SetFocusPos;
    if(DialogMode.Check(DMODE_INITOBJECTS))
      DlgProc((HANDLE)this,DN_GOTFOCUS,SetFocusPos,0);
  }
  else
    SetFocusPos=KillFocusPos;

  SelectOnEntry(KillFocusPos,FALSE);
  SelectOnEntry(SetFocusPos,TRUE);
  return(SetFocusPos);
}
/* SVS $ */

/* $ 08.09.2000 SVS
  Функция SelectOnEntry - выделение строки редактирования
  Обработка флага DIF_SELECTONENTRY
*/
void Dialog::SelectOnEntry(int Pos,BOOL Selected)
{
  if(IsEdit(Item[Pos].Type) &&
     (Item[Pos].Flags&DIF_SELECTONENTRY)
//     && PrevFocusPos != -1 && PrevFocusPos != Pos
    )
  {
    Edit *edt=(Edit *)Item[Pos].ObjPtr;
    if(edt)
    {
      if(Selected)
        edt->Select(0,edt->GetLength());
      else
        edt->Select(-1,0);
    }
  }
}
/* SVS $ */

/* $ 04.12.2000 SVS
   ! Оптимизация функций ConvertItem() и DataToItem() - с указателями
     будет генериться компактный и быстрый код (MSVC - это сам делает :-(
*/

//////////////////////////////////////////////////////////////////////////
/* $ 28.07.2000 SVS
   Public, Static:
   + функция ConvertItem - обратное преобразование элементов диалога из
   внутреннего представления во внешние
*/
void Dialog::ConvertItem(int FromPlugin,
                         struct FarDialogItem *Item,struct DialogItem *Data,
                         int Count,BOOL InternalCall)
{
  int I;
  if(!Item || !Data)
    return;

  char *PtrData;
  int PtrLength;
  Edit *EditPtr;

  if(FromPlugin == CVTITEM_TOPLUGIN)
    for (I=0; I < Count; I++, ++Item, ++Data)
    {
      Item->Type=Data->Type;
      Item->X1=Data->X1;
      Item->Y1=Data->Y1;
      Item->X2=Data->X2;
      Item->Y2=Data->Y2;
      if(Item->X2 < Item->X1) Item->X2=Item->X1;
      if(Item->Y2 < Item->Y1) Item->Y2=Item->Y1;
      Item->Focus=Data->Focus;
      Item->Param.Selected=Data->Selected;
      Item->Flags=Data->Flags;
      Item->DefaultButton=Data->DefaultButton;
      if(InternalCall)
      {
        if(Dialog::IsEdit(Data->Type) && (EditPtr=(Edit *)(Data->ObjPtr)) != NULL)
        {
          // Заполним значения
          if((Data->Type==DI_EDIT || Data->Type==DI_COMBOBOX) &&
             (Data->Flags&DIF_VAREDIT))
          {
            PtrData  =(char *)Data->Ptr.PtrData;
            PtrLength=Data->Ptr.PtrLength;
          }
          else
          {
            PtrData  =Data->Data;
            PtrLength=sizeof(Data->Data);
          }
          EditPtr->GetString(PtrData,PtrLength);
        }
      }
      memmove(Item->Data.Data,Data->Data,sizeof(Item->Data.Data));
    }
  else
    for (I=0; I < Count; I++, ++Item, ++Data)
    {
      Data->Type=Item->Type;
      Data->X1=Item->X1;
      Data->Y1=Item->Y1;
      Data->X2=Item->X2;
      Data->Y2=Item->Y2;
      if(Data->X2 < Data->X1) Data->X2=Data->X1;
      if(Data->Y2 < Data->Y1) Data->Y2=Data->Y1;
      Data->Focus=Item->Focus;
      Data->Selected=Item->Param.Selected;
      Data->Flags=Item->Flags;
      Data->DefaultButton=Item->DefaultButton;
      memmove(Data->Data,Item->Data.Data,sizeof(Data->Data));
      /* Этот кусок будет работать после тчательной проверки.
      Он позволит менять данные в ответ на DN_EDITCHANGE
      if(InternalCall)
      {
        if(Dialog::IsEdit(Data->Type) && (EditPtr=(Edit *)(Data->ObjPtr)) != NULL)
        {
          // обновим
          if((Data->Type==DI_EDIT || Data->Type==DI_COMBOBOX) &&
             (Data->Flags&DIF_VAREDIT))
          {
            PtrData  =(char *)Data->Ptr.PtrData;
            PtrLength=Data->Ptr.PtrLength;
          }
          else
          {
            PtrData  =Data->Data;
            PtrLength=sizeof(Data->Data);
          }
          EditPtr->SetString(PtrData);
        }
      }
      */
    }
}
/* SVS $ */

//////////////////////////////////////////////////////////////////////////
/* Public, Static:
   преобразует данные об элементах диалога во внутреннее
   представление. Аналогичен функции InitDialogItems (см. "Far PlugRinG
   Russian Help Encyclopedia of Developer")
*/
void Dialog::DataToItem(struct DialogData *Data,struct DialogItem *Item,int Count)
{
  int I;

  if(!Item || !Data)
    return;

  memset(Item,0,sizeof(struct DialogItem)*Count);
  for (I=0; I < Count; I++, ++Item, ++Data)
  {
    Item->ID=I;
    Item->Type=Data->Type;
    Item->X1=Data->X1;
    Item->Y1=Data->Y1;
    Item->X2=Data->X2;
    Item->Y2=Data->Y2;
    if(Item->X2 < Item->X1) Item->X2=Item->X1;
    if(Item->Y2 < Item->Y1) Item->Y2=Item->Y1;
    Item->Focus=Data->Focus;
    Item->Selected=Data->Selected;
    Item->Flags=Data->Flags;
    Item->DefaultButton=Data->DefaultButton;
    if ((unsigned int)Data->Data<MAX_MSG)
      strcpy(Item->Data,MSG((unsigned int)Data->Data));
    else
      memcpy(Item->Data,Data->Data,sizeof(Item->Data));
  }
}
/* SVS 04.12.2000 $ */

int Dialog::SetAutomation(WORD IDParent,WORD id,
                             DWORD UncheckedSet,DWORD UncheckedSkip,
                             DWORD CheckedSet,DWORD CheckedSkip,
                             DWORD Checked3Set,DWORD Checked3Skip)
{
  int Ret=FALSE;
  if(IDParent < ItemCount && (Item[IDParent].Flags&DIF_AUTOMATION) &&
     id < ItemCount && IDParent != id) // Сами себя не юзаем!
  {
    DialogItemAutomation *Auto;
    int AutoCount=Item[IDParent].AutoCount;
    if((Auto=(DialogItemAutomation*)realloc(Item[IDParent].AutoPtr,sizeof(DialogItemAutomation)*(AutoCount+1))) != NULL)
    {
      Item[IDParent].AutoPtr=Auto;
      Auto=Item[IDParent].AutoPtr+AutoCount;
      Auto->ID=id;
      Auto->Flags[0][0]=UncheckedSet;
      Auto->Flags[0][1]=UncheckedSkip;
      Auto->Flags[1][0]=CheckedSet;
      Auto->Flags[1][1]=CheckedSkip;
      Auto->Flags[2][0]=Checked3Set;
      Auto->Flags[2][1]=Checked3Skip;
      Item[IDParent].AutoCount++;
      Ret=TRUE;
    }
  }
  return Ret;
}

//////////////////////////////////////////////////////////////////////////
/* Private:
   Проверяет тип элемента диалога на предмет строки ввода
   (DI_EDIT, DI_FIXEDIT, DI_PSWEDIT) и в случае успеха возвращает TRUE
*/
/* $ 18.07.2000 SVS
   ! элемент DI_COMBOBOX относится к категории строковых редакторов...
*/
int Dialog::IsEdit(int Type)
{
  return(Type==DI_EDIT ||
         Type==DI_FIXEDIT ||
         Type==DI_PSWEDIT ||
         Type == DI_COMBOBOX);
}
/* SVS $ */


//////////////////////////////////////////////////////////////////////////
/* $ 28.07.2000 SVS
   Функция, определяющая - "Может ли элемент диалога иметь фокус ввода"
*/
/* $ 24.08.2000 SVS
   Добавка для DI_USERCONTROL
*/
int Dialog::IsFocused(int Type)
{
  return(Type==DI_EDIT ||
         Type==DI_FIXEDIT ||
         Type==DI_PSWEDIT ||
         Type==DI_COMBOBOX ||
         Type==DI_BUTTON ||
         Type==DI_CHECKBOX ||
         Type==DI_RADIOBUTTON ||
         Type==DI_LISTBOX ||
         Type==DI_USERCONTROL);
}
/* 24.08.2000 SVS $ */
/* SVS $ */


//////////////////////////////////////////////////////////////////////////
/* $ 26.07.2000 SVS
   AutoComplite: Поиск входжение подстроки в истории
*/
/* $ 28.07.2000 SVS
   ! Переметр Edit *EditLine нафиг ненужен!
*/
int Dialog::FindInEditForAC(int TypeFind,void *HistoryName,char *FindStr,int MaxLen)
{
  char *Str;
  int I, LenFindStr=strlen(FindStr);

  if(!TypeFind)
  {
    char RegKey[NM];
    if((Str=(char*)malloc(MaxLen+1)) == NULL)
      return FALSE;
    sprintf(RegKey,fmtSavedDialogHistory,(char*)HistoryName);
    // просмотр пунктов истории
    for (I=0; I < HISTORY_COUNT; I++)
    {
      itoa(I,PHisLine,10);
      GetRegKey(RegKey,HisLine,Str,"",MaxLen);
      if (!LocalStrnicmp(Str,FindStr,LenFindStr))
        break;
    }
    if (I == HISTORY_COUNT)
    {
      free(Str);
      return FALSE;
    }
    /* $ 28.07.2000 SVS
       Введенные буковки не затрагиваем, а дополняем недостающее.
    */
//_D(SysLog("FindInEditForAC()  FindStr=%s Str=%s",FindStr,&Str[strlen(FindStr)]));
    strncat(FindStr,&Str[LenFindStr],MaxLen-LenFindStr);
    /* SVS $ */
    free(Str);
  }
  else
  {
    struct FarListItem *ListItems=((struct FarList *)HistoryName)->Items;
    int Count=((struct FarList *)HistoryName)->ItemsNumber;

    for (I=0; I < Count ;I++)
    {
      if (!LocalStrnicmp(ListItems[I].Text,FindStr,Min(LenFindStr,(int)sizeof(ListItems[I].Text))))
        break;
    }
    if (I  == Count)
      return FALSE;

    if(sizeof(ListItems[I].Text) < LenFindStr)
      strncat(FindStr,&ListItems[I].Text[LenFindStr],MaxLen-LenFindStr);
  }
  return TRUE;
}
/*  SVS $ */

//////////////////////////////////////////////////////////////////////////
/* Private:
   Заполняем выпадающий список для ComboBox
*/
/*
   $ 18.07.2000 SVS
   Функция-обработчик выбора из списка и установки...
*/
int Dialog::SelectFromComboBox(
         Edit *EditLine,                   // строка редактирования
         VMenu *ComboBox,    // список строк
         int MaxLen)
{
  char *Str;
  int EditX1,EditY1,EditX2,EditY2;
  int I,Dest;

  if((Str=(char*)malloc(MaxLen)) != NULL)
  {
    EditLine->GetPosition(EditX1,EditY1,EditX2,EditY2);
    if (EditX2-EditX1<20)
      EditX2=EditX1+20;
    if (EditX2>ScrX)
      EditX2=ScrX;
    ComboBox->SetPosition(EditX1,EditY1+1,EditX2,0);
    // Перед отрисовкой спросим об изменении цветовых атрибутов
    short Colors[VMENU_COLOR_COUNT];
    ComboBox->GetColors(Colors);
    if(DlgProc((HANDLE)this,DN_CTLCOLORDLGLIST,
                    sizeof(Colors)/sizeof(Colors[0]),(long)Colors))
      ComboBox->SetColors(Colors);

    SetDropDownOpened(TRUE); // Установим флаг "открытия" комбобокса.

    // Выставим то, что есть в строке ввода!
    // if(EditLine->DropDownBox == 1) //???
    EditLine->GetString(Str,MaxLen);
    ComboBox->SetSelectPos(ComboBox->FindItem(0,Str,LIFIND_NOPATTERN),1);

    ComboBox->Show();

    Dest=ComboBox->GetSelectPos();
    while (!ComboBox->Done())
    {
      if (!GetDropDownOpened())
      {
        ComboBox->ProcessKey(KEY_ESC);
        continue;
      }
      //int Key=
      ComboBox->ReadInput();
      // здесь можно добавить что-то свое, например,
      I=ComboBox->GetSelectPos();
      if(I != Dest)
      {
        if(!DlgProc((HANDLE)this,DN_LISTCHANGE,FocusPos,I))
          ComboBox->SetSelectPos(Dest,Dest<I?-1:1); //????
        else
          Dest=I;

#if 0
        // во время навигации по DropDown листу - отобразим ЭТО дело в
        // связанной строке
        // ВНИМАНИЕ!!!
        //  Очень медленная реакция!
        if(EditLine->DropDownBox == 1)
        {
          struct MenuItem *CurCBItem=ComboBox->GetItemPtr();
          EditLine->SetString(CurCBItem->Name);
          EditLine->Show();
          //EditLine->FastShow();
        }
#endif
      }
      // обработку multiselect ComboBox
      // ...
      ComboBox->ProcessInput();
    }
    ComboBox->ClearDone();
    ComboBox->Hide();
    if (GetDropDownOpened()) // Закрылся не программным путём?
      Dest=ComboBox->Modal::GetExitCode();
    else
      Dest=-1;
    SetDropDownOpened(FALSE); // Установим флаг "закрытия" комбобокса.
    if (Dest<0)
    {
      free(Str);
      return KEY_ESC;
    }

    ComboBox->GetUserData(Str,MaxLen,Dest);
    EditLine->SetString(Str);
    EditLine->SetLeftPos(0);
    Redraw();
    free(Str);
    return KEY_ENTER;
  }
  return KEY_ESC;
}
/* SVS $ */

//////////////////////////////////////////////////////////////////////////
/* Private:
   Заполняем выпадающий список из истории
*/
/* $ 26.07.2000 SVS
  + Дополнительный параметр в SelectFromEditHistory для выделения
   нужной позиции в истории (если она соответствует строке ввода)
*/
BOOL Dialog::SelectFromEditHistory(struct DialogItem *CurItem,
                                   Edit *EditLine,
                                   char *HistoryName,
                                   char *IStr,
                                   int MaxLen)
/* SVS $ */
/* $ 21.02.2001 IS
     Избавился от утечки памяти (проявлялось не у всех, но проявлялось же!)
*/
{
  if(!EditLine)
    return FALSE;

  char RegKey[NM],Str[4096];
  int I,Dest,Ret=FALSE;
  int Locked;
  int IsOk=FALSE, Done, IsUpdate;
  struct MenuItem HistoryItem;
  int ItemsCount;
  int LastSelected = 0;
  int EditX1,EditY1,EditX2,EditY2;

  sprintf(RegKey,fmtSavedDialogHistory,HistoryName);
  {
    // создание пустого вертикального меню
    VMenu HistoryMenu("",NULL,0,8,VMENU_ALWAYSSCROLLBAR);

    EditLine->GetPosition(EditX1,EditY1,EditX2,EditY2);
    if (EditX2-EditX1<20)
      EditX2=EditX1+20;
    if (EditX2>ScrX)
      EditX2=ScrX;

    HistoryMenu.SetFlags(VMENU_SHOWAMPERSAND);
    HistoryMenu.SetPosition(EditX1,EditY1+1,EditX2,0);
    HistoryMenu.SetBoxType(SHORT_SINGLE_BOX);

    SetDropDownOpened(TRUE); // Установим флаг "открытия" комбобокса.
    Done=FALSE;

    // запомним (для прорисовки)
    CurItem->ListPtr=&HistoryMenu;

    while(!Done)
    {
      IsUpdate=FALSE;

      HistoryMenu.DeleteItems();

      // заполнение пунктов меню
      for (ItemsCount=Dest=I=0; I < HISTORY_COUNT; I++)
      {
        memset(&HistoryItem,0,sizeof(HistoryItem));

        itoa(I,PHisLine,10);
        GetRegKey(RegKey,HisLine,Str,"",sizeof(Str));
        if (*Str==0)
          continue;

        itoa(I,PHisLocked,10);
        GetRegKey(RegKey,HisLocked,(int)Locked,0);
        HistoryItem.SetCheck(Locked);
        strncpy(HistoryItem.Name,Str,sizeof(HistoryItem.Name)-1);
        HistoryMenu.SetUserData(Str,0,
              HistoryMenu.AddItem(&HistoryItem));
        ItemsCount++;
      }
      if (ItemsCount==0)
        break;

      // выставим селекшин
      Dest=Opt.DlgSelectFromHistory?HistoryMenu.FindItem(0,IStr,LIFIND_NOPATTERN):-1;
      HistoryMenu.SetSelectPos(Dest!=-1?Dest:0, 1);
      //  Перед отрисовкой спросим об изменении цветовых атрибутов
      /*$ 14.06.2001 OT */
      short Colors[VMENU_COLOR_COUNT];
      /* OT $*/
      HistoryMenu.GetColors(Colors);
      if(DlgProc((HANDLE)this,DN_CTLCOLORDLGLIST,
                      sizeof(Colors)/sizeof(Colors[0]),(long)Colors))
        HistoryMenu.SetColors(Colors);
      HistoryMenu.Show();

      // основной цикл обработки
      while (!HistoryMenu.Done())
      {
        if (!GetDropDownOpened())
        {
          Ret=FALSE;
          HistoryMenu.ProcessKey(KEY_ESC);
          Done=TRUE;
          continue;
        }

        int Key=HistoryMenu.ReadInput();

        if (Key==KEY_TAB) // Tab в списке хистори - аналог Enter
        {
          HistoryMenu.ProcessKey(KEY_ENTER);
          Ret=TRUE;
          Done=TRUE;
          continue; //??
        }
        else if (Key==KEY_INS) // Ins защищает пункт истории от удаления.
        {
          itoa(HistoryMenu.GetSelectPos(),PHisLocked,10);
          if (!HistoryMenu.GetSelection())
          {
            HistoryMenu.SetSelection(TRUE);
            SetRegKey(RegKey,HisLocked,1);
          }
          else
          {
            HistoryMenu.SetSelection(FALSE);
            DeleteRegValue(RegKey,HisLocked);
          }
          HistoryMenu.SetUpdateRequired(TRUE);
          HistoryMenu.Redraw();
          continue;
        }
        else if (Key==KEY_SHIFTDEL) // Shift-Del очищает текущий пункт истории команд.
        {
          LastSelected=HistoryMenu.GetSelectPos();
          if (!HistoryMenu.GetSelection(LastSelected))
          {
            HistoryMenu.Hide();
            // удаляем из реестра все.
            for (I=0; I < HISTORY_COUNT;I++)
            {
              itoa(I,PHisLocked,10);
              DeleteRegValue(RegKey,HisLocked);
              itoa(I,PHisLine,10);
              DeleteRegValue(RegKey,HisLine);
            }
            // удаляем из списка только то, что требовали
            HistoryMenu.DeleteItem(LastSelected);
            // перестроим список в реестре
            for (Dest=I=0; I < HistoryMenu.GetItemCount(); I++)
            {
               HistoryMenu.GetUserData(Str,sizeof(Str),I);
               itoa(Dest,PHisLine,10);
               SetRegKey(RegKey,HisLine,Str);
               if(HistoryMenu.GetSelection(I))
               {
                 itoa(Dest,PHisLocked,10);
                 SetRegKey(RegKey,HisLocked,TRUE);
               }
               Dest++;
            }

            HistoryMenu.SetUpdateRequired(TRUE);
            IsUpdate=TRUE;
            break;
          }
          continue;
        }
        else if (Key==KEY_DEL) // Del очищает историю команд.
        {
          LastSelected=HistoryMenu.GetSelectPos();

          if (!Opt.Confirm.HistoryClear ||
              (Opt.Confirm.HistoryClear &&
               Message(MSG_WARNING,2,MSG(MHistoryTitle),
                       MSG(MHistoryClear),
                       MSG(MClear),MSG(MCancel))==0))
          {
            HistoryMenu.Hide();

            // удаляем из реестра
            for (I=0; I < HISTORY_COUNT;I++)
            {
              itoa(I,PHisLocked,10);
              DeleteRegValue(RegKey,HisLocked);
              itoa(I,PHisLine,10);
              DeleteRegValue(RegKey,HisLine);
            } /* for */

            // заносим в реестр
            for (Dest=I=0; I < HistoryMenu.GetItemCount(); I++)
            {
              if (HistoryMenu.GetSelection(I))
              {
                HistoryMenu.GetUserData(Str,sizeof(Str),I);
                itoa(Dest,PHisLine,10);
                SetRegKey(RegKey,HisLine,Str);
                itoa(Dest,PHisLocked,10);
                SetRegKey(RegKey,HisLocked,TRUE);
                Dest++;
              } /* if */
            } /* for */
          } /* if */
          HistoryMenu.SetUpdateRequired(TRUE);
          IsUpdate=TRUE;
          break;
        }

        // Сюды надо добавить DN_LISTCHANGE

        HistoryMenu.ProcessInput();
      }

      if(IsUpdate)
        continue;

      int ExitCode=HistoryMenu.Modal::GetExitCode();
      if (ExitCode<0)
      {
        Ret=FALSE;
        Done=TRUE;
//        break;
      }
      else
      {
        HistoryMenu.GetUserData(Str,Min((int)sizeof(Str),MaxLen),ExitCode);
        Ret=TRUE;
        Done=TRUE;
        IsOk=TRUE;
      }
    }

    // забудим (не нужен)
    CurItem->ListPtr=NULL;

    SetDropDownOpened(FALSE); // Установим флаг "закрытия" комбобокса.
  }

  if(IsOk)
  {
    EditLine->SetString(Str);
    EditLine->SetLeftPos(0);
    EditLine->SetClearFlag(0);
    Dialog::SendDlgMessage((HANDLE)this,DN_EDITCHANGE,FocusPos,0);
    Redraw();
  }
  return Ret;
}

//////////////////////////////////////////////////////////////////////////
/* Private:
   Работа с историей - добавление и reorder списка
*/
int Dialog::AddToEditHistory(char *AddStr,char *HistoryName)
{
#define MAXSIZESTRING 4096
  int AddLine=-1, I, J, Locked, HistCount, LockedCount=0;
  char Str[MAXSIZESTRING];
  char RegKey[NM];
  struct HistArray{
    char *Str;
    int  Locked;
  } His[HISTORY_COUNT],HisTemp[HISTORY_COUNT+1];

  sprintf(RegKey,fmtSavedDialogHistory,HistoryName);

  if (*AddStr==0)
  {
    SetRegKey(RegKey,"Flags",(DWORD)0);
    return FALSE;
  }

  memset(His,0,sizeof(His));
  memset(HisTemp,0,sizeof(HisTemp));

  // Read content & delete
  for (HistCount=I=0; I < HISTORY_COUNT; I++)
  {
    itoa(I,PHisLocked,10);
    GetRegKey(RegKey,HisLocked,Locked,0);
    itoa(I,PHisLine,10);
    GetRegKey(RegKey,HisLine,Str,"",sizeof(Str));

    if(*Str)
    {
      if((His[HistCount].Str=strdup(Str)) != NULL)
      {
        His[HistCount].Locked=Locked;
        LockedCount+=Locked;
        DeleteRegValue(RegKey,HisLocked);
        DeleteRegValue(RegKey,HisLine);
        ++HistCount;
      }
    }
  }

  // ищем строку добавления
  for (I=0; I < HistCount; I++)
    if (!LCStricmp(AddStr,His[I].Str))
    {
      // берем только! либо которой нету либо залоченную
      if(AddLine == -1 || AddLine != -1 && His[I].Locked)
        AddLine=I;
    }
  /*
    Здесь у нас:
      если AddLine == -1, то такой строки нету в истории
      если LockedCount == HISTORY_COUNT, все залочено!
  */

  // А можно ли добавлять то?...
  if(LockedCount == HISTORY_COUNT && AddLine == -1)
    J=0;
  else // ...не только можно, но и нужно!
  {
    // добавляем в начало с учетом добавляемого
    HisTemp[0].Str=strdup(AddStr);
    HisTemp[0].Locked=(AddLine == -1)?0:His[AddLine].Locked;
    J=1;
  }

  // Locked вперед
  for (I=0; I < HistCount; I++)
  {
    if(His[I].Locked && His[I].Str)
    {
      if(AddLine == I)
        continue;
      HisTemp[J].Str=His[I].Str;
      /* $ 27.11.2001 DJ
         это потом освобождать не надо
      */
      His[I].Str = NULL;
      /* DJ $ */
      HisTemp[J].Locked=1;
      ++J;
    }
  }

  // UnLocked
  for (I=0; I < HistCount; I++)
  {
    if(!His[I].Locked && His[I].Str)
    {
      if(AddLine == I)
        continue;
      HisTemp[J].Str=His[I].Str;
      /* $ 27.11.2001 DJ
         это потом освобождать не надо
      */
      His[I].Str=NULL;
      /* DJ $ */
      HisTemp[J].Locked=0;
      ++J;
    }
  }

  // исключаем дубликаты
  for (I=0; I < HISTORY_COUNT; I++)
  {
    if(HisTemp[I].Str)
    {
      // поиск среди незалоченных
      for(J=I+1; J < HISTORY_COUNT; ++J)
      {
        if(HisTemp[J].Str)
        {
          if(!LCStricmp(HisTemp[I].Str,HisTemp[J].Str))
          {
            free(HisTemp[J].Str);
            HisTemp[J].Str=NULL;
          }
        }
      }
    }
  }
  // здесь в HisTemp сидит отсортированный список

  // Save History
  for (J=I=0; I < HISTORY_COUNT; I++)
  {
    if(HisTemp[I].Str)
    {
      itoa(J,PHisLocked,10);
      itoa(J,PHisLine,10);
      SetRegKey(RegKey,HisLine,HisTemp[I].Str);
      if(HisTemp[I].Locked)
        SetRegKey(RegKey,HisLocked,HisTemp[I].Locked);
      free(HisTemp[I].Str);
      ++J;
    }
  }

  /* $ 27.11.2001 DJ
     не забудем освободить оставшуюся память
  */
  for (I=0; I<HISTORY_COUNT; I++)
    if (His[I].Str)
      free(His[I].Str);
  /* DJ $ */

  SetRegKey(RegKey,"Flags",1);
  return TRUE;
}


//////////////////////////////////////////////////////////////////////////
/* Public, Static:
   Проверка на HotKey
*/
/* $ 20.02.2001 SVS
   Пересмотр алгоритма IsKeyHighlighted с добавками Alt- на
   сколько это возможно*/
int Dialog::IsKeyHighlighted(char *Str,int Key,int Translate,int AmpPos)
{
  if(AmpPos == -1)
  {
    if ((Str=strchr(Str,'&'))==NULL)
      return(FALSE);
    AmpPos=1;
  }
  else
  {
    if(AmpPos >= (int)strlen(Str))
      return FALSE;
    Str=Str+AmpPos;
    AmpPos=0;
    if(Str[AmpPos] == '&')
      AmpPos++;
  }
//_SVS(SysLog("'%s' (%d)",Str+AmpPos,AmpPos));
  int UpperStrKey=LocalUpper((int)Str[AmpPos]);
  /* $ 08.11.2000 SVS
     Изменен пересчет кодов клавиш для hotkey (используются сканкоды)
  */
  /* 28.12.2000 SVS
    + добавлена обработка Opt.HotkeyRules */
  if (Key < 256)
  {
    int KeyToKey=LocalKeyToKey(Key);
    return(UpperStrKey == (int)LocalUpper(Key) ||
      Translate &&
      (!Opt.HotkeyRules && UpperStrKey==(int)LocalUpper(KeyToKey) ||
        Opt.HotkeyRules && LocalKeyToKey(UpperStrKey)==KeyToKey));
  }

  if(Key&KEY_ALT)
  {
    int AltKey=Key&(~KEY_ALT);
    if(AltKey < 256)
    {
      if (AltKey >= '0' && AltKey <= '9')
        return(AltKey==UpperStrKey);

      int AltKeyToKey=LocalKeyToKey(AltKey);
      if (AltKey > ' ' && AltKey <= 255)
  //         (AltKey=='-'  || AltKey=='/' || AltKey==','  || AltKey=='.' ||
  //          AltKey=='\\' || AltKey=='=' || AltKey=='['  || AltKey==']' ||
  //          AltKey==':'  || AltKey=='"' || AltKey=='~'))
      {
        return(UpperStrKey==(int)LocalUpper(AltKey) ||
               Translate &&
               (!Opt.HotkeyRules && UpperStrKey==(int)LocalUpper(AltKeyToKey) ||
                  Opt.HotkeyRules && LocalKeyToKey(UpperStrKey)==AltKeyToKey));
      }
    }
  }
  /* SVS $*/
  /* SVS $*/
  return(FALSE);
}
/* SVS $ */


//////////////////////////////////////////////////////////////////////////
/* Private:
   Если жмакнули Alt-???
*/
int Dialog::ProcessHighlighting(int Key,int FocusPos,int Translate)
{
  int I, Type;
  DWORD Flags;
  for (I=0;I<ItemCount;I++)
  {
    Type=Item[I].Type;
    Flags=Item[I].Flags;

    if ((!IsEdit(Type) || (Type == DI_COMBOBOX && (Flags&DIF_DROPDOWNLIST))) &&
        (Flags & (DIF_SHOWAMPERSAND|DIF_DISABLE|DIF_HIDDEN))==0)
      if (IsKeyHighlighted(Item[I].Data,Key,Translate))
      {
        int DisableSelect=FALSE;

        // Если ЭТО: Edit(пред контрол) и DI_TEXT в одну строку, то...
        if (I>0 &&
            Type==DI_TEXT &&                              // DI_TEXT
            IsEdit(Item[I-1].Type) &&                     // и редактор
            Item[I].Y1==Item[I-1].Y1 &&                   // и оба в одну строку
            (I+1 < ItemCount && Item[I].Y1!=Item[I+1].Y1)) // ...и следующий контрол в другой строке
        {
          if((Item[I-1].Flags&(DIF_DISABLE|DIF_HIDDEN)) != 0) // и не задисаблен
             break;
          // Сообщим о случивщемся факте процедуре обработки диалога
          if(!DlgProc((HANDLE)this,DN_HOTKEY,I,Key))
            break; // сказали не продолжать обработку...
          I=ChangeFocus(I,-1,FALSE);
          DisableSelect=TRUE;
        }
        else if (Item[I].Type==DI_TEXT      || Item[I].Type==DI_VTEXT ||
                 Item[I].Type==DI_SINGLEBOX || Item[I].Type==DI_DOUBLEBOX)
        {
          if(I+1 < ItemCount && // ...и следующий контрол
            (Item[I+1].Flags&(DIF_DISABLE|DIF_HIDDEN)) != 0) // и не задисаблен
             break;
          // Сообщим о случивщемся факте процедуре обработки диалога
          if(!DlgProc((HANDLE)this,DN_HOTKEY,I,Key))
            break; // сказали не продолжать обработку...
          I=ChangeFocus(I,1,FALSE);
          DisableSelect=TRUE;
        }
        /* $ 29.08.2000 SVS
           - Первый официальный альфа-баг - функция ProcessHighlighting
           MY> Работа с диалогами стала ГЛЮЧНАЯ. Я имею в виду горячие клавиши.
           MY> Входим в настройку чего угодно, жмем Alt-нужную букву и
           MY> наблюдаем разнообразные глюки.

           А ларчик просто открывался :-)))
        */
        // Сообщим о случивщемся факте процедуре обработки диалога
        if(!DlgProc((HANDLE)this,DN_HOTKEY,I,Key))
          break; // сказали не продолжать обработку...
        ChangeFocus2(FocusPos,I);
        ShowDialog();
        /* SVS $ */
        if ((Item[I].Type==DI_CHECKBOX || Item[I].Type==DI_RADIOBUTTON) &&
            (!DisableSelect || (Item[I].Flags & DIF_MOVESELECT)))
        {
          ProcessKey(KEY_SPACE);
          return(TRUE);
        }
        else if (Item[I].Type==DI_BUTTON)
        {
          ProcessKey(KEY_ENTER);
          return(TRUE);
        }
        // при ComboBox`е - "вываливаем" последний //????
        else if (Item[I].Type==DI_COMBOBOX)
        {
          ProcessKey(KEY_CTRLDOWN);
          return(TRUE);
        }
        return(TRUE);
      }
  }
  return(FALSE);
}


//////////////////////////////////////////////////////////////////////////
/* $ 31.07.2000 tran
   + функция подравнивания координат edit классов */
/* $ 07.08.2000 SVS
   + а про ListBox забыли?*/
void Dialog::AdjustEditPos(int dx, int dy)
{
  struct DialogItem *CurItem;
  int I;
  int x1,x2,y1,y2;

  if(!DialogMode.Check(DMODE_CREATEOBJECTS))
    return;

  ScreenObject *DialogScrObject;
  for (I=0; I < ItemCount; I++)
  {
    CurItem=&Item[I];
    int Type=CurItem->Type;
    if (CurItem->ObjPtr  && IsEdit(Type) ||
        CurItem->ListPtr && Type == DI_LISTBOX)
    {
       if(Type == DI_LISTBOX)
         DialogScrObject=(ScreenObject *)CurItem->ListPtr;
       else
         DialogScrObject=(ScreenObject *)CurItem->ObjPtr;
       DialogScrObject->GetPosition(x1,y1,x2,y2);
       x1+=dx;
       x2+=dx;
       y1+=dy;
       y2+=dy;
       DialogScrObject->SetPosition(x1,y1,x2,y2);
    }
  }
  ProcessCenterGroup();
}
/* SVS $ */
/* tran 31.07.2000 $ */


//////////////////////////////////////////////////////////////////////////
/* $ 11.08.2000 SVS
   Работа с доп. данными экземпляра диалога
   Пока простое копирование (присвоение)
*/
void Dialog::SetDialogData(long NewDataDialog)
{
  DataDialog=NewDataDialog;
}
/* SVS $ */

//////////////////////////////////////////////////////////////////////////
/* $ 11.08.2000 SVS
   + Для того, чтобы послать DM_CLOSE нужно переопределить Process
*/
void Dialog::Process()
{
  /* $ 17.05.2001 DJ
     NDZ
  */
  FrameManager->ExecuteModal (this);
  /* DJ $ */
}
/* SVS $ */

/* $ 18.05.2001 DJ */

void Dialog::CloseDialog()
{
  GetDialogObjectsData();
  if (DlgProc ((HANDLE)this,DM_CLOSE,ExitCode,0))
  {
    DialogMode.Set(DMODE_ENDLOOP);
    FrameManager->DeleteFrame (this);
    _DIALOG(CleverSysLog CL("Close Dialog"));
  }
}

/* DJ $ */

/* $ 17.05.2001 DJ
   установка help topic'а и прочие радости, временно перетащенные сюда
   из Modal
*/

void Dialog::SetHelp (const char *Topic)
{
  if (HelpTopic)
    delete[] HelpTopic;
  HelpTopic=NULL;

  if(Topic && *Topic)
  {
    HelpTopic = new char [strlen (Topic)+1];
    if(HelpTopic)
      strcpy (HelpTopic, Topic);
  }
}

void Dialog::ShowHelp()
{
  if (HelpTopic && *HelpTopic)
  {
    Help Hlp (HelpTopic);
  }
}

void Dialog::ClearDone()
{
  DialogMode.Skip(DMODE_ENDLOOP);
}

void Dialog::SetExitCode(int Code)
{
  ExitCode=Code;
  DialogMode.Set(DMODE_ENDLOOP);
  //CloseDialog();
}

/* DJ $ */

/* $ 19.05.2001 DJ
   возвращаем наше название для меню по F12
*/

int Dialog::GetTypeAndName (char *Type, char *Name)
{
  strcpy (Type, MSG(MDialogType));
  strcpy (Name, GetDialogTitle());
  return MODALTYPE_DIALOG;
}

/* DJ $ */

int Dialog::GetMacroMode()
{
  return MACRO_DIALOG;
}

int Dialog::FastHide()
{
  return Opt.AllCtrlAltShiftRule & CASR_DIALOG;
}

void Dialog::ResizeConsole()
{
  COORD c;
  DialogMode.Set(DMODE_RESIZED);
  Hide();
  // коррекция относительного положения диалога (чтобы не центрировать :-)
  c.X=ScrX+1; c.Y=ScrY+1;
  Dialog::SendDlgMessage((HANDLE)this,DN_RESIZECONSOLE,0,(long)&c);

  // !!!!!!!!!!! здесь нужно правильно вычислить положение !!!!!!!!!!!
  //c.X=((X1*100/PrevScrX)*ScrX)/100;
  //c.Y=((Y1*100/PrevScrY)*ScrY)/100;
  // !!!!!!!!!!! здесь нужно правильно вычислить положение !!!!!!!!!!!
  c.X=c.Y=-1;
  Dialog::SendDlgMessage((HANDLE)this,DM_MOVEDIALOG,TRUE,(long)&c);
};

void Dialog::OnDestroy()
{
  if(DialogMode.Check(DMODE_RESIZED))
  {
    FrameManager->GetBottomFrame()->UnlockRefresh();
    Dialog::SendDlgMessage((HANDLE)this,DM_KILLSAVESCREEN,0,0);
  }
};

//////////////////////////////////////////////////////////////////////////
/* $ 28.07.2000 SVS
   функция обработки диалога (по умолчанию)
   Вот именно эта функция и является последним рубежом обработки диалога.
   Т.е. здесь должна быть ВСЯ обработка ВСЕХ сообщений!!!
*/
/* $ 02.07.2001 KM
   - Избавимся от потенциального (и кажется не только) бага
     при Param1==-1.
*/

long WINAPI Dialog::DefDlgProc(HANDLE hDlg,int Msg,int Param1,long Param2)
{
  Dialog* Dlg=(Dialog*)hDlg;
  struct DialogItem *CurItem=NULL;
  char *Ptr=NULL;
  int Type=0;
  _DIALOG(CleverSysLog CL("Dialog.DefDlgProc()"));
  _DIALOG(SysLog("hDlg=%p, Msg=%s, Param1=%d (0x%08X), Param2=%d (0x%08X)",hDlg,_DLGMSG_ToName(Msg),Param1,Param1,Param2,Param2));
  if(!Dlg)
    return 0;

  switch(Msg)
  {
    case DN_INITDIALOG:
      return FALSE; // изменений не было!

    case DM_CLOSE:
      return TRUE;  // согласен с закрытием

    case DN_KILLFOCUS:
      return -1;    // "Согласен с потерей фокуса"

    case DN_GOTFOCUS:
      return 0;     // always 0

    case DN_HELP:
      return Param2; // что передали, то и...

    case DN_DRAGGED:
      return TRUE; // согласен с перемещалкой.

    case DN_DRAWDIALOG:
    {
      if(Param1 == 1)  // Нужно отрисовать "салазки"?
      {
        /* $ 03.08.2000 tran
           вывод текста в углу может приводить к ошибкам изображения
           1) когда диалог перемещается в угол
           2) когда диалог перемещается из угла
           сделал вывод красных палочек по углам */
        Text(Dlg->X1,Dlg->Y1,0xCE,"\\");
        Text(Dlg->X1,Dlg->Y2,0xCE,"/");
        Text(Dlg->X2,Dlg->Y1,0xCE,"/");
        Text(Dlg->X2,Dlg->Y2,0xCE,"\\");
      }
      return TRUE;
    }

    case DN_CTLCOLORDIALOG:
      return Param2;

    case DN_CTLCOLORDLGITEM:
      return Param2;

    case DN_CTLCOLORDLGLIST:
      return FALSE;

    case DN_ENTERIDLE:
      return 0;     // always 0
  }

  // предварительно проверим...
  if(Param1 >= Dlg->ItemCount && Dlg->Item)
    return 0;

  if (Param1>=0)
  {
    CurItem=&Dlg->Item[Param1];
    Type=CurItem->Type;
    Ptr=CurItem->Data;
  }

  switch(Msg)
  {
    case DN_MOUSECLICK:
      return FALSE;

    case DN_DRAWDLGITEM:
      return TRUE;

    case DN_HOTKEY:
      return TRUE;

    case DN_EDITCHANGE:
      return TRUE;

    case DN_BTNCLICK:
      return ((Type==DI_BUTTON)?FALSE:TRUE);

    case DN_LISTCHANGE:
      return TRUE;

    /* $ 23.08.2000 SVS
       + получить клавишу(ы)
    */
    case DM_KEY:
      return FALSE;
    /* SVS $ */

    case DN_MOUSEEVENT:
      return TRUE;
  }

  return 0;
}
/* SVS $ */


//////////////////////////////////////////////////////////////////////////
/* $ 28.07.2000 SVS
   Посылка сообщения диалогу
   Некоторые сообщения эта функция обрабатывает сама, не передавая управление
   обработчику диалога.
*/
/* $ 02.07.2001 KM
   - Избавимся от потенциального (и кажется не только) бага
     при Param1==-1.
*/
long WINAPI Dialog::SendDlgMessage(HANDLE hDlg,int Msg,int Param1,long Param2)
{
  Dialog* Dlg=(Dialog*)hDlg;
  struct DialogItem *CurItem=NULL;
  int Type=0;
  char *Ptr=NULL;
  char Str[1024];
  int Len, I;
  struct FarDialogItem PluginDialogItem;

  _DIALOG(CleverSysLog CL("Dialog.SendDlgMessage()"));
  _DIALOG(SysLog("hDlg=%p, Msg=%s, Param1=%d (0x%08X), Param2=%d (0x%08X)",hDlg,_DLGMSG_ToName(Msg),Param1,Param1,Param2,Param2));

  if(!Dlg)
    return 0;
  // предварительно проверим...

  /* $ 09.12.2001 DJ
     для DM_KEY и DM_USER проверять _не_надо_!
  */
  if((Msg != DM_KEY && Msg < DM_USER && Param1 >= Dlg->ItemCount) || !Dlg->Item)
    return 0;
  /* DJ $ */

//  CurItem=&Dlg->Item[Param1];
  if (Param1>=0)
  {
    CurItem=Dlg->Item+Param1;
    Type=CurItem->Type;
    Ptr=CurItem->Data;
  }

  switch(Msg)
  {
    /*****************************************************************/
    case DM_LISTSORT: // Param1=ID Param=Direct {0|1}
    case DM_LISTADD: // Param1=ID Param2=FarList: ItemsNumber=Count, Items=Src
    case DM_LISTADDSTR: // Param1=ID Param2=String
    case DM_LISTDELETE: // Param1=ID Param2=FarListDelete: StartIndex=BeginIndex, Count=количество (<=0 - все!)
    case DM_LISTGETITEM: // Param1=ID Param2=FarListGetItem: ItemsNumber=Index, Items=Dest
    case DM_LISTSET: // Param1=ID Param2=FarList: ItemsNumber=Count, Items=Src
    case DM_LISTGETCURPOS: // Param1=ID Param2=FarListPos
    case DM_LISTSETCURPOS: // Param1=ID Param2=FarListPos Ret: RealPos
    case DM_LISTUPDATE: // Param1=ID Param2=FarList: ItemsNumber=Index, Items=Src
    case DM_LISTINFO:// Param1=ID Param2=FarListInfo
    case DM_LISTFINDSTRING: // Param1=ID Param2=FarListFind
    case DM_LISTINSERT: // Param1=ID Param2=FarListInsert
    case DM_LISTGETDATA: // Param1=ID Param2=Index
    case DM_LISTSETDATA: // Param1=ID Param2=struct FarListItemData
    case DM_LISTSETTITLES: // Param1=ID Param2=struct FarListTitles: TitleLen=strlen(Title), BottomLen=strlen(Bottom)
    case DM_LISTGETTITLES: // Param1=ID Param2=struct FarListTitles: TitleLen=strlen(Title), BottomLen=strlen(Bottom)
    case DM_LISTGETDATASIZE: // Param1=ID Param2=Index
    case DM_LISTSETMOUSEREACTION: // Param1=ID Param2=TRUE/FALSE Ret=OldSets
    {
      if(Type==DI_LISTBOX || Type==DI_COMBOBOX)
      {
        VMenu *ListBox;
        ListBox=CurItem->ListPtr;
        if(ListBox)
        {
          int Ret=TRUE;
          switch(Msg)
          {
            case DM_LISTFINDSTRING: // Param1=ID Param2=FarListFind
            {
              return ListBox->FindItem(((struct FarListFind *)Param2)->StartIndex,
                                       ((struct FarListFind *)Param2)->Pattern,
                                       ((struct FarListFind *)Param2)->Flags);
            }

            case DM_LISTINSERT: // Param1=ID Param2=FarListInsert
            {
              if((Ret=ListBox->InsertItem((struct FarListInsert *)Param2)) == -1)
                return -1;
              break;
            }

            case DM_LISTINFO:// Param1=ID Param2=FarListInfo
            {
              return ListBox->GetVMenuInfo((struct FarListInfo*)Param2);
            }

            case DM_LISTSORT: // Param1=ID Param=Direct {0|1}
            {
              ListBox->SortItems(Param2);
              break;
            }

            case DM_LISTADDSTR: // Param1=ID Param2=String
            {
              Ret=ListBox->AddItem((char*)Param2);
              break;
            }

            case DM_LISTADD: // Param1=ID Param2=FarList: ItemsNumber=Count, Items=Src
            {
              struct FarList *ListItems=(struct FarList *)Param2;
              if(!ListItems)
                return FALSE;
              Ret=ListBox->AddItem(ListItems);
              break;
            }

            case DM_LISTDELETE: // Param1=ID Param2=FarListDelete: StartIndex=BeginIndex, Count=количество (<=0 - все!)
            {
              int Count;
              struct FarListDelete *ListItems=(struct FarListDelete *)Param2;
              if(!ListItems || (Count=ListItems->Count) <= 0)
                ListBox->DeleteItems();
              else
                ListBox->DeleteItem(ListItems->StartIndex,Count);
              break;
            }

            case DM_LISTGETDATA: // Param1=ID Param2=Index
            {
              if(Param2 < ListBox->GetItemCount())
                return (long)ListBox->GetUserData(NULL,0,Param2);
              return NULL;
            }

            case DM_LISTGETDATASIZE: // Param1=ID Param2=Index
            {
              if(Param2 < ListBox->GetItemCount())
                return ListBox->GetUserDataSize(Param2);
              return 0;
            }

            case DM_LISTSETDATA: // Param1=ID Param2=struct FarListItemData
            {
              struct FarListItemData *ListItems=(struct FarListItemData *)Param2;
              if(ListItems &&
                 ListItems->Index < ListBox->GetItemCount())
              {
                  return ListBox->SetUserData(ListItems->Data,
                                              ListItems->DataSize,
                                              ListItems->Index);
              }
              return 0;
            }

            case DM_LISTSETTITLES: // Param1=ID Param2=struct FarListTitles
            {
              struct FarListTitles *ListTitle=(struct FarListTitles *)Param2;
              ListBox->SetTitle((!ListTitle)?NULL:ListTitle->Title);
              ListBox->SetBottomTitle((!ListTitle)?NULL:ListTitle->Bottom);
              return TRUE;
            }

            case DM_LISTGETTITLES: // Param1=ID Param2=struct FarListTitles
            {
              struct FarListTitles *ListTitle=(struct FarListTitles *)Param2;
              if(ListTitle)
              {
                if (ListBox->GetTitle(ListTitle->Title,ListTitle->TitleLen) ||
                    ListBox->GetTitle(ListTitle->Bottom,ListTitle->BottomLen))
                  return TRUE;
              }
              return FALSE;
            }

            case DM_LISTGETCURPOS: // Param1=ID Param2=FarListPos
            {
              if (Param2)
                return ListBox->GetSelectPos((struct FarListPos *)Param2);
              else
                return ListBox->GetSelectPos();
            }

            case DM_LISTSETCURPOS: // Param1=ID Param2=FarListPos Ret: RealPos
            {
              /* 26.06.2001 KM Подадим перед изменением позиции об этом сообщение */
              int CurListPos=ListBox->GetSelectPos();
              Ret=ListBox->SetSelectPos((struct FarListPos *)Param2);
              if(Ret!=CurListPos)
                if(!Dlg->DlgProc(hDlg,DN_LISTCHANGE,Param1,Ret))
                  Ret=ListBox->SetSelectPos(CurListPos,1);
              /* KM $ */
              break; // т.к. нужно перерисовать!
            }

            case DM_LISTUPDATE: // Param1=ID Param2=FarList: Index=Index, Items=Src
            {
              if(Param2 && ListBox->UpdateItem((struct FarList *)Param2))
                break;
              return FALSE;
            }

            case DM_LISTGETITEM: // Param1=ID Param2=FarListGetItem: ItemsNumber=Index, Items=Dest
            {
              struct FarListGetItem *ListItems=(struct FarListGetItem *)Param2;
              if(!ListItems)
                return FALSE;
              struct MenuItem *ListMenuItem;
              if((ListMenuItem=ListBox->GetItemPtr(ListItems->ItemIndex)) != NULL)
              {
                //ListItems->ItemIndex=1;
                struct FarListItem *Item=&ListItems->Item;
                memset(Item,0,sizeof(struct FarListItem));
                Item->Flags=ListMenuItem->Flags;
                strncpy(Item->Text,ListMenuItem->Name,sizeof(Item->Text)-1);
                return TRUE;
              }
              return FALSE;
            }
            /* $ 02.12.2001 KM
               + Сообщение для добавления в список строк, с удалением
                 уже существующих, т.с. "чистая" установка
            */
            case DM_LISTSET: // Param1=ID Param2=FarList: ItemsNumber=Count, Items=Src
            {
              struct FarList *ListItems=(struct FarList *)Param2;
              if(!ListItems)
                return FALSE;
              ListBox->DeleteItems();
              Ret=ListBox->AddItem(ListItems);
              break;
            }
            /* KM $ */
            //case DM_LISTINS: // Param1=ID Param2=FarList: ItemsNumber=Index, Items=Dest

            case DM_LISTSETMOUSEREACTION: // Param1=ID Param2=TRUE/FALSE Ret=OldSets
            {
              DWORD OldSets=Dlg->DialogMode.Check(DMODE_MOUSELIST)?TRUE:FALSE;
              Dlg->SetListMouseReaction(Param2);
              return OldSets;
            }
          }
          // уточнение для DI_COMBOBOX - здесь еще и Edit нужно корректно заполнить
          if(Type==DI_COMBOBOX && CurItem->ObjPtr)
          {
            struct MenuItem *ListMenuItem;
            if((ListMenuItem=ListBox->GetItemPtr(ListBox->GetSelectPos())) != NULL)
            {
              ((Edit *)(CurItem->ObjPtr))->SetString(ListMenuItem->Name);
              ((Edit *)(CurItem->ObjPtr))->Select(-1,-1); // снимаем выделение
            }
          }

          if(Dlg->DialogMode.Check(DMODE_SHOW) && ListBox->UpdateRequired())
          {
            Dlg->ShowDialog(Param1);
            ScrBuf.Flush();
          }
          return Ret;
        }
      }
      return FALSE;
    }

    /*****************************************************************/
    case DM_SETHISTORY: // Param1 = ID, Param2 = LPSTR HistoryName
    {
      if(Type==DI_EDIT || Type==DI_FIXEDIT)
      {
        if(Param2 && *(char *)Param2)
        {
          CurItem->Flags|=DIF_HISTORY;
          CurItem->History=(char *)Param2;
          if(Type==DI_EDIT && (CurItem->Flags&DIF_USELASTHISTORY))
          {
            /* $ 09.12.2001 DJ
               вынесем в отдельную функцию
            */
            Dlg->ProcessLastHistory (CurItem, Param1);
      /* DJ $ */
          }
        }
        else
        {
          CurItem->Flags&=~DIF_HISTORY;
          CurItem->History=NULL;
        }
        if(Dlg->DialogMode.Check(DMODE_SHOW))
        {
          Dlg->ShowDialog(Param1);
          ScrBuf.Flush();
        }
        return TRUE;
      }
      return FALSE;
    }

    /*****************************************************************/
    case DM_ADDHISTORY:
    {
      if(Param2 &&
         (Type==DI_EDIT || Type==DI_FIXEDIT) &&
         (CurItem->Flags & DIF_HISTORY))
      {
        return Dlg->AddToEditHistory((char*)Param2,CurItem->History);
      }
      return FALSE;
    }

    /*****************************************************************/
    /* $ 23.10.2000 SVS
       Получить/установить позицию в строках редактирования
    */
    case DM_GETCURSORPOS:
    {
      if(!Param2)
        return FALSE;
      if (IsEdit(Type) && CurItem->ObjPtr)
      {
        ((COORD*)Param2)->X=((Edit *)(CurItem->ObjPtr))->GetCurPos();
        ((COORD*)Param2)->Y=0;
        return TRUE;
      }
      else if(Type == DI_USERCONTROL && CurItem->UCData)
      {
        ((COORD*)Param2)->X=CurItem->UCData->CursorPos.X;
        ((COORD*)Param2)->Y=CurItem->UCData->CursorPos.Y;
        return TRUE;
      }
      return FALSE;
    }

    /*****************************************************************/
    case DM_SETCURSORPOS:
    {
      if (IsEdit(Type) && CurItem->ObjPtr)
      {
        ((Edit *)(CurItem->ObjPtr))->SetCurPos(((COORD*)Param2)->X);
        return TRUE;
      }
      else if(Type == DI_USERCONTROL && CurItem->UCData)
      {
        // учтем, что координаты для этого элемента всегда относительные!
        //  и начинаются с 0,0
        COORD Coord=*(COORD*)Param2;
        Coord.X+=CurItem->X1;
        if(Coord.X > CurItem->X2)
          Coord.X=CurItem->X2;

        Coord.Y+=CurItem->Y1;
        if(Coord.Y > CurItem->Y2)
          Coord.Y=CurItem->Y2;

        // Запомним
        CurItem->UCData->CursorPos.X=Coord.X-CurItem->X1;
        CurItem->UCData->CursorPos.Y=Coord.Y-CurItem->Y1;
        // переместим если надо
        if(Dlg->DialogMode.Check(DMODE_SHOW) && Dlg->FocusPos == Param1)
        {
           // что-то одно надо убрать :-)
           MoveCursor(Coord.X+Dlg->X1,Coord.Y+Dlg->Y1); // ???
           Dlg->ShowDialog(); //???
        }
        return TRUE;
      }
      return FALSE;
    }

    /*****************************************************************/
    /* $ 23.10.2000 SVS
       Получить/установить размер курсора
       Param2=0
       Return MAKELONG(Visible,Size)
    */
    case DM_GETCURSORSIZE:
    {
      if (IsEdit(Type) && CurItem->ObjPtr)
      {
        int Visible,Size;
        ((Edit *)(CurItem->ObjPtr))->GetCursorType(Visible,Size);
        return MAKELONG(Visible,Size);
      }
      else if(Type == DI_USERCONTROL && CurItem->UCData)
      {
        return MAKELONG(CurItem->UCData->CursorVisible,CurItem->UCData->CursorSize);
      }
      return FALSE;
    }

    /*****************************************************************/
    // Param2=MAKELONG(Visible,Size)
    //   Return MAKELONG(OldVisible,OldSize)
    case DM_SETCURSORSIZE:
    {
      int Visible=0,Size=0;
      if (IsEdit(Type) && CurItem->ObjPtr)
      {
        ((Edit *)(CurItem->ObjPtr))->GetCursorType(Visible,Size);
        ((Edit *)(CurItem->ObjPtr))->SetCursorType(LOWORD(Param2),HIWORD(Param2));
      }
      else if(Type == DI_USERCONTROL && CurItem->UCData)
      {
        Visible=CurItem->UCData->CursorVisible;
        Size=CurItem->UCData->CursorSize;

        CurItem->UCData->CursorVisible=LOWORD(Param2);
        CurItem->UCData->CursorSize=HIWORD(Param2);

        int CCX=CurItem->UCData->CursorPos.X;
        int CCY=CurItem->UCData->CursorPos.Y;
        if(Dlg->DialogMode.Check(DMODE_SHOW) &&
           Dlg->FocusPos == Param1 &&
           CCX != -1 && CCY != -1)
          SetCursorType(CurItem->UCData->CursorVisible,CurItem->UCData->CursorSize);
      }
      return MAKELONG(Visible,Size);
    }

    /*****************************************************************/
    case DN_LISTCHANGE:
    {
      return Dlg->DlgProc(hDlg,Msg,Param1,Param2);
    }

    /*****************************************************************/
    case DN_EDITCHANGE:
    {
      Dialog::ConvertItem(CVTITEM_TOPLUGIN,&PluginDialogItem,CurItem,1,TRUE);
      if((I=Dlg->DlgProc(hDlg,DN_EDITCHANGE,Param1,(long)&PluginDialogItem)) == TRUE)
        Dialog::ConvertItem(CVTITEM_FROMPLUGIN,&PluginDialogItem,CurItem,1,TRUE);
      return I;
    }

    /*****************************************************************/
    case DN_BTNCLICK:
    {
      int Ret=Dlg->DlgProc(hDlg,Msg,Param1,Param2);
      if(Ret && (CurItem->Flags&DIF_AUTOMATION) && CurItem->AutoCount && CurItem->AutoPtr)
      {
        DialogItemAutomation* Auto=CurItem->AutoPtr;
        Param2%=3;
        for(I=0; I < CurItem->AutoCount; ++I, ++Auto)
        {
          DWORD NewFlags=Dlg->Item[Auto->ID].Flags;
          Dlg->Item[Auto->ID].Flags=(NewFlags&(~Auto->Flags[Param2][1]))|Auto->Flags[Param2][0];
          // здесь намеренно в обработчик не посылаются эвенты об изменении
          // состояния...
        }
      }
      return Ret;
    }

    /*****************************************************************/
    case DM_GETCHECK:
    {
      if(Type==DI_CHECKBOX || Type==DI_RADIOBUTTON)
        return CurItem->Selected;
      return 0;
    }

    /*****************************************************************/
    case DM_SET3STATE:
    {
      if(Type == DI_CHECKBOX)
      {
        int OldState=CurItem->Flags&DIF_3STATE?TRUE:FALSE;
        if(Param2)
          CurItem->Flags|=DIF_3STATE;
        else
          CurItem->Flags&=~DIF_3STATE;
        return OldState;
      }
      return 0;
    }

    /*****************************************************************/
    case DM_SETCHECK:
    {
      if(Type == DI_CHECKBOX || Type == DI_RADIOBUTTON)
      {
        int Selected=CurItem->Selected;
        if(Type == DI_CHECKBOX && (CurItem->Flags&DIF_3STATE))
          Param2%=3;
        else
          Param2&=1;
        CurItem->Selected=Param2;
        if(CurItem->Selected != (unsigned int)Param2 && Dlg->DialogMode.Check(DMODE_SHOW))
        {
          Dlg->ShowDialog(Param1);
          ScrBuf.Flush();
        }
        return Selected;
      }
      return 0;
    }

    /*****************************************************************/
    case DN_DRAWDLGITEM:
    {
      // преобразуем данные для!
      Dialog::ConvertItem(CVTITEM_TOPLUGIN,&PluginDialogItem,CurItem,1);
      I=Dlg->DlgProc(hDlg,Msg,Param1,(long)&PluginDialogItem);
      Dialog::ConvertItem(CVTITEM_FROMPLUGIN,&PluginDialogItem,CurItem,1);
      return I;
    }

    /*****************************************************************/
    case DM_REDRAW:
    {
      if(Dlg->DialogMode.Check(DMODE_INITOBJECTS))
        Dlg->Show();
      return 0;
    }

    /*****************************************************************/
    /* $ 08.09.2000 SVS
      - Если коротко, то DM_SETFOCUS вроде как и работал :-)
    */
    case DM_SETFOCUS:
    {
//      if(!Dialog::IsFocused(Dlg->Item[Param1].Type))
//        return FALSE;
      if(Dlg->FocusPos == Param1) // уже и так установлено все!
        return TRUE;
      if(Dlg->ChangeFocus2(Dlg->FocusPos,Param1) == Param1)
      {
        Dlg->ShowDialog();
        return TRUE;
      }
      return FALSE;
    }

    /*****************************************************************/
    case DM_GETFOCUS: // Получить ID фокуса
    {
      return Dlg->FocusPos;
    }

    /*****************************************************************/
    case DM_GETTEXTPTR:
      if(Param2)
      {
        struct FarDialogItemData IData;
        IData.PtrData=(char *)Param2;
        IData.PtrLength=0;
        return Dialog::SendDlgMessage(hDlg,DM_GETTEXT,Param1,(long)&IData);
      }

    /*****************************************************************/
    case DM_GETTEXT:
      if(Param2) // если здесь NULL, то это еще один способ получить размер
      {
        struct FarDialogItemData *did=(struct FarDialogItemData*)Param2;
        Len=0;
        switch(Type)
        {
          case DI_COMBOBOX:
          case DI_EDIT:
          case DI_PSWEDIT:
          case DI_FIXEDIT:
            if(!CurItem->ObjPtr)
              break;
            ((Edit *)(CurItem->ObjPtr))->GetString(Str,sizeof(Str));
            Ptr=Str;

          case DI_TEXT:
          case DI_VTEXT:
          case DI_SINGLEBOX:
          case DI_DOUBLEBOX:
          case DI_CHECKBOX:
          case DI_RADIOBUTTON:
          case DI_BUTTON:

            Len=strlen(Ptr)+1;
            if (!(CurItem->Flags & DIF_NOBRACKETS) && Type == DI_BUTTON)
            {
              Ptr+=2;
              Len-=4;
            }

            if(!did->PtrLength)
              did->PtrLength=Len;
            else if(Len > did->PtrLength)
              Len=did->PtrLength;

            if(Len > 0 && did->PtrData)
            {
              memmove(did->PtrData,Ptr,Len);
              did->PtrData[Len]=0;
            }
            break;

          case DI_USERCONTROL:
            did->PtrLength=CurItem->Ptr.PtrLength;
            did->PtrData=(char*)CurItem->Ptr.PtrData;
            break;

          case DI_LISTBOX:
          {
//            if(!CurItem->ListPtr)
//              break;
//            did->PtrLength=CurItem->ListPtr->GetUserData(did->PtrData,did->PtrLength,-1);
            break;
          }

          default:  // подразумеваем, что остались
            did->PtrLength=0;
            break;
        }
        return Len-(!Len?0:1);
      }
      // здесь умышленно не ставим return, т.к. хотим получить размер
      // следовательно сразу должен идти "case DM_GETTEXTLENGTH"!!!

    /*****************************************************************/
    case DM_GETTEXTLENGTH:
      switch(Type)
      {
        case DI_BUTTON:
          Len=strlen(Ptr)+1;
          if (!(CurItem->Flags & DIF_NOBRACKETS))
            Len-=4;
          break;

        case DI_USERCONTROL:
          Len=CurItem->Ptr.PtrLength;
          break;

        case DI_TEXT:
        case DI_VTEXT:
        case DI_SINGLEBOX:
        case DI_DOUBLEBOX:
        case DI_CHECKBOX:
        case DI_RADIOBUTTON:
          Len=strlen(Ptr)+1;
          break;

        case DI_COMBOBOX:
        case DI_EDIT:
        case DI_PSWEDIT:
        case DI_FIXEDIT:
          if(CurItem->ObjPtr)
          {
            Len=((Edit *)(CurItem->ObjPtr))->GetLength()+1;
            break;
          }

        case DI_LISTBOX:
        {
          Len=0;
          struct MenuItem *ListMenuItem;
          if((ListMenuItem=CurItem->ListPtr->GetItemPtr(-1)) != NULL)
          {
            Len=strlen(ListMenuItem->Name)+1;
          }
          break;
        }

        default:
          Len=0;
          break;
      }
      return Len-(!Len?0:1);

    /*****************************************************************/
    case DM_SETTEXTPTR:
    {
      if(!Param2)
        return 0;

      struct FarDialogItemData IData;
      IData.PtrData=(char *)Param2;
      IData.PtrLength=strlen(IData.PtrData);
      return Dialog::SendDlgMessage(hDlg,DM_SETTEXT,Param1,(long)&IData);
    }

    /*****************************************************************/
    case DM_SETTEXT:
      if(Param2)
      {
        int NeedInit=TRUE;
        struct FarDialogItemData *did=(struct FarDialogItemData*)Param2;
        switch(Type)
        {
          case DI_TEXT:
          case DI_VTEXT:
          case DI_SINGLEBOX:
          case DI_DOUBLEBOX:
          case DI_BUTTON:
          case DI_CHECKBOX:
          case DI_RADIOBUTTON:
          case DI_COMBOBOX:
          case DI_EDIT:
          case DI_PSWEDIT:
          case DI_FIXEDIT:
            if((Len=did->PtrLength) == 0)
            {
              strncpy(Ptr,(char *)did->PtrData,511);
              Len=strlen(Ptr)+1;
            }
            else
            {
              if((unsigned)did->PtrLength > 511)
                Len=511;
              if(Len > 0)
                memmove(Ptr,(char *)did->PtrData,Len);
              Ptr[Len]=0;
            }
            break;
          default:
            Len=0;
            break;
        }

        switch(Type)
        {
          case DI_USERCONTROL:
            CurItem->Ptr.PtrLength=did->PtrLength;
            CurItem->Ptr.PtrData=did->PtrData;
            return CurItem->Ptr.PtrLength;

          case DI_TEXT:
          case DI_VTEXT:
          case DI_SINGLEBOX:
          case DI_DOUBLEBOX:
            if(Dlg->DialogMode.Check(DMODE_SHOW))
            {
              SetFarTitle(Dlg->GetDialogTitle());
              Dlg->ShowDialog(Param1);
              ScrBuf.Flush();
            }
            return Len-(!Len?0:1);

          case DI_BUTTON:
          case DI_CHECKBOX:
          case DI_RADIOBUTTON:
            break;

          case DI_COMBOBOX:
          case DI_EDIT:
          case DI_PSWEDIT:
          case DI_FIXEDIT:
            NeedInit=FALSE;
            if(CurItem->ObjPtr)
            {
              int ReadOnly=((Edit *)(CurItem->ObjPtr))->ReadOnly;
              ((Edit *)(CurItem->ObjPtr))->ReadOnly=0;
              ((Edit *)(CurItem->ObjPtr))->SetString((char *)Ptr);
              ((Edit *)(CurItem->ObjPtr))->ReadOnly=ReadOnly;
              //((Edit *)(CurItem->ObjPtr))->Select(-1,-1); // снимаем выделение
              // ...оно уже снимается в Edit::SetString()
            }
            break;

          case DI_LISTBOX: // пока не трогаем - не реализован
            return 0;

          default:  // подразумеваем, что остались
            return 0;
        }
        if(NeedInit)
          Dlg->InitDialogObjects(Param1); // переинициализируем элементы диалога
        if(Dlg->DialogMode.Check(DMODE_SHOW)) // достаточно ли этого????!!!!
        {
          Dlg->ShowDialog(Param1);
          ScrBuf.Flush();
        }
        return strlen((char *)Ptr); //???
      }
      return 0;

    /*****************************************************************/
    case DM_SETMAXTEXTLENGTH:
    {
      if((Type==DI_EDIT || Type==DI_PSWEDIT ||
          (Type==DI_COMBOBOX && !(CurItem->Flags & DIF_DROPDOWNLIST))) &&
         CurItem->ObjPtr)
      {
        int MaxLen=((Edit *)(CurItem->ObjPtr))->GetMaxLength();

        if((CurItem->Type==DI_EDIT || CurItem->Type==DI_COMBOBOX) &&
           (CurItem->Flags&DIF_VAREDIT))
          CurItem->Ptr.PtrLength=Param2; //???
        else if(Param2 > 511)
          Param2=511;

        ((Edit *)(CurItem->ObjPtr))->SetMaxLength(Param2);

        //if (DialogMode.Check(DMODE_INITOBJECTS)) //???
        Dlg->InitDialogObjects(Param1); // переинициализируем элементы диалога
        SetFarTitle(Dlg->GetDialogTitle());
        return MaxLen;
      }
      return 0;
    }

    /*****************************************************************/
    case DM_GETDLGITEM:
    {
      if(Param2 && !IsBadWritePtr((void*)Param2,sizeof(struct FarDialogItem)))
      {
        Dialog::ConvertItem(CVTITEM_TOPLUGIN,(struct FarDialogItem *)Param2,CurItem,1);
/*
        if(IsEdit(Type))
        {
          ((Edit *)(CurItem->ObjPtr))->GetString(Str,sizeof(Str));
          strcpy((char *)Param2,Str);
        }
        else
          strcpy(((struct FarDialogItem *)Param2)->Data,CurItem->Data);
*/
        return TRUE;
      }
      return FALSE;
    }

    /*****************************************************************/
    case DM_SETDLGITEM:
    {
      if(Param2 && !IsBadReadPtr((void*)Param2,sizeof(struct FarDialogItem)) &&
         Type == ((struct FarDialogItem *)Param2)->Type) // пока нефига менять тип
      {
        Dialog::ConvertItem(CVTITEM_FROMPLUGIN,(struct FarDialogItem *)Param2,CurItem,1);
        CurItem->Type=Type;
        // еще разок, т.к. данные могли быть изменены
        Dlg->InitDialogObjects(Param1);
        SetFarTitle(Dlg->GetDialogTitle());
        if(Dlg->DialogMode.Check(DMODE_SHOW))
        {
          Dlg->ShowDialog(Param1);
          ScrBuf.Flush();
        }
        return TRUE;
      }
      return FALSE;
    }


    /*****************************************************************/
    /* $ 18.08.2000 SVS
       + Разрешение/запрещение отрисовки диалога
    */
    case DM_ENABLEREDRAW:
    {
      if(Param1)
        Dlg->IsEnableRedraw++;
      else
        Dlg->IsEnableRedraw--;

      if(!Dlg->IsEnableRedraw)
        if(Dlg->DialogMode.Check(DMODE_INITOBJECTS))
        {
          Dlg->ShowDialog();
          ScrBuf.Flush();
//          Dlg->Show();
        }
      return 0;
    }
    /* SVS $ */

    /*****************************************************************/
    /* $ 03.01.2001 SVS
        + показать/скрыть элемент
        Param2: -1 - получить состояние
                 0 - погасить
                 1 - показать
        Return:  предыдущее состояние
    */
    case DM_SHOWITEM:
    {
      DWORD PrevFlags=CurItem->Flags;
      if(Param2 != -1)
      {
         if(Param2)
           CurItem->Flags&=~DIF_HIDDEN;
         else
           CurItem->Flags|=DIF_HIDDEN;
        if(Dlg->DialogMode.Check(DMODE_SHOW) && !(CurItem->Flags&DIF_HIDDEN))
        {
          // Либо все,  либо... только 1
          Dlg->ShowDialog(Dlg->GetDropDownOpened()?-1:Param1);
          ScrBuf.Flush();
        }
      }
      return (PrevFlags&DIF_HIDDEN)?FALSE:TRUE;
    }

    /*****************************************************************/
    /* $ 23.08.2000 SVS
       + показать/спрятать диалог.
    */
    case DM_SHOWDIALOG:
//      if(!Dlg->IsEnableRedraw)
      {
        if(Param1)
        {
          if(!Dlg->IsVisible())
            Dlg->Show();
        }
        else
        {
          if(Dlg->IsVisible())
            Dlg->Hide();
        }
      }
      return 0;
    /* SVS $ */

    /*****************************************************************/
    /* $ 23.08.2000 SVS
       + установить/взять данные диалога.
    */
    case DM_SETDLGDATA:
    {
      long PrewDataDialog=Dlg->DataDialog;
      Dlg->DataDialog=Param2;
      return PrewDataDialog;
    }

    /*****************************************************************/
    case DM_GETDLGDATA:
    {
      return Dlg->DataDialog;
    }
    /* SVS $ */

    /*****************************************************************/
    /* $ 23.08.2000 SVS
       + послать клавишу(ы)
    */
    case DM_KEY:
    {
      int *KeyArray=(int*)Param2;
      Dlg->DialogMode.Set(DMODE_KEY);
      for(I=0; I < Param1; ++I)
        Dlg->ProcessKey(KeyArray[I]);
      Dlg->DialogMode.Skip(DMODE_KEY);
      return 0;
    }
    /* SVS $ */

    /*****************************************************************/
    /* $ 23.08.2000 SVS
       + принудительно закрыть диалог
    */
    case DM_CLOSE:
    {
      if(Param1 == -1)
        Dlg->ExitCode=Dlg->FocusPos;
      else
        Dlg->ExitCode=Param1;
      /* $ 17.05.2001 DJ */
      Dlg->CloseDialog();
      /* DJ $ */
      return TRUE;  // согласен с закрытием
    }
    /* SVS $ */

    /*****************************************************************/
    /* $ 25.08.2000 SVS
        + получить координаты диалогового окна
    */
    case DM_GETDLGRECT:
    {
      if(Param2 && !IsBadWritePtr((void*)Param2,sizeof(SMALL_RECT)))
      {
        int x1,y1,x2,y2;
        Dlg->GetPosition(x1,y1,x2,y2);
        ((SMALL_RECT*)Param2)->Left=x1;
        ((SMALL_RECT*)Param2)->Top=y1;
        ((SMALL_RECT*)Param2)->Right=x2;
        ((SMALL_RECT*)Param2)->Bottom=y2;
        return TRUE;
      }
      return FALSE;
    }
    /* SVS $ */

    /*****************************************************************/
    /* $ 23.06.2001 KM */
    case DM_GETDROPDOWNOPENED: // Param1=0; Param2=0
    {
      return Dlg->GetDropDownOpened();
    }

    /*****************************************************************/
    case DM_SETDROPDOWNOPENED: // Param1=ID; Param2={TRUE|FALSE}
    {
      if (!Param2) // Закрываем любой открытый комбобокс или историю
      {
        if (Dlg->GetDropDownOpened())
        {
          Dlg->SetDropDownOpened(FALSE);
          Sleep(10);
        }
        return TRUE;
      }
      /* $ 09.12.2001 DJ
         у DI_PSWEDIT не бывает хистори!
      */
      else if (Param2 && (Type==DI_COMBOBOX || ((Type==DI_EDIT || Type==DI_FIXEDIT)
               && (CurItem->Flags&DIF_HISTORY)))) /* DJ $ */
      {
        // Открываем заданный в Param1 комбобокс или историю
        if (Dlg->GetDropDownOpened())
        {
          Dlg->SetDropDownOpened(FALSE);
          Sleep(10);
        }

        if (Dialog::SendDlgMessage(hDlg,DM_SETFOCUS,Param1,0))
        {
          Dlg->ProcessKey(KEY_CTRLDOWN);
          return TRUE;
        }
        else
          return FALSE;
      }
      return FALSE;
    }
    /* KM $ */

    /*****************************************************************/
    case DM_SETITEMPOSITION: // Param1 = ID; Param2 = SMALL_RECT
    {
      return Dlg->SetItemRect((int)Param1,(SMALL_RECT*)Param2);
    }

    /*****************************************************************/
    case DM_RESIZEDIALOG:
      // изменим вызов RESIZE.
      Param1=-1;

    /*****************************************************************/
    /* $ 30.08.2000 SVS
        + программное перемещение диалога
    */
    case DM_MOVEDIALOG:
    {
      int W1,H1;

      /* $ 10.08.2001 KM
        - Неверно вычислялась ширина диалога.
      */
      W1=Dlg->X2-Dlg->X1+1;
      H1=Dlg->Y2-Dlg->Y1+1;
      /* KM $ */
      // сохранили
      Dlg->OldX1=Dlg->X1;
      Dlg->OldY1=Dlg->Y1;
      Dlg->OldX2=Dlg->X2;
      Dlg->OldY2=Dlg->Y2;
      /* $ 30.05.2001 KM
         - Косячило центрирование диалога и изменение размера
      */
      // переместили
      if(Param1>0)   // абсолютно?
      {
        Dlg->X1=((COORD*)Param2)->X;
        Dlg->Y1=((COORD*)Param2)->Y;
        /* $ 10.08.2001 KM
          - Неверно вычислялись координаты X2 и Y2.
        */
        Dlg->X2=W1-1;
        Dlg->Y2=H1-1;
        /* KM $ */
        Dlg->CheckDialogCoord();
      }
      else if(Param1 == 0)   // значит относительно
      {
        Dlg->X1+=((COORD*)Param2)->X;
        Dlg->Y1+=((COORD*)Param2)->Y;
      }
      else // Resize, Param2=width/height
      {
        int OldW1,OldH1;
        OldW1=W1;
        OldH1=H1;
        W1=((COORD*)Param2)->X;
        H1=((COORD*)Param2)->Y;
        /* $ 11.10.2001 KM
          - Ещё одно уточнение при ресайзинге, с учётом предполагаемого
            выхода краёв диалога за границу экрана.
        */
        if(Dlg->X1+W1>ScrX)
          Dlg->X1=ScrX-W1+1;
        if(Dlg->Y1+H1>ScrY)
          Dlg->Y1=ScrY-H1+1;
        /* KM $ */

        if (W1<OldW1 || H1<OldH1)
        {
          Dlg->DialogMode.Set(DMODE_DRAWING);
          DialogItem *Item;
          SMALL_RECT Rect;
          for (I=0;I<Dlg->ItemCount;I++)
          {
            Item=Dlg->Item+I;
            Rect.Left=Item->X1;
            Rect.Top=Item->Y1;
            if (Item->X2>=W1)
            {
              Rect.Right=Item->X2-(OldW1-W1);
              Rect.Bottom=Item->Y2;
              Dlg->SetItemRect(I,&Rect);
            }
            if (Item->Y2>=H1)
            {
              Rect.Right=Item->X2;
              Rect.Bottom=Item->Y2-(OldH1-H1);
              Dlg->SetItemRect(I,&Rect);
            }
          }
          Dlg->DialogMode.Skip(DMODE_DRAWING);
        }
      }
      /* KM $ */
      // проверили и скорректировали
      if(Dlg->X1<0)
        Dlg->X1=0;
      if(Dlg->Y1<0)
        Dlg->Y1=0;
      /* $ 11.10.2001 KM
        - Ещё одно уточнение при ресайзинге, с учётом предполагаемого
          выхода краёв диалога за границу экрана.
      */
      if(Dlg->X1+W1>ScrX)
        Dlg->X1=ScrX-W1+1;
      if(Dlg->Y1+H1>ScrY)
        Dlg->Y1=ScrY-H1+1;
      /* KM $ */
      /* $ 10.08.2001 KM
        - Неверно вычислялись координаты X2 и Y2.
      */
      Dlg->X2=Dlg->X1+W1-1;
      Dlg->Y2=Dlg->Y1+H1-1;
      /* KM $ */

      if(Param1 < 0)   // размер?
      {
        ((COORD*)Param2)->X=Dlg->X2-Dlg->X1+1;
        ((COORD*)Param2)->Y=Dlg->Y2-Dlg->Y1+1;
      }
      else
      {
        ((COORD*)Param2)->X=Dlg->X1;
        ((COORD*)Param2)->Y=Dlg->Y1;
      }

      I=Dlg->IsVisible();// && Dlg->DialogMode.Check(DMODE_INITOBJECTS);
      if(I) Dlg->Hide();
      // приняли.
      Dlg->AdjustEditPos(Dlg->X1-Dlg->OldX1,Dlg->Y1-Dlg->OldY1);
      if(I) Dlg->Show(); // только если диалог был виден

      return Param2;
    }
    /* SVS $ */

    /*****************************************************************/
    /* $ 31.08.2000 SVS
        + переключение/получение состояния Enable/Disable элемента
    */
    case DM_ENABLE:
    {
      DWORD PrevFlags=CurItem->Flags;
      if(Param2 != -1)
      {
         if(Param2)
           CurItem->Flags&=~DIF_DISABLE;
         else
           CurItem->Flags|=DIF_DISABLE;
      }
      return (PrevFlags&DIF_DISABLE)?FALSE:TRUE;
    }
    /* SVS $ */

    /*****************************************************************/
    case DM_KILLSAVESCREEN:
    {
      if (Dlg->SaveScr) Dlg->SaveScr->Discard();
      if (Dlg->ShadowSaveScr) Dlg->ShadowSaveScr->Discard();
      return TRUE;
    }

    /*****************************************************************/
    /*
      Msg=DM_ALLKEYMODE
      Param1 = -1 - получить состояние
             =  0 - выключить
             =  1 - включить
      Ret = состояние
    */
    case DM_ALLKEYMODE:
    {
      if(Param1 == -1)
        return IsProcessAssignMacroKey;
      BOOL OldIsProcessAssignMacroKey=IsProcessAssignMacroKey;
      IsProcessAssignMacroKey=Param1;
      return OldIsProcessAssignMacroKey;
    }

    /*****************************************************************/
    // получить позицию и размеры контрола
    case DM_GETITEMPOSITION: // Param1=ID, Param2=*SMALL_RECT
      if(Param2 && !IsBadWritePtr((void*)Param2,sizeof(SMALL_RECT)))
      {
        RECT Rect;
        if(Dlg->GetItemRect(Param1,Rect))
        {
          ((SMALL_RECT *)Param2)->Left=(short)Rect.left;
          ((SMALL_RECT *)Param2)->Top=(short)Rect.top;
          ((SMALL_RECT *)Param2)->Right=(short)Rect.right;
          ((SMALL_RECT *)Param2)->Bottom=(short)Rect.bottom;
          return TRUE;
        }
      }
      return FALSE;

    /*****************************************************************/
    case DM_SETMOUSEEVENTNOTIFY: // Param1 = 0 on, 1 off, -1 - get
    {
      int State=Dlg->DialogMode.Check(DMODE_MOUSEEVENT)?TRUE:FALSE;
      if(Param1 != -1)
      {
        if(!Param1)
          Dlg->DialogMode.Skip(DMODE_MOUSEEVENT);
        else
          Dlg->DialogMode.Set(DMODE_MOUSEEVENT);
      }
      return State;
    }

    /*****************************************************************/
    case DN_RESIZECONSOLE:
    {
      break;
    }

    /*****************************************************************/
    case DM_SETITEMDATA:
    {
      long PrewDataDialog=CurItem->UserData;
      CurItem->UserData=Param2;
      return PrewDataDialog;
    }

    /*****************************************************************/
    case DM_GETITEMDATA:
    {
      return CurItem->UserData;
    }

    /*****************************************************************/
    case DM_EDITUNCHANGEDFLAG: // -1 Get, 0 - Skip, 1 - Set; Выделение блока снимается.
    {
      if(IsEdit(Type))
      {
        Edit *EditLine=(Edit *)(CurItem->ObjPtr);
        int ClearFlag=EditLine->GetClearFlag();
        if(Param2 >= 0)
        {
          EditLine->SetClearFlag(Param2);
          EditLine->Select(-1,0); // снимаем выделение
          if(Dlg->DialogMode.Check(DMODE_SHOW)) //???
          {
            Dlg->ShowDialog(Param1);
            ScrBuf.Flush();
          }
        }
        return ClearFlag;
      }
      break;
    }
  }

  // Все, что сами не отрабатываем - посылаем на обработку обработчику.
  return Dlg->DlgProc(hDlg,Msg,Param1,Param2);
}
/* SVS $ */


//////////////////////////////////////////////////////////////////////////
