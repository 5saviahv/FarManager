Логирование работы FAR
~~~~~~~~~~~~~~~~~~~~~~

Введение
~~~~~~~~
  В дебажной версии предусмотрен механизм логирования. 

  Логирование будет только если: 

  1. включен режим ScrollLock 
  2. в параметрах компиляции указаны макросы вида: 
     - SYSLOG_XXX 
     - SYSLOG_FARSYSLOG 
     - SYSLOG 
  3. по сорцам в нужных местах раскиданы макросы типа _XXX() 

  Если указан SYSLOG_FARSYSLOG, то FAR экспортирует 3 функции, которые можно заюзать в плагинах: 

    void WINAPIV _export FarSysLog(char *ModuleName,int Level,char *fmt,...);
    void WINAPI  _export FarSysLogDump(char *ModuleName,DWORD StartAddress,LPBYTE Buf,int SizeBuf);
    void WINAPI _export FarSysLog_INPUT_RECORD_Dump(char *ModuleName,INPUT_RECORD *rec);

  В MSVC кроме вывода в файл логирование передается в окно результатов (используется 
  OutputDebugString()) 

  Вся математика логирования находится в файле syslog.cpp. Макрос и описания в fn.hpp


Макросы
~~~~~~~
  общие макросы
  ~~~~~~~~~~~~~
  _D()                включается, если в параметрах компиляции включен _DEBUG 
  _ALGO()             предназначен для логирования "алгоритмов работы" тех или иных 
                      функций АПИ  (макрос компиляции SYSLOG_ALGO). 
  _DIALOG()           диалоги (макрос компиляции SYSLOG_DIALOG) 
  _KEYMACRO()         макросы (макрос компиляции SYSLOG_KEYMACRO) 
  _KEYMACRO_PARSE()   макросы (макрос компиляции SYSLOG_KEYMACRO_PARSE) 
  _ECTLLOG()          ECTL_* команды (макрос компиляции SYSLOG_ECTL) 
  _FCTLLOG()          FCTL_* команды (макрос компиляции SYSLOG_FCTL) 
  _ACTLLOG()          ACTL_* команды (макрос компиляции SYSLOG_ACTL) 
  _VCTLLOG()          VCTL_* команды (макрос компиляции SYSLOG_VCTL) 
  _SYS_EE_REDRAW()    логирование прорисовки в редакторе (макрос компиляции SYSLOG_EE_REDRAW) 
  _NWZ()              что-то про "новый двиг" (макрос компиляции SYSLOG_NWZ) 
  _LOGCOPYR()         функция копирования (макрос компиляции SYSLOG_COPYR) 

  персональные макросы
  ~~~~~~~~~~~~~~~~~~~~
  _OT()    - Олег Тараненко (макрос компиляции SYSLOG_OT) 
  _SVS()   - Valentin Skirdin (макрос компиляции SYSLOG_SVS) 
  _DJ()    - Дмитрий Жемеров (макрос компиляции SYSLOG_DJ) 
  _WARP()  - ... (макрос компиляции SYSLOG_WARP) 
  _VVM()   - ... (макрос компиляции SYSLOG_VVM) 
  _IS()    - ... (макрос компиляции SYSLOG_IS) 
  _AT()    - ... (макрос компиляции SYSLOG_AT) 
  _tran()  - ... (макрос компиляции SYSLOG_tran) 
  _SKV()   - ... (макрос компиляции SYSLOG_SKV) 
  _KM()    - ... (макрос компиляции SYSLOG_KM) 
  _TREX()  - ... (макрос компиляции SYSLOG_TREX) 
  _YJH()   - ... (макрос компиляции SYSLOG_YJH) 



Функции
~~~~~~~

  функции преобразования
  ~~~~~~~~~~~~~~~~~~~~~~
    Код клавиши в строку
     const char *_FARKEY_ToName(int Key);

    Код макро-опкода в строку
     const char *_MCODE_ToName(int OpCode);
    
    Код виртуальной клавиши в строку
     const char *_VK_KEY_ToName(int VkKey);

    "Разжевать" ECTL-команду
     const char *_ECTL_ToName(int Command);

     Если добавили новую ECTL-команду, то в функцию syslog.cpp::_ECTL_ToName()
     нужно добавить дефайн. Например, вводим ECTL_FOOBAR, в этом случае 
     добавляем строку: 
 
     DEF_ECTL_(FOOBAR),

    "Разжевать" FCTL-команду
     const char *_FCTL_ToName(int Command);
    
     Если добавили новую FCTL-команду, то в функцию syslog.cpp::_FCTL_ToName() 
     нужно добавить дефайн. Например, вводим FCTL_FOOBAR, в этом случае 
     добавляем строку: 

     DEF_FCTL_(FOOBAR),

    "Разжевать" ACTL-команду
     const char *_ACTL_ToName(int Command);
    
    "Разжевать" VCTL-команду
     const char *_VCTL_ToName(int Command);

    EE-команду в текст
     const char *_EE_ToName(int Command);

    EEREDRAW в текст
     const char *_EEREDRAW_ToName(int Command);

    ESPT в текст
     const char *_ESPT_ToName(int Command);

    VE-команду в текст
     const char *_VE_ToName(int Command);

    Сообщение/события диалоговые в текст
     const char *_DLGMSG_ToName(int Msg);

    "Разжевать" INPUT_RECORD
     const char *_INPUT_RECORD_Dump(INPUT_RECORD *Rec);

    Линейный дамп памяти
     Получить строковый буфер линейного дампа памяти (после вызова этой 
     функции нужно освободить память) 

     const char *_SysLog_LinearDump(LPBYTE Buf,int SizeBuf);


  функции логирования
  ~~~~~~~~~~~~~~~~~~~
    Дамп памяти 
     void SysLogDump(char *Title,DWORD StartAddress,LPBYTE Buf,int SizeBuf,FILE *fp=NULL);

    Сделать отступ 
     void SysLog(int l);
   
    Вывести в формате (аля printf) 
     void SysLog(char *fmt,...);
 
    Вывести в формате (аля printf) с отступом 
     void SysLog(int l,char *fmt,...);
 
    Вывод в лог результата GetLastError() 
     void SysLogLastError(void);
 
    Вывести состояние хипа 
     void ShowHeap();
 
    Проверить хип на corrupt 
     void CheckHeap(int NumLine);
 
    Дамп структуры OpenPluginInfo 
     void GetOpenPluginInfo_Dump(char *Title,const struct OpenPluginInfo *Info,FILE *fp);

    Дамп входного консольного буфера ("скока там еще осталось то") 
     void INPUT_RECORD_DumpBuffer(FILE *fp=NULL);
 
    Дамп структуры PanelViewSettings 
     void PanelViewSettings_Dump(char *Title,const struct PanelViewSettings &ViewSettings,FILE *fp=NULL);
 
    Дамп массива структуры PluginsStackItem 
     void PluginsStackItem_Dump(char *Title,const struct PluginsStackItem *StackItems,int ItemNumber,FILE *fp=NULL);

    Дам экрана 
     void SaveScreenDumpBuffer(const char *Title,const CHAR_INFO *Buffer,int X1,int Y1,int X2,int Y2,int RealScreen,FILE *fp=NULL);
 
    Дам класса Manager 
     void ManagerClass_Dump(char *Title,const Manager *m=NULL,FILE *fp=NULL);
 
    Дамп GetVolumeInformation 
     void GetVolumeInformation_Dump(char *Title,LPCTSTR lpRootPathName,LPTSTR lpVolumeNameBuffer,DWORD nVolumeNameSize,
                                              DWORD lpVolumeSerialNumber, DWORD lpMaximumComponentLength, DWORD lpFileSystemFlags,
                                              LPTSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize,FILE *fp=NULL);
    Дамп WIN32_FIND_DATA 
     void WIN32_FIND_DATA_Dump(char *Title,const WIN32_FIND_DATA &fd,FILE *fp=NULL);

  Классы
  ~~~~~~
    CleverSysLog - "умный логер": конструктор делает отступ, в 
    деструкторе отступ возвращается обратно.
